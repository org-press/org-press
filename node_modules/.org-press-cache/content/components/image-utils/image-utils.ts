// Source display only (not executed)
export default "/**\n * Options for image processing\n */\nexport interface ImageProcessOptions {\n  /** Threshold for white background removal (0-255), default 240 */\n  whiteThreshold?: number;\n  /** Fuzz factor for color matching (0-1), default 0.1 */\n  fuzzFactor?: number;\n  /** Convert to grayscale */\n  grayscale?: boolean;\n  /** Invert colors */\n  invert?: boolean;\n  /** Contrast adjustment (-1 to 1), default 0 */\n  contrast?: number;\n}\n\nexport interface ProcessedImage {\n  canvas: HTMLCanvasElement;\n  imageData: ImageData;\n  width: number;\n  height: number;\n}\n\n/**\n * Load an image from URL and return as canvas\n */\nexport async function loadImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = url;\n  });\n}\n\n/**\n * Remove white/light background from image, making it transparent\n */\nexport function removeWhiteBackground(\n  imageData: ImageData,\n  threshold: number = 240,\n  fuzz: number = 0.1\n): ImageData {\n  const data = imageData.data;\n  const fuzzAmount = Math.floor(255 * fuzz);\n\n  for (let i = 0; i < data.length; i += 4) {\n    const r = data[i];\n    const g = data[i + 1];\n    const b = data[i + 2];\n\n    // Check if pixel is close to white\n    const isWhite =\n      r >= threshold - fuzzAmount &&\n      g >= threshold - fuzzAmount &&\n      b >= threshold - fuzzAmount &&\n      Math.abs(r - g) < fuzzAmount &&\n      Math.abs(g - b) < fuzzAmount &&\n      Math.abs(r - b) < fuzzAmount;\n\n    if (isWhite) {\n      data[i + 3] = 0; // Set alpha to transparent\n    }\n  }\n\n  return imageData;\n}\n\n/**\n * Convert image to grayscale\n */\nexport function toGrayscale(imageData: ImageData): ImageData {\n  const data = imageData.data;\n\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    data[i] = gray;\n    data[i + 1] = gray;\n    data[i + 2] = gray;\n  }\n\n  return imageData;\n}\n\n/**\n * Invert image colors\n */\nexport function invertColors(imageData: ImageData): ImageData {\n  const data = imageData.data;\n\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = 255 - data[i];\n    data[i + 1] = 255 - data[i + 1];\n    data[i + 2] = 255 - data[i + 2];\n  }\n\n  return imageData;\n}\n\n/**\n * Adjust contrast\n * @param factor -1 to 1, where 0 is no change\n */\nexport function adjustContrast(imageData: ImageData, factor: number): ImageData {\n  const data = imageData.data;\n  const contrast = (factor + 1) / (1 - factor);\n\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = Math.max(0, Math.min(255, contrast * (data[i] - 128) + 128));\n    data[i + 1] = Math.max(0, Math.min(255, contrast * (data[i + 1] - 128) + 128));\n    data[i + 2] = Math.max(0, Math.min(255, contrast * (data[i + 2] - 128) + 128));\n  }\n\n  return imageData;\n}\n\n/**\n * Process an image with the given options\n */\nexport async function processImage(\n  url: string,\n  options: ImageProcessOptions = {}\n): Promise<ProcessedImage> {\n  const {\n    whiteThreshold = 240,\n    fuzzFactor = 0.1,\n    grayscale = false,\n    invert = false,\n    contrast = 0,\n  } = options;\n\n  // Load image\n  const img = await loadImage(url);\n\n  // Create canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d')!;\n\n  // Draw image\n  ctx.drawImage(img, 0, 0);\n\n  // Get image data\n  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n  // Apply processing pipeline\n  imageData = removeWhiteBackground(imageData, whiteThreshold, fuzzFactor);\n\n  if (grayscale) {\n    imageData = toGrayscale(imageData);\n  }\n\n  if (invert) {\n    imageData = invertColors(imageData);\n  }\n\n  if (contrast !== 0) {\n    imageData = adjustContrast(imageData, contrast);\n  }\n\n  // Put processed data back\n  ctx.putImageData(imageData, 0, 0);\n\n  return {\n    canvas,\n    imageData,\n    width: canvas.width,\n    height: canvas.height,\n  };\n}\n\n/**\n * Get brightness values from processed image for halftone\n * Returns array of { x, y, brightness, alpha } for each grid point\n */\nexport function sampleBrightness(\n  imageData: ImageData,\n  gridSize: number\n): Array<{ x: number; y: number; brightness: number; alpha: number }> {\n  const { width, height, data } = imageData;\n  const samples: Array<{ x: number; y: number; brightness: number; alpha: number }> = [];\n\n  const stepX = width / gridSize;\n  const stepY = height / gridSize;\n\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      const imgX = Math.floor(gx * stepX);\n      const imgY = Math.floor(gy * stepY);\n      const i = (imgY * width + imgX) * 4;\n\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      const a = data[i + 3];\n\n      // Calculate luminosity\n      const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\n      samples.push({\n        x: gx - gridSize / 2,\n        y: (gridSize - gy) - gridSize / 2, // Flip Y\n        brightness,\n        alpha: a / 255,\n      });\n    }\n  }\n\n  return samples;\n}\n\nexport default { processImage, sampleBrightness, loadImage };\n";