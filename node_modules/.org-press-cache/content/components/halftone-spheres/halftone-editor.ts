// Source display only (not executed)
export default "import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { proxyImageUrl } from './halftone-spheres.org?name=image-utils';\n\n/**\n * Resolution-independent halftone illustration format\n */\nexport interface HalftoneIllustration {\n  version: 1;\n  name: string;\n  type: 'image' | 'typecase' | 'custom';\n  /** Original source (URL or config) for reference */\n  source?: string | object;\n  /** Normalized point data (0-1 range) */\n  points: Array<{\n    /** Normalized X position (0-1) */\n    nx: number;\n    /** Normalized Y position (0-1) */\n    ny: number;\n    /** Normalized Z depth (0-1, 0=back, 1=front) */\n    nz: number;\n    /** Normalized scale (0-1) */\n    scale: number;\n  }>;\n  /** Illustration transform */\n  transform: {\n    x: number;\n    y: number;\n    z: number;\n    scale: number;\n  };\n  /** Camera settings */\n  camera: {\n    position: { x: number; y: number; z: number };\n    lookAt: { x: number; y: number; z: number };\n    fov: number;\n  };\n  /** Creation metadata */\n  created?: string;\n}\n\nexport interface EditorOptions {\n  width?: number;\n  height?: number;\n  backgroundColor?: number;\n  sphereColor?: number;\n  /** Initial grid size for preview (can change) */\n  gridSize?: number;\n}\n\nexport interface EditorResult {\n  container: HTMLElement;\n  /** Load illustration from URL */\n  loadFromUrl: (url: string) => Promise<void>;\n  /** Load from saved illustration */\n  loadIllustration: (illustration: HalftoneIllustration) => void;\n  /** Export current state */\n  exportIllustration: (name: string) => HalftoneIllustration;\n  /** Update grid resolution (re-renders) */\n  setGridSize: (size: number) => void;\n  /** Dispose resources */\n  dispose: () => void;\n}\n\n/**\n * Load an image from URL\n * Uses CORS proxy for external URLs automatically\n */\nasync function loadImage(url: string): Promise<HTMLImageElement> {\n  // Use proxy for external URLs to avoid CORS issues\n  const proxyUrl = proxyImageUrl(url);\n\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error(`Failed to load image: ${url}`));\n    img.src = proxyUrl;\n  });\n}\n\n/**\n * Process image to normalized point data\n */\nasync function imageToNormalizedPoints(\n  url: string,\n  sampleSize: number = 100\n): Promise<HalftoneIllustration['points']> {\n  // Load image\n  const img = await loadImage(url);\n\n  // Draw to canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = sampleSize;\n  canvas.height = sampleSize;\n  const ctx = canvas.getContext('2d')!;\n\n  // Draw image centered and scaled to fit\n  const scale = Math.min(sampleSize / img.width, sampleSize / img.height);\n  const w = img.width * scale;\n  const h = img.height * scale;\n  const x = (sampleSize - w) / 2;\n  const y = (sampleSize - h) / 2;\n\n  ctx.fillStyle = '#ffffff';\n  ctx.fillRect(0, 0, sampleSize, sampleSize);\n  ctx.drawImage(img, x, y, w, h);\n\n  // Sample pixels\n  const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);\n  const { data } = imageData;\n  const points: HalftoneIllustration['points'] = [];\n\n  for (let py = 0; py < sampleSize; py++) {\n    for (let px = 0; px < sampleSize; px++) {\n      const i = (py * sampleSize + px) * 4;\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      const a = data[i + 3];\n\n      // Skip transparent\n      if (a < 30) continue;\n\n      // Calculate brightness (inverted - dark = visible)\n      const brightness = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n\n      // Skip very light areas\n      if (brightness < 0.05) continue;\n\n      points.push({\n        nx: px / sampleSize,\n        ny: py / sampleSize,\n        nz: brightness, // Depth based on darkness\n        scale: brightness,\n      });\n    }\n  }\n\n  return points;\n}\n\n/**\n * Render normalized points at a specific grid size\n */\nfunction renderPoints(\n  points: HalftoneIllustration['points'],\n  transform: HalftoneIllustration['transform'],\n  gridSize: number,\n  depthScale: number = 10\n): Array<{ x: number; y: number; z: number; scale: number }> {\n  const result: Array<{ x: number; y: number; z: number; scale: number }> = [];\n\n  const halfGrid = gridSize / 2;\n  const { x: tx, y: ty, z: tz, scale: tScale } = transform;\n\n  for (const point of points) {\n    // Convert normalized coords to grid coords\n    const x = (point.nx - 0.5) * gridSize * tScale + tx;\n    const y = (0.5 - point.ny) * gridSize * tScale + ty; // Flip Y\n    const z = point.nz * depthScale + tz;\n    const scale = point.scale * tScale * 0.5;\n\n    result.push({ x, y, z, scale });\n  }\n\n  return result;\n}\n\n/**\n * Create the halftone illustration editor\n */\nexport function createHalftoneEditor(options: EditorOptions = {}): EditorResult {\n  const {\n    width = 800,\n    height = 600,\n    backgroundColor = 0x0a0a0f,\n    sphereColor = 0xffffff,\n    gridSize: initialGridSize = 80,\n  } = options;\n\n  // State\n  let currentPoints: HalftoneIllustration['points'] = [];\n  let currentSource: string | object | undefined;\n  let currentType: HalftoneIllustration['type'] = 'image';\n  let gridSize = initialGridSize;\n\n  let transform = {\n    x: 0,\n    y: 0,\n    z: 0,\n    scale: 1,\n  };\n\n  // Create container\n  const container = document.createElement('div');\n  container.style.cssText = `\n    display: flex;\n    flex-direction: column;\n    gap: 1rem;\n    padding: 1rem;\n    background: #1a1a2e;\n    border-radius: 8px;\n  `;\n\n  // Controls panel\n  const controls = document.createElement('div');\n  controls.style.cssText = `\n    display: flex;\n    flex-wrap: wrap;\n    gap: 0.5rem;\n    align-items: center;\n  `;\n\n  // URL input\n  const urlInput = document.createElement('input');\n  urlInput.type = 'text';\n  urlInput.placeholder = 'Image URL...';\n  urlInput.style.cssText = `\n    flex: 1;\n    min-width: 200px;\n    padding: 0.5rem;\n    background: #2a2a4e;\n    border: 1px solid #3a3a6e;\n    border-radius: 4px;\n    color: white;\n  `;\n\n  // Load button\n  const loadBtn = document.createElement('button');\n  loadBtn.textContent = 'Load Image';\n  loadBtn.style.cssText = `\n    padding: 0.5rem 1rem;\n    background: #4a4a8e;\n    border: none;\n    border-radius: 4px;\n    color: white;\n    cursor: pointer;\n  `;\n\n  // Grid size selector\n  const gridLabel = document.createElement('label');\n  gridLabel.textContent = 'Grid: ';\n  gridLabel.style.color = 'white';\n\n  const gridSelect = document.createElement('select');\n  gridSelect.style.cssText = `\n    padding: 0.5rem;\n    background: #2a2a4e;\n    border: 1px solid #3a3a6e;\n    border-radius: 4px;\n    color: white;\n  `;\n  [40, 60, 80, 100, 120, 150, 200].forEach(size => {\n    const opt = document.createElement('option');\n    opt.value = String(size);\n    opt.textContent = String(size);\n    if (size === initialGridSize) opt.selected = true;\n    gridSelect.appendChild(opt);\n  });\n\n  // Export button\n  const exportBtn = document.createElement('button');\n  exportBtn.textContent = 'Export JSON';\n  exportBtn.style.cssText = `\n    padding: 0.5rem 1rem;\n    background: #2a8a4a;\n    border: none;\n    border-radius: 4px;\n    color: white;\n    cursor: pointer;\n  `;\n\n  // Import button\n  const importBtn = document.createElement('button');\n  importBtn.textContent = 'Import JSON';\n  importBtn.style.cssText = `\n    padding: 0.5rem 1rem;\n    background: #8a4a2a;\n    border: none;\n    border-radius: 4px;\n    color: white;\n    cursor: pointer;\n  `;\n\n  controls.appendChild(urlInput);\n  controls.appendChild(loadBtn);\n  controls.appendChild(gridLabel);\n  controls.appendChild(gridSelect);\n  controls.appendChild(exportBtn);\n  controls.appendChild(importBtn);\n\n  // Transform controls\n  const transformControls = document.createElement('div');\n  transformControls.style.cssText = `\n    display: flex;\n    gap: 1rem;\n    align-items: center;\n    color: white;\n    font-size: 0.85rem;\n  `;\n\n  const createSlider = (label: string, min: number, max: number, value: number, step: number, onChange: (v: number) => void) => {\n    const wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 0.25rem;';\n\n    const lbl = document.createElement('span');\n    lbl.textContent = label;\n\n    const slider = document.createElement('input');\n    slider.type = 'range';\n    slider.min = String(min);\n    slider.max = String(max);\n    slider.value = String(value);\n    slider.step = String(step);\n    slider.style.width = '80px';\n\n    const valDisplay = document.createElement('span');\n    valDisplay.textContent = String(value);\n    valDisplay.style.width = '40px';\n\n    slider.oninput = () => {\n      const v = parseFloat(slider.value);\n      valDisplay.textContent = v.toFixed(1);\n      onChange(v);\n    };\n\n    wrapper.appendChild(lbl);\n    wrapper.appendChild(slider);\n    wrapper.appendChild(valDisplay);\n    return { wrapper, slider, valDisplay };\n  };\n\n  const xSlider = createSlider('X:', -50, 50, 0, 1, v => { transform.x = v; updateMesh(); });\n  const ySlider = createSlider('Y:', -50, 50, 0, 1, v => { transform.y = v; updateMesh(); });\n  const zSlider = createSlider('Z:', -20, 20, 0, 1, v => { transform.z = v; updateMesh(); });\n  const scaleSlider = createSlider('Scale:', 0.1, 3, 1, 0.1, v => { transform.scale = v; updateMesh(); });\n\n  transformControls.appendChild(xSlider.wrapper);\n  transformControls.appendChild(ySlider.wrapper);\n  transformControls.appendChild(zSlider.wrapper);\n  transformControls.appendChild(scaleSlider.wrapper);\n\n  // Canvas container\n  const canvasContainer = document.createElement('div');\n  canvasContainer.style.cssText = `\n    width: 100%;\n    height: ${height}px;\n    border-radius: 4px;\n    overflow: hidden;\n  `;\n\n  // Status bar\n  const status = document.createElement('div');\n  status.style.cssText = `\n    color: #888;\n    font-size: 0.85rem;\n  `;\n  status.textContent = 'Ready. Enter an image URL and click Load.';\n\n  container.appendChild(controls);\n  container.appendChild(transformControls);\n  container.appendChild(canvasContainer);\n  container.appendChild(status);\n\n  // Three.js setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(backgroundColor);\n\n  const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);\n  camera.position.set(0, 0, 80);\n\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  canvasContainer.appendChild(renderer.domElement);\n\n  const orbitControls = new OrbitControls(camera, renderer.domElement);\n  orbitControls.enableDamping = true;\n  orbitControls.dampingFactor = 0.05;\n\n  // Sphere mesh\n  const sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8);\n  const sphereMaterial = new THREE.MeshBasicMaterial({ color: sphereColor });\n  let instancedMesh: THREE.InstancedMesh | null = null;\n\n  const matrix = new THREE.Matrix4();\n\n  function updateMesh() {\n    if (currentPoints.length === 0) return;\n\n    const rendered = renderPoints(currentPoints, transform, gridSize);\n\n    // Recreate mesh if point count changed\n    if (!instancedMesh || instancedMesh.count !== rendered.length) {\n      if (instancedMesh) {\n        scene.remove(instancedMesh);\n        instancedMesh.dispose();\n      }\n      instancedMesh = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, rendered.length);\n      scene.add(instancedMesh);\n    }\n\n    // Update positions\n    rendered.forEach((point, i) => {\n      matrix.makeScale(point.scale, point.scale, point.scale);\n      matrix.setPosition(point.x, point.y, point.z);\n      instancedMesh!.setMatrixAt(i, matrix);\n    });\n    instancedMesh.instanceMatrix.needsUpdate = true;\n\n    status.textContent = `Points: ${rendered.length} | Grid: ${gridSize} | Use mouse to orbit camera`;\n  }\n\n  // Animation loop\n  let animationId: number;\n  function animate() {\n    animationId = requestAnimationFrame(animate);\n    orbitControls.update();\n    renderer.render(scene, camera);\n  }\n  animate();\n\n  // Event handlers\n  const loadFromUrl = async (url: string) => {\n    status.textContent = 'Loading image...';\n    try {\n      currentPoints = await imageToNormalizedPoints(url, 100);\n      currentSource = url;\n      currentType = 'image';\n      updateMesh();\n      status.textContent = `Loaded ${currentPoints.length} points from image`;\n    } catch (e) {\n      status.textContent = `Error loading image: ${e}`;\n    }\n  };\n\n  loadBtn.onclick = () => {\n    if (urlInput.value) loadFromUrl(urlInput.value);\n  };\n\n  urlInput.onkeydown = (e) => {\n    if (e.key === 'Enter' && urlInput.value) loadFromUrl(urlInput.value);\n  };\n\n  gridSelect.onchange = () => {\n    gridSize = parseInt(gridSelect.value);\n    updateMesh();\n  };\n\n  const exportIllustration = (name: string): HalftoneIllustration => {\n    return {\n      version: 1,\n      name,\n      type: currentType,\n      source: currentSource,\n      points: currentPoints,\n      transform: { ...transform },\n      camera: {\n        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },\n        lookAt: { x: orbitControls.target.x, y: orbitControls.target.y, z: orbitControls.target.z },\n        fov: camera.fov,\n      },\n      created: new Date().toISOString(),\n    };\n  };\n\n  exportBtn.onclick = () => {\n    const name = prompt('Illustration name:', 'my-illustration') || 'illustration';\n    const illustration = exportIllustration(name);\n    const json = JSON.stringify(illustration, null, 2);\n\n    // Copy to clipboard\n    navigator.clipboard.writeText(json).then(() => {\n      status.textContent = 'JSON copied to clipboard!';\n    }).catch(() => {\n      // Fallback: show in prompt\n      console.log(json);\n      status.textContent = 'JSON logged to console (clipboard failed)';\n    });\n  };\n\n  const loadIllustration = (illustration: HalftoneIllustration) => {\n    currentPoints = illustration.points;\n    currentSource = illustration.source;\n    currentType = illustration.type;\n    transform = { ...illustration.transform };\n\n    // Update UI\n    xSlider.slider.value = String(transform.x);\n    xSlider.valDisplay.textContent = transform.x.toFixed(1);\n    ySlider.slider.value = String(transform.y);\n    ySlider.valDisplay.textContent = transform.y.toFixed(1);\n    zSlider.slider.value = String(transform.z);\n    zSlider.valDisplay.textContent = transform.z.toFixed(1);\n    scaleSlider.slider.value = String(transform.scale);\n    scaleSlider.valDisplay.textContent = transform.scale.toFixed(1);\n\n    // Update camera\n    if (illustration.camera) {\n      camera.position.set(\n        illustration.camera.position.x,\n        illustration.camera.position.y,\n        illustration.camera.position.z\n      );\n      orbitControls.target.set(\n        illustration.camera.lookAt.x,\n        illustration.camera.lookAt.y,\n        illustration.camera.lookAt.z\n      );\n      camera.fov = illustration.camera.fov;\n      camera.updateProjectionMatrix();\n    }\n\n    updateMesh();\n    status.textContent = `Loaded illustration: ${illustration.name}`;\n  };\n\n  importBtn.onclick = () => {\n    const json = prompt('Paste illustration JSON:');\n    if (json) {\n      try {\n        const illustration = JSON.parse(json) as HalftoneIllustration;\n        loadIllustration(illustration);\n      } catch (e) {\n        status.textContent = `Error parsing JSON: ${e}`;\n      }\n    }\n  };\n\n  const setGridSize = (size: number) => {\n    gridSize = size;\n    gridSelect.value = String(size);\n    updateMesh();\n  };\n\n  const dispose = () => {\n    cancelAnimationFrame(animationId);\n    orbitControls.dispose();\n    renderer.dispose();\n    sphereGeometry.dispose();\n    sphereMaterial.dispose();\n    if (instancedMesh) instancedMesh.dispose();\n  };\n\n  return {\n    container,\n    loadFromUrl,\n    loadIllustration,\n    exportIllustration,\n    setGridSize,\n    dispose,\n  };\n}\n\n/**\n * Render a saved illustration at a specific resolution\n * Use this in production to render from cached data\n */\nexport function renderIllustration(\n  illustration: HalftoneIllustration,\n  gridSize: number,\n  options: {\n    depthScale?: number;\n    sphereScale?: number;\n  } = {}\n): Map<string, { x: number; y: number; z: number; scale: number }> {\n  const { depthScale = 10, sphereScale = 1 } = options;\n\n  const rendered = renderPoints(illustration.points, illustration.transform, gridSize, depthScale);\n  const targets = new Map<string, { x: number; y: number; z: number; scale: number }>();\n\n  // Map to grid positions\n  rendered.forEach((point, i) => {\n    const gx = Math.floor(point.x + gridSize / 2);\n    const gy = Math.floor(gridSize / 2 - point.y);\n    const key = `${gx},${gy}`;\n\n    // If position already has a point, keep the one with larger scale\n    const existing = targets.get(key);\n    if (!existing || point.scale > existing.scale) {\n      targets.set(key, {\n        x: point.x,\n        y: point.y,\n        z: point.z,\n        scale: point.scale * sphereScale,\n      });\n    }\n  });\n\n  // Fill remaining grid positions with invisible spheres\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      const key = `${gx},${gy}`;\n      if (!targets.has(key)) {\n        targets.set(key, {\n          x: gx - gridSize / 2,\n          y: gridSize / 2 - gy,\n          z: 0,\n          scale: 0,\n        });\n      }\n    }\n  }\n\n  return targets;\n}\n\nexport default createHalftoneEditor;\n";