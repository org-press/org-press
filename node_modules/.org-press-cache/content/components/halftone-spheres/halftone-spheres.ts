// Source display only (not executed)
export default "import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { proxyImageUrl } from './halftone-spheres.org?name=image-utils';\n\nexport interface HalftoneOptions {\n  imageUrl: string;\n  gridSize?: number;\n  sphereScale?: number;\n  backgroundColor?: number;\n  sphereColor?: number;\n  width?: number;\n  height?: number;\n  /** Animation duration in seconds for spheres to reach final position */\n  animationDuration?: number;\n  /** Spread of random delays (0-1), higher = more staggered */\n  animationSpread?: number;\n}\n\nexport interface HalftoneResult {\n  renderer: THREE.WebGLRenderer;\n  scene: THREE.Scene;\n  camera: THREE.PerspectiveCamera;\n  controls: OrbitControls;\n  animate: () => void;\n  dispose: () => void;\n  /** Restart the expansion animation */\n  replay: () => void;\n}\n\ninterface SphereData {\n  targetPosition: THREE.Vector3;\n  scale: number;\n  /** Random delay before this sphere starts moving (0-1) */\n  delay: number;\n  /** Random speed multiplier for variety */\n  speed: number;\n}\n\n/**\n * Load an image and get its pixel data\n * Uses CORS proxy for external URLs automatically\n */\nasync function getImageData(url: string): Promise<ImageData> {\n  // Use proxy for external URLs to avoid CORS issues\n  const proxyUrl = proxyImageUrl(url);\n\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d')!;\n      ctx.drawImage(img, 0, 0);\n      resolve(ctx.getImageData(0, 0, img.width, img.height));\n    };\n    img.onerror = reject;\n    img.src = proxyUrl;\n  });\n}\n\n/**\n * Get brightness (0-1) at a specific pixel\n */\nfunction getBrightness(data: Uint8ClampedArray, x: number, y: number, width: number): number {\n  const i = (y * width + x) * 4;\n  const r = data[i];\n  const g = data[i + 1];\n  const b = data[i + 2];\n  const a = data[i + 3];\n\n  // Skip transparent pixels\n  if (a < 128) return 1;\n\n  // Calculate luminosity (human perception weighted)\n  return (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n}\n\n/**\n * Easing function for smooth animation\n */\nfunction easeOutCubic(t: number): number {\n  return 1 - Math.pow(1 - t, 3);\n}\n\n/**\n * Create 3D halftone spheres from an image with expansion animation\n */\nexport async function createHalftoneSpheres(options: HalftoneOptions): Promise<HalftoneResult> {\n  const {\n    imageUrl,\n    gridSize = 40,\n    sphereScale = 0.5,\n    backgroundColor = 0x111111,\n    sphereColor = 0xffffff,\n    width = 800,\n    height = 600,\n    animationDuration = 3,\n    animationSpread = 0.8,\n  } = options;\n\n  // Load image data\n  const imageData = await getImageData(imageUrl);\n  const { width: imgWidth, height: imgHeight, data } = imageData;\n\n  // Setup Three.js\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(backgroundColor);\n\n  const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);\n  camera.position.z = gridSize * 1.2;\n\n  const renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n\n  // Orbit controls for interactivity\n  const controls = new OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.05;\n\n  // Create instanced mesh for performance\n  const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);\n  const sphereMaterial = new THREE.MeshStandardMaterial({\n    color: sphereColor,\n    metalness: 0.3,\n    roughness: 0.7,\n  });\n\n  // Calculate sphere data with animation properties\n  const spheres: SphereData[] = [];\n  const stepX = imgWidth / gridSize;\n  const stepY = imgHeight / gridSize;\n\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      // Sample image at grid point\n      const imgX = Math.floor(gx * stepX);\n      const imgY = Math.floor(gy * stepY);\n      const brightness = getBrightness(data, imgX, imgY, imgWidth);\n\n      // Invert brightness: darker pixels = larger spheres\n      const size = (1 - brightness) * sphereScale;\n\n      if (size > 0.01) {\n        // Center the grid\n        const x = gx - gridSize / 2;\n        const y = (gridSize - gy) - gridSize / 2; // Flip Y\n\n        spheres.push({\n          targetPosition: new THREE.Vector3(x, y, 0),\n          scale: size,\n          // Random delay creates the \"flow\" effect\n          delay: Math.random() * animationSpread,\n          // Random speed adds variety (0.7 to 1.3)\n          speed: 0.7 + Math.random() * 0.6,\n        });\n      }\n    }\n  }\n\n  // Create instanced mesh\n  const instancedMesh = new THREE.InstancedMesh(\n    sphereGeometry,\n    sphereMaterial,\n    spheres.length\n  );\n  scene.add(instancedMesh);\n\n  // Lighting\n  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n  scene.add(ambientLight);\n\n  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n  directionalLight.position.set(10, 10, 10);\n  scene.add(directionalLight);\n\n  const backLight = new THREE.DirectionalLight(0xffffff, 0.3);\n  backLight.position.set(-10, -10, -10);\n  scene.add(backLight);\n\n  // Animation state\n  let animationId: number;\n  let startTime: number | null = null;\n  const matrix = new THREE.Matrix4();\n  const currentPos = new THREE.Vector3();\n  const center = new THREE.Vector3(0, 0, 0);\n\n  /**\n   * Update sphere positions based on animation progress\n   */\n  function updateSpheres(elapsedSeconds: number) {\n    let allComplete = true;\n\n    spheres.forEach((sphere, i) => {\n      // Calculate this sphere's progress (accounting for delay and speed)\n      const adjustedTime = (elapsedSeconds - sphere.delay * animationDuration) * sphere.speed;\n      const progress = Math.max(0, Math.min(1, adjustedTime / animationDuration));\n\n      if (progress < 1) allComplete = false;\n\n      // Apply easing\n      const easedProgress = easeOutCubic(progress);\n\n      // Interpolate from center to target\n      currentPos.lerpVectors(center, sphere.targetPosition, easedProgress);\n\n      // Scale also animates in (starts small, grows to full size)\n      const currentScale = sphere.scale * easedProgress;\n\n      // Update matrix\n      matrix.makeScale(currentScale, currentScale, currentScale);\n      matrix.setPosition(currentPos);\n      instancedMesh.setMatrixAt(i, matrix);\n    });\n\n    instancedMesh.instanceMatrix.needsUpdate = true;\n    return allComplete;\n  }\n\n  // Initialize all spheres at center\n  updateSpheres(0);\n\n  // Animation loop\n  const animate = () => {\n    animationId = requestAnimationFrame(animate);\n\n    // Track animation time\n    if (startTime === null) startTime = performance.now();\n    const elapsedSeconds = (performance.now() - startTime) / 1000;\n\n    // Update sphere positions\n    updateSpheres(elapsedSeconds);\n\n    controls.update();\n    renderer.render(scene, camera);\n  };\n\n  // Replay function to restart animation\n  const replay = () => {\n    startTime = null;\n    // Re-randomize delays for different flow pattern\n    spheres.forEach(sphere => {\n      sphere.delay = Math.random() * animationSpread;\n      sphere.speed = 0.7 + Math.random() * 0.6;\n    });\n  };\n\n  // Cleanup function\n  const dispose = () => {\n    cancelAnimationFrame(animationId);\n    controls.dispose();\n    renderer.dispose();\n    sphereGeometry.dispose();\n    sphereMaterial.dispose();\n  };\n\n  return { renderer, scene, camera, controls, animate, dispose, replay };\n}\n\nexport default createHalftoneSpheres;\n";