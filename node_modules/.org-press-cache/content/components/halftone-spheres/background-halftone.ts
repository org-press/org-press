// Source display only (not executed)
export default "import * as THREE from 'three';\nimport { processImage, proxyImageUrl } from './halftone-spheres.org?name=image-utils';\n\nexport interface CameraKeyframe {\n  /** Scroll progress (0-1) when this keyframe is active */\n  at: number;\n  /** Camera position */\n  position: { x: number; y: number; z: number };\n  /** Camera look-at target */\n  lookAt?: { x: number; y: number; z: number };\n}\n\nexport interface FlowWaypoint {\n  /** Position offset from center */\n  x: number;\n  y: number;\n  /** Time to reach this point (0-1 of flow cycle) */\n  at: number;\n}\n\nexport interface BackgroundHalftoneOptions {\n  /** Initial image URL */\n  imageUrl: string;\n  /** Grid size (default 80 for more dots) */\n  gridSize?: number;\n  /** Base sphere scale (default 0.4) */\n  sphereScale?: number;\n  /** Background color */\n  backgroundColor?: number;\n  /** Sphere color */\n  sphereColor?: number;\n  /** Camera keyframes for scroll animation */\n  cameraKeyframes?: CameraKeyframe[];\n  /** Duration for quick image visibility (seconds, default 3) */\n  quickRevealDuration?: number;\n  /** Duration for full settling animation (seconds, default 300 = 5 minutes) */\n  settlingDuration?: number;\n  /** Z-depth multiplier for relief effect (default 8) */\n  depthScale?: number;\n  /** Image scale relative to grid (0.5 = 50% of grid, default 0.5) */\n  imageScale?: number;\n  /** Flow path waypoints - composition drifts through these positions */\n  flowPath?: FlowWaypoint[];\n  /** Duration of one flow cycle in seconds (default 60) */\n  flowDuration?: number;\n  /** Image preprocessing options */\n  imageProcessing?: {\n    removeWhiteBackground?: boolean;\n    whiteThreshold?: number;\n    grayscale?: boolean;\n    invert?: boolean;\n    contrast?: number;\n  };\n}\n\nexport interface TypeCaseConfig {\n  /** Grid columns (default 6) */\n  cols?: number;\n  /** Grid rows (default 8) */\n  rows?: number;\n  /** Size of each cell in grid units (default auto-calculated) */\n  cellSize?: number;\n  /** Letters to display - can include featured word */\n  letters?: string[];\n  /** Featured word to highlight (e.g., \"ORG-PRESS\") */\n  featuredWord?: string;\n  /** Font family (default \"Georgia, serif\") */\n  fontFamily?: string;\n  /** Gap between cells as fraction of cell size (default 0.15) */\n  cellGap?: number;\n  /** Perspective tilt in radians (default 0) */\n  perspectiveTilt?: number;\n  /** Letter elevation multiplier (default 1) */\n  letterElevation?: number;\n}\n\n/** Forward declaration - full type defined in editor section */\nexport interface HalftoneIllustration {\n  version: 1;\n  name: string;\n  type: 'image' | 'typecase' | 'custom';\n  source?: string | object;\n  points: Array<{ nx: number; ny: number; nz: number; scale: number }>;\n  transform: { x: number; y: number; z: number; scale: number };\n  camera: { position: { x: number; y: number; z: number }; lookAt: { x: number; y: number; z: number }; fov: number };\n  created?: string;\n}\n\nexport interface GlobeConfig {\n  /** Colors for random sphere glows (hex numbers) */\n  colors?: number[];\n  /** Radius of the globe */\n  radius?: number;\n  /** Number of spheres to show (uses fewer, bigger spheres) */\n  sphereCount?: number;\n}\n\nexport interface SolarSystemConfig {\n  /** Colors for orbiting spheres */\n  orbitColors?: number[];\n  /** Center sphere color */\n  centerColor?: number;\n  /** Center sphere glow intensity */\n  glowIntensity?: number;\n}\n\nexport interface BackgroundHalftoneResult {\n  canvas: HTMLCanvasElement;\n  start: () => void;\n  stop: () => void;\n  setScrollProgress: (progress: number) => void;\n  transitionToImage: (imageUrl: string) => Promise<void>;\n  transitionToTypeCase: (config?: TypeCaseConfig) => Promise<void>;\n  transitionToIllustration: (illustration: HalftoneIllustration) => void;\n  /** Arrange spheres as a rotating globe with colored glows */\n  transitionToGlobe: (config?: GlobeConfig) => void;\n  /** Arrange spheres as a solar system with orbiting spheres */\n  transitionToSolarSystem: (config?: SolarSystemConfig) => void;\n  /** Collapse all spheres to center as a single floating sphere */\n  collapseToCenter: () => void;\n  /** Restore spheres to their expanded formation */\n  restore: () => void;\n  /** Check if currently collapsed */\n  isCollapsed: () => boolean;\n  dispose: () => void;\n  resize: (width: number, height: number) => void;\n}\n\ninterface SphereState {\n  /** Grid position (fixed) */\n  gridX: number;\n  gridY: number;\n  /** Current animated position */\n  currentPosition: THREE.Vector3;\n  /** Target position from current image */\n  targetPosition: THREE.Vector3;\n  /** Current scale (animated) */\n  currentScale: number;\n  /** Target scale from current image */\n  targetScale: number;\n  /** Random delay for staggered animation (0-1) */\n  delay: number;\n  /** Random speed multiplier */\n  speed: number;\n  /** Whether this sphere is \"active\" (has image data) */\n  active: boolean;\n}\n\n/**\n * Load and process image, returning target data for ALL grid positions\n * @param imageScale - Scale of image relative to grid (0.5 = 50% of grid size)\n */\nasync function loadImageData(\n  url: string,\n  gridSize: number,\n  sphereScale: number,\n  depthScale: number,\n  imageScale: number,\n  processing?: BackgroundHalftoneOptions['imageProcessing']\n): Promise<Map<string, { x: number; y: number; z: number; scale: number }>> {\n  // Process image if options provided\n  let imageData: ImageData;\n\n  if (processing?.removeWhiteBackground) {\n    const processed = await processImage(url, {\n      whiteThreshold: processing.whiteThreshold ?? 240,\n      grayscale: processing.grayscale,\n      invert: processing.invert,\n      contrast: processing.contrast,\n    });\n    imageData = processed.imageData;\n  } else {\n    // Load directly (use proxy for external URLs)\n    const proxyUrl = proxyImageUrl(url);\n    const img = await new Promise<HTMLImageElement>((resolve, reject) => {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = () => resolve(img);\n      img.onerror = reject;\n      img.src = proxyUrl;\n    });\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d')!;\n    ctx.drawImage(img, 0, 0);\n    imageData = ctx.getImageData(0, 0, img.width, img.height);\n  }\n\n  const { width, height, data } = imageData;\n  const targets = new Map<string, { x: number; y: number; z: number; scale: number }>();\n  const stepX = width / gridSize;\n  const stepY = height / gridSize;\n\n  // Calculate scaled grid bounds (image is smaller and centered)\n  const scaledGridSize = gridSize * imageScale;\n  const offset = (gridSize - scaledGridSize) / 2;\n\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      const imgX = Math.floor(gx * stepX);\n      const imgY = Math.floor(gy * stepY);\n      const i = (imgY * width + imgX) * 4;\n\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      const a = data[i + 3];\n\n      // Grid position scaled and centered\n      const x = (gx - gridSize / 2) * imageScale;\n      const y = ((gridSize - gy) - gridSize / 2) * imageScale;\n\n      // Calculate brightness and scale\n      const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n      const isVisible = a > 30;\n\n      // Z-axis based on brightness (darker = closer to camera)\n      const z = isVisible ? (1 - brightness) * depthScale : 0;\n\n      // Scale based on darkness (darker = larger sphere), also scaled down\n      const scale = isVisible ? (1 - brightness) * sphereScale * imageScale : 0;\n\n      const key = `${gx},${gy}`;\n      targets.set(key, { x, y, z, scale });\n    }\n  }\n\n  return targets;\n}\n\nfunction easeInOutCubic(t: number): number {\n  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n}\n\n/**\n * Render a letter to canvas and return bitmap for voxelization\n */\nfunction renderLetterBitmap(\n  letter: string,\n  size: number,\n  fontFamily: string\n): boolean[][] {\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d')!;\n\n  // Clear\n  ctx.fillStyle = '#000000';\n  ctx.fillRect(0, 0, size, size);\n\n  // Draw letter\n  ctx.fillStyle = '#ffffff';\n  ctx.font = `bold ${size * 0.75}px ${fontFamily}`;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(letter, size / 2, size / 2);\n\n  // Get pixel data and convert to bitmap\n  const imageData = ctx.getImageData(0, 0, size, size);\n  const bitmap: boolean[][] = [];\n\n  for (let y = 0; y < size; y++) {\n    bitmap[y] = [];\n    for (let x = 0; x < size; x++) {\n      const i = (y * size + x) * 4;\n      const brightness = imageData.data[i]; // Just red channel\n      bitmap[y][x] = brightness > 128;\n    }\n  }\n\n  return bitmap;\n}\n\n/**\n * Generate true 3D type case layout\n * Creates compartment walls and 3D letter blocks that can rise up\n */\nfunction generateTypeCaseData(\n  gridSize: number,\n  sphereScale: number,\n  depthScale: number,\n  config: TypeCaseConfig = {}\n): Map<string, { x: number; y: number; z: number; scale: number }> {\n  const {\n    cols = 6,\n    rows = 8,\n    letters: customLetters,\n    featuredWord = 'ORG-PRESS',\n    fontFamily = 'Georgia, Times, serif',\n    cellGap = 0.15,\n    letterElevation = 1,\n  } = config;\n\n  const targets = new Map<string, { x: number; y: number; z: number; scale: number }>();\n\n  // Calculate dimensions\n  // The type case should fit nicely in the view\n  const caseWidth = gridSize * 0.4;  // 40% of grid width\n  const caseHeight = gridSize * 0.5; // 50% of grid height\n  const caseDepth = depthScale * 1.5; // How deep the compartments are\n\n  const cellWidth = caseWidth / cols;\n  const cellHeight = caseHeight / rows;\n  const wallThickness = cellWidth * cellGap;\n  const letterResolution = 12; // Dots per letter dimension\n  const letterDepth = 4; // How many layers deep the letter block is\n\n  // Generate letter arrangement\n  const defaultLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&'.split('');\n  const cellLetters: (string | null)[][] = [];\n  const featuredChars = featuredWord.split('');\n\n  // Place featured word in middle rows\n  const featuredStartRow = Math.floor(rows / 2) - 1;\n  let featuredIndex = 0;\n  let letterIndex = 0;\n\n  for (let row = 0; row < rows; row++) {\n    cellLetters[row] = [];\n    for (let col = 0; col < cols; col++) {\n      // Featured word placement - spread across two middle rows\n      if (row === featuredStartRow || row === featuredStartRow + 1) {\n        if (featuredIndex < featuredChars.length) {\n          cellLetters[row][col] = featuredChars[featuredIndex++];\n        } else {\n          cellLetters[row][col] = null;\n        }\n      } else {\n        // Random letters with some empty spaces\n        if (Math.random() > 0.15) {\n          const available = customLetters?.length ? customLetters : defaultLetters;\n          cellLetters[row][col] = available[letterIndex % available.length];\n          letterIndex++;\n        } else {\n          cellLetters[row][col] = null;\n        }\n      }\n    }\n  }\n\n  // Helper to add a sphere target\n  let sphereIndex = 0;\n  const addSphere = (x: number, y: number, z: number, scale: number) => {\n    // Map to grid coordinates\n    const gx = Math.floor((x + gridSize / 2) + Math.random() * 0.5);\n    const gy = Math.floor((gridSize / 2 - y) + Math.random() * 0.5);\n    const key = `${gx},${gy},${sphereIndex++}`;\n    targets.set(key, { x, y, z, scale });\n  };\n\n  // Center offset for the case\n  const offsetX = -caseWidth / 2;\n  const offsetY = caseHeight / 2;\n\n  // Build compartment walls (3D box edges)\n  const wallDotSpacing = wallThickness * 1.5;\n  const wallDotScale = sphereScale * 0.3;\n\n  // Vertical walls (between columns)\n  for (let col = 0; col <= cols; col++) {\n    const x = offsetX + col * cellWidth;\n    for (let row = 0; row < rows; row++) {\n      const yTop = offsetY - row * cellHeight;\n      const yBottom = offsetY - (row + 1) * cellHeight;\n\n      // Dots along the vertical edge, going down into Z\n      for (let wy = yBottom; wy <= yTop; wy += wallDotSpacing) {\n        for (let wz = -caseDepth; wz <= 0; wz += wallDotSpacing) {\n          addSphere(x, wy, wz, wallDotScale);\n        }\n      }\n    }\n  }\n\n  // Horizontal walls (between rows)\n  for (let row = 0; row <= rows; row++) {\n    const y = offsetY - row * cellHeight;\n    for (let col = 0; col < cols; col++) {\n      const xLeft = offsetX + col * cellWidth;\n      const xRight = offsetX + (col + 1) * cellWidth;\n\n      // Dots along the horizontal edge, going down into Z\n      for (let wx = xLeft; wx <= xRight; wx += wallDotSpacing) {\n        for (let wz = -caseDepth; wz <= 0; wz += wallDotSpacing) {\n          addSphere(wx, y, wz, wallDotScale);\n        }\n      }\n    }\n  }\n\n  // Bottom of compartments (floor)\n  const floorDotSpacing = cellWidth / 4;\n  const floorDotScale = sphereScale * 0.15;\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const cellCenterX = offsetX + (col + 0.5) * cellWidth;\n      const cellCenterY = offsetY - (row + 0.5) * cellHeight;\n\n      // Sparse dots on the floor\n      for (let fx = -cellWidth / 2 + wallThickness; fx < cellWidth / 2 - wallThickness; fx += floorDotSpacing) {\n        for (let fy = -cellHeight / 2 + wallThickness; fy < cellHeight / 2 - wallThickness; fy += floorDotSpacing) {\n          if (Math.random() > 0.5) { // Sparse\n            addSphere(cellCenterX + fx, cellCenterY + fy, -caseDepth, floorDotScale);\n          }\n        }\n      }\n    }\n  }\n\n  // Build 3D letter blocks\n  const letterDotScale = sphereScale * 0.5;\n  const letterBlockHeight = depthScale * letterElevation; // How high letters rise\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      const letter = cellLetters[row][col];\n      if (!letter) continue;\n\n      // Get letter bitmap\n      const bitmap = renderLetterBitmap(letter, letterResolution, fontFamily);\n\n      // Cell center position\n      const cellCenterX = offsetX + (col + 0.5) * cellWidth;\n      const cellCenterY = offsetY - (row + 0.5) * cellHeight;\n\n      // Letter block dimensions (slightly smaller than cell)\n      const letterWidth = cellWidth * 0.7;\n      const letterHeight = cellHeight * 0.7;\n      const dotSpacingX = letterWidth / letterResolution;\n      const dotSpacingY = letterHeight / letterResolution;\n      const dotSpacingZ = letterBlockHeight / letterDepth;\n\n      // Create 3D voxelized letter\n      for (let ly = 0; ly < letterResolution; ly++) {\n        for (let lx = 0; lx < letterResolution; lx++) {\n          if (!bitmap[ly][lx]) continue; // Skip empty pixels\n\n          // Position within the cell\n          const x = cellCenterX + (lx - letterResolution / 2) * dotSpacingX;\n          const y = cellCenterY + (letterResolution / 2 - ly) * dotSpacingY;\n\n          // Create vertical stack of dots for the letter block\n          // Letters rise from inside the case (negative Z) to above (positive Z)\n          for (let lz = 0; lz < letterDepth; lz++) {\n            const z = -caseDepth * 0.3 + lz * dotSpacingZ + letterBlockHeight;\n            // Slightly vary scale for top surface vs sides\n            const scale = lz === letterDepth - 1 ? letterDotScale : letterDotScale * 0.8;\n            addSphere(x, y, z, scale);\n          }\n        }\n      }\n    }\n  }\n\n  // Now we need to map these 3D positions back to the grid indices\n  // Since we have more spheres than grid positions, we'll use the grid as a pool\n  // and assign spheres to grid positions based on proximity\n\n  // Convert to grid-indexed map\n  const gridTargets = new Map<string, { x: number; y: number; z: number; scale: number }>();\n  const sphereList = Array.from(targets.values());\n\n  // Assign spheres to grid positions\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      const key = `${gx},${gy}`;\n\n      if (sphereList.length > 0) {\n        // Pop a sphere from our list\n        const sphere = sphereList.pop()!;\n        gridTargets.set(key, sphere);\n      } else {\n        // No more spheres, make this one invisible\n        gridTargets.set(key, {\n          x: (gx - gridSize / 2) * 0.5,\n          y: ((gridSize - gy) - gridSize / 2) * 0.5,\n          z: -depthScale * 2,\n          scale: 0,\n        });\n      }\n    }\n  }\n\n  return gridTargets;\n}\n\nfunction easeOutExpo(t: number): number {\n  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);\n}\n\n/**\n * Interpolate between camera keyframes\n */\nfunction interpolateCamera(\n  keyframes: CameraKeyframe[],\n  progress: number,\n  camera: THREE.PerspectiveCamera\n) {\n  if (keyframes.length === 0) return;\n  if (keyframes.length === 1) {\n    const kf = keyframes[0];\n    camera.position.set(kf.position.x, kf.position.y, kf.position.z);\n    if (kf.lookAt) camera.lookAt(kf.lookAt.x, kf.lookAt.y, kf.lookAt.z);\n    return;\n  }\n\n  let prevKf = keyframes[0];\n  let nextKf = keyframes[keyframes.length - 1];\n\n  for (let i = 0; i < keyframes.length - 1; i++) {\n    if (progress >= keyframes[i].at && progress <= keyframes[i + 1].at) {\n      prevKf = keyframes[i];\n      nextKf = keyframes[i + 1];\n      break;\n    }\n  }\n\n  const range = nextKf.at - prevKf.at;\n  const localProgress = range > 0 ? (progress - prevKf.at) / range : 0;\n  const t = easeInOutCubic(Math.max(0, Math.min(1, localProgress)));\n\n  camera.position.set(\n    THREE.MathUtils.lerp(prevKf.position.x, nextKf.position.x, t),\n    THREE.MathUtils.lerp(prevKf.position.y, nextKf.position.y, t),\n    THREE.MathUtils.lerp(prevKf.position.z, nextKf.position.z, t)\n  );\n\n  const prevLookAt = prevKf.lookAt || { x: 0, y: 0, z: 0 };\n  const nextLookAt = nextKf.lookAt || { x: 0, y: 0, z: 0 };\n  camera.lookAt(\n    THREE.MathUtils.lerp(prevLookAt.x, nextLookAt.x, t),\n    THREE.MathUtils.lerp(prevLookAt.y, nextLookAt.y, t),\n    THREE.MathUtils.lerp(prevLookAt.z, nextLookAt.z, t)\n  );\n}\n\n/**\n * Interpolate flow position based on time\n */\nfunction getFlowOffset(\n  flowPath: FlowWaypoint[],\n  flowProgress: number\n): { x: number; y: number } {\n  if (flowPath.length === 0) return { x: 0, y: 0 };\n  if (flowPath.length === 1) return { x: flowPath[0].x, y: flowPath[0].y };\n\n  // Find surrounding waypoints\n  let prevWp = flowPath[0];\n  let nextWp = flowPath[flowPath.length - 1];\n\n  for (let i = 0; i < flowPath.length - 1; i++) {\n    if (flowProgress >= flowPath[i].at && flowProgress <= flowPath[i + 1].at) {\n      prevWp = flowPath[i];\n      nextWp = flowPath[i + 1];\n      break;\n    }\n  }\n\n  const range = nextWp.at - prevWp.at;\n  const localProgress = range > 0 ? (flowProgress - prevWp.at) / range : 0;\n  // Smooth easing for flow\n  const t = easeInOutCubic(Math.max(0, Math.min(1, localProgress)));\n\n  return {\n    x: prevWp.x + (nextWp.x - prevWp.x) * t,\n    y: prevWp.y + (nextWp.y - prevWp.y) * t,\n  };\n}\n\n/**\n * Create background halftone with relief effect and slow settling\n */\nexport async function createBackgroundHalftone(\n  options: BackgroundHalftoneOptions\n): Promise<BackgroundHalftoneResult> {\n  const {\n    imageUrl,\n    gridSize = 80,\n    sphereScale = 0.4,\n    backgroundColor = 0x111111,\n    sphereColor = 0xffffff,\n    cameraKeyframes = [\n      { at: 0, position: { x: 0, y: 0, z: 70 }, lookAt: { x: 0, y: 0, z: 0 } },\n      { at: 0.5, position: { x: 25, y: 10, z: 60 }, lookAt: { x: 0, y: 0, z: 0 } },\n      { at: 1, position: { x: -15, y: -5, z: 50 }, lookAt: { x: 0, y: 0, z: 0 } },\n    ],\n    quickRevealDuration = 3,\n    settlingDuration = 300, // 5 minutes\n    depthScale = 8,\n    imageScale = 0.5, // Image takes 50% of grid by default\n    flowPath = [\n      // Default flow: top-left → bottom-right → center → loop\n      { x: -15, y: 10, at: 0 },\n      { x: 10, y: -8, at: 0.33 },\n      { x: 0, y: 0, at: 0.66 },\n      { x: -15, y: 10, at: 1 }, // Loop back\n    ],\n    flowDuration = 90, // 90 seconds per cycle\n    imageProcessing = { removeWhiteBackground: true },\n  } = options;\n\n  // Setup Three.js\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(backgroundColor);\n  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);\n  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n\n  // Flat white spheres (no lighting)\n  const sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8);\n  const sphereMaterial = new THREE.MeshBasicMaterial({ color: sphereColor });\n\n  const totalSpheres = gridSize * gridSize;\n  const instancedMesh = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, totalSpheres);\n  scene.add(instancedMesh);\n\n  // Initialize ALL spheres at center with zero scale\n  const sphereStates: SphereState[] = [];\n  for (let gy = 0; gy < gridSize; gy++) {\n    for (let gx = 0; gx < gridSize; gx++) {\n      sphereStates.push({\n        gridX: gx,\n        gridY: gy,\n        currentPosition: new THREE.Vector3(0, 0, 0),\n        targetPosition: new THREE.Vector3(0, 0, 0),\n        currentScale: 0,\n        targetScale: 0,\n        delay: Math.random(),\n        speed: 0.7 + Math.random() * 0.6,\n        active: false,\n      });\n    }\n  }\n\n  // Load initial image data\n  const initialData = await loadImageData(imageUrl, gridSize, sphereScale, depthScale, imageScale, imageProcessing);\n\n  // Set initial targets for all spheres\n  sphereStates.forEach((state, i) => {\n    const key = `${state.gridX},${state.gridY}`;\n    const data = initialData.get(key);\n    if (data && data.scale > 0.01) {\n      state.targetPosition.set(data.x, data.y, data.z);\n      state.targetScale = data.scale;\n      state.active = true;\n    } else {\n      // Inactive spheres go to their grid position but with 0 scale\n      const x = state.gridX - gridSize / 2;\n      const y = (gridSize - state.gridY) - gridSize / 2;\n      state.targetPosition.set(x, y, 0);\n      state.targetScale = 0;\n      state.active = false;\n    }\n  });\n\n  // Animation state\n  let animationId: number | null = null;\n  let startTime: number | null = null;\n  let transitionStartTime: number | null = null;\n  let currentScrollProgress = 0;\n  const matrix = new THREE.Matrix4();\n\n  // Store previous state for transitions\n  const prevPositions: THREE.Vector3[] = sphereStates.map(() => new THREE.Vector3());\n  const prevScales: number[] = sphereStates.map(() => 0);\n\n  // Collapse/restore state\n  let collapsed = false;\n  const expandedTargets: Array<{ position: THREE.Vector3; scale: number; active: boolean }> =\n    sphereStates.map(s => ({\n      position: s.targetPosition.clone(),\n      scale: s.targetScale,\n      active: s.active,\n    }));\n\n  // Mouse tracking for perspective tilt\n  let mouseX = 0; // -1 to 1 (left to right)\n  let mouseY = 0; // -1 to 1 (top to bottom)\n  let targetMouseX = 0;\n  let targetMouseY = 0;\n  const tiltSmoothing = 0.06; // Smoothing factor (lower = smoother)\n\n  // Track mouse movement\n  const handleMouseMove = (e: MouseEvent) => {\n    // Normalize to -1 to 1 range\n    targetMouseX = (e.clientX / window.innerWidth) * 2 - 1;\n    targetMouseY = (e.clientY / window.innerHeight) * 2 - 1;\n  };\n  window.addEventListener('mousemove', handleMouseMove, { passive: true });\n\n  // Fluid motion parameters for collapsed state (per-sphere)\n  const fluidParams: Array<{\n    orbitRadius: number;\n    orbitSpeed: number;\n    orbitPhase: number;\n    verticalSpeed: number;\n    verticalPhase: number;\n    pulseSpeed: number;\n    pulsePhase: number;\n  }> = sphereStates.map(() => ({\n    orbitRadius: 0.5 + Math.random() * 1.5,      // How far from center it orbits\n    orbitSpeed: 0.3 + Math.random() * 0.4,       // Orbit speed\n    orbitPhase: Math.random() * Math.PI * 2,     // Starting angle\n    verticalSpeed: 0.2 + Math.random() * 0.3,    // Vertical bob speed\n    verticalPhase: Math.random() * Math.PI * 2,  // Vertical phase\n    pulseSpeed: 0.5 + Math.random() * 0.5,       // Scale pulse speed\n    pulsePhase: Math.random() * Math.PI * 2,     // Scale pulse phase\n  }));\n\n  // Formation mode: 'normal' | 'globe' | 'solarSystem'\n  let formationMode: 'normal' | 'globe' | 'solarSystem' = 'normal';\n  let formationStartTime: number | null = null;\n\n  // Per-sphere colors for special formations\n  const sphereColors: THREE.Color[] = sphereStates.map(() => new THREE.Color(sphereColor));\n  const defaultColor = new THREE.Color(sphereColor);\n  let useInstanceColors = false;\n\n  // Globe formation parameters\n  const globeParams: Array<{\n    theta: number; // longitude\n    phi: number;   // latitude\n    rotationSpeed: number;\n    glowPhase: number;\n  }> = sphereStates.map(() => ({\n    theta: Math.random() * Math.PI * 2,\n    phi: Math.acos(2 * Math.random() - 1),\n    rotationSpeed: 0.15 + Math.random() * 0.1,\n    glowPhase: Math.random() * Math.PI * 2,\n  }));\n\n  // Solar system formation parameters\n  const solarParams: Array<{\n    orbitRadius: number;  // Distance from center\n    orbitAngle: number;   // Current angle in orbit\n    orbitSpeed: number;   // Speed of orbit\n    orbitTilt: number;    // Tilt of orbit plane\n    glowPhase: number;    // For pulsing\n    isCenter: boolean;    // Is this the center sphere?\n  }> = sphereStates.map((_, i) => ({\n    orbitRadius: 5 + Math.random() * 15,\n    orbitAngle: Math.random() * Math.PI * 2,\n    orbitSpeed: 0.1 + Math.random() * 0.15,\n    orbitTilt: (Math.random() - 0.5) * Math.PI * 0.3,\n    glowPhase: Math.random() * Math.PI * 2,\n    isCenter: i === 0, // First sphere is center\n  }));\n\n  function updateSpheres(timestamp: number) {\n    if (startTime === null) startTime = timestamp;\n    const elapsed = (timestamp - startTime) / 1000;\n\n    // Calculate flow offset (continuous looping movement)\n    const flowProgress = (elapsed % flowDuration) / flowDuration;\n    const flowOffset = getFlowOffset(flowPath, flowProgress);\n\n    // Handle image transition\n    if (transitionStartTime !== null) {\n      const transitionElapsed = (timestamp - transitionStartTime) / 1000;\n      const transitionDuration = 2; // 2 second transition\n      const tProgress = Math.min(1, transitionElapsed / transitionDuration);\n      const tEased = easeInOutCubic(tProgress);\n\n      sphereStates.forEach((state, i) => {\n        state.currentPosition.lerpVectors(prevPositions[i], state.targetPosition, tEased);\n        state.currentScale = THREE.MathUtils.lerp(prevScales[i], state.targetScale, tEased);\n      });\n\n      if (tProgress >= 1) {\n        transitionStartTime = null;\n      }\n    } else {\n      // Normal animation: quick reveal then slow settling\n      sphereStates.forEach((state, i) => {\n        // Staggered start based on delay\n        const adjustedTime = Math.max(0, elapsed - state.delay * quickRevealDuration);\n\n        // Quick reveal phase (first few seconds - image becomes visible)\n        const quickProgress = Math.min(1, adjustedTime / quickRevealDuration);\n        const quickEased = easeOutExpo(quickProgress);\n\n        // Slow settling phase (continues for minutes - subtle drift to final position)\n        const settlingProgress = Math.min(1, adjustedTime / settlingDuration);\n        const settlingEased = easeOutExpo(settlingProgress);\n\n        // Combine: quick reveal gets ~90% there, settling gets the last 10%\n        const totalProgress = quickEased * 0.9 + settlingEased * 0.1;\n\n        // Position interpolation from center\n        const centerX = 0;\n        const centerY = 0;\n        const centerZ = -20; // Start behind the \"plane\"\n\n        state.currentPosition.set(\n          THREE.MathUtils.lerp(centerX, state.targetPosition.x, totalProgress),\n          THREE.MathUtils.lerp(centerY, state.targetPosition.y, totalProgress),\n          THREE.MathUtils.lerp(centerZ, state.targetPosition.z, totalProgress)\n        );\n\n        // Scale animation\n        state.currentScale = state.targetScale * quickEased;\n      });\n    }\n\n    // Update instanced mesh with flow offset applied\n    sphereStates.forEach((state, i) => {\n      let scale = state.currentScale;\n      let posX = state.currentPosition.x + flowOffset.x;\n      let posY = state.currentPosition.y + flowOffset.y;\n      let posZ = state.currentPosition.z;\n\n      // Apply fluid motion when collapsed\n      if (collapsed && transitionStartTime === null) {\n        const fp = fluidParams[i];\n\n        // Gentle orbital motion around center\n        const orbitAngle = fp.orbitPhase + elapsed * fp.orbitSpeed;\n        const orbitX = Math.cos(orbitAngle) * fp.orbitRadius;\n        const orbitY = Math.sin(orbitAngle) * fp.orbitRadius * 0.6; // Elliptical\n\n        // Vertical floating bob\n        const verticalBob = Math.sin(fp.verticalPhase + elapsed * fp.verticalSpeed) * 0.8;\n\n        // Subtle depth oscillation\n        const depthBob = Math.sin(fp.orbitPhase + elapsed * fp.orbitSpeed * 0.5) * 0.5;\n\n        // Apply fluid offsets\n        posX += orbitX;\n        posY += orbitY + verticalBob;\n        posZ += depthBob;\n\n        // Gentle scale pulsing (breathing effect)\n        const pulse = 1 + Math.sin(fp.pulsePhase + elapsed * fp.pulseSpeed) * 0.15;\n        scale *= pulse;\n      }\n\n      // Globe formation: spheres on a rotating sphere surface\n      if (formationMode === 'globe' && transitionStartTime === null) {\n        const gp = globeParams[i];\n        const globeRadius = 12;\n\n        // Rotate theta over time (longitude rotation)\n        const theta = gp.theta + elapsed * gp.rotationSpeed;\n        const phi = gp.phi;\n\n        // Spherical to Cartesian\n        posX = globeRadius * Math.sin(phi) * Math.cos(theta);\n        posY = globeRadius * Math.cos(phi);\n        posZ = globeRadius * Math.sin(phi) * Math.sin(theta) + 8; // Offset forward\n\n        // Random glow pulsing with color\n        const glowPulse = 0.5 + 0.5 * Math.sin(gp.glowPhase + elapsed * 0.8);\n        scale = 0.6 + glowPulse * 0.3;\n      }\n\n      // Solar system formation: center sphere with orbiting smaller spheres\n      if (formationMode === 'solarSystem' && transitionStartTime === null) {\n        const sp = solarParams[i];\n\n        if (sp.isCenter) {\n          // Large glowing center sphere\n          posX = 0;\n          posY = 0;\n          posZ = 8;\n          // Pulsing glow effect for center\n          const centerPulse = 1 + 0.15 * Math.sin(elapsed * 0.5);\n          scale = 3 * centerPulse;\n        } else {\n          // Orbiting spheres\n          const angle = sp.orbitAngle + elapsed * sp.orbitSpeed;\n          const tiltedY = Math.sin(angle) * Math.sin(sp.orbitTilt);\n          const tiltedZ = Math.sin(angle) * Math.cos(sp.orbitTilt);\n\n          posX = Math.cos(angle) * sp.orbitRadius;\n          posY = tiltedY * sp.orbitRadius * 0.3;\n          posZ = tiltedZ * sp.orbitRadius * 0.5 + 8;\n\n          // Orbiting spheres are smaller with gentle pulse\n          const orbitPulse = 0.8 + 0.2 * Math.sin(sp.glowPhase + elapsed * 0.6);\n          scale = 0.4 * orbitPulse;\n        }\n      }\n\n      if (scale < 0.001) {\n        matrix.makeScale(0, 0, 0);\n      } else {\n        matrix.makeScale(scale, scale, scale);\n        matrix.setPosition(posX, posY, posZ);\n      }\n      instancedMesh.setMatrixAt(i, matrix);\n\n      // Update instance colors if enabled\n      if (useInstanceColors) {\n        instancedMesh.setColorAt(i, sphereColors[i]);\n      }\n    });\n    instancedMesh.instanceMatrix.needsUpdate = true;\n    if (useInstanceColors && instancedMesh.instanceColor) {\n      instancedMesh.instanceColor.needsUpdate = true;\n    }\n  }\n\n  function render(timestamp: number) {\n    animationId = requestAnimationFrame(render);\n    updateSpheres(timestamp);\n\n    // Smooth mouse tracking\n    mouseX += (targetMouseX - mouseX) * tiltSmoothing;\n    mouseY += (targetMouseY - mouseY) * tiltSmoothing;\n\n    // Interpolate camera from keyframes\n    interpolateCamera(cameraKeyframes, currentScrollProgress, camera);\n\n    // Apply Y-axis rotation based on mouse position\n    // Like turning your head left/right to look around\n    const rotateY = -mouseX * 0.12; // Radians, subtle rotation\n    const rotateX = mouseY * 0.06;  // Slight vertical look\n\n    // Rotate camera around world Y axis (look left/right)\n    camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), rotateY);\n    // Slight X rotation for vertical mouse movement\n    camera.rotateX(rotateX);\n\n    renderer.render(scene, camera);\n  }\n\n  const start = () => {\n    if (animationId === null) {\n      animationId = requestAnimationFrame(render);\n    }\n  };\n\n  const stop = () => {\n    if (animationId !== null) {\n      cancelAnimationFrame(animationId);\n      animationId = null;\n    }\n  };\n\n  const setScrollProgress = (progress: number) => {\n    currentScrollProgress = Math.max(0, Math.min(1, progress));\n  };\n\n  const transitionToImage = async (newImageUrl: string) => {\n    // Store current state\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Load new image data\n    const newData = await loadImageData(newImageUrl, gridSize, sphereScale, depthScale, imageScale, imageProcessing);\n\n    // Update ALL sphere targets\n    sphereStates.forEach((state, i) => {\n      const key = `${state.gridX},${state.gridY}`;\n      const data = newData.get(key);\n      if (data && data.scale > 0.01) {\n        state.targetPosition.set(data.x, data.y, data.z);\n        state.targetScale = data.scale;\n        state.active = true;\n      } else {\n        // Keep position but fade out\n        state.targetScale = 0;\n        state.active = false;\n      }\n      // Also update expanded targets for collapse/restore\n      expandedTargets[i].position.copy(state.targetPosition);\n      expandedTargets[i].scale = state.targetScale;\n      expandedTargets[i].active = state.active;\n    });\n\n    collapsed = false; // New content means we're expanded\n    transitionStartTime = performance.now();\n  };\n\n  const transitionToTypeCase = async (config: TypeCaseConfig = {}) => {\n    // Store current state\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Generate type case data\n    const typeCaseData = generateTypeCaseData(gridSize, sphereScale, depthScale, config);\n\n    // Update ALL sphere targets\n    sphereStates.forEach((state, i) => {\n      const key = `${state.gridX},${state.gridY}`;\n      const data = typeCaseData.get(key);\n      if (data && data.scale > 0.01) {\n        state.targetPosition.set(data.x, data.y, data.z);\n        state.targetScale = data.scale;\n        state.active = true;\n      } else {\n        // Sphere becomes inactive\n        state.targetScale = 0;\n        state.active = false;\n      }\n      // Also update expanded targets for collapse/restore\n      expandedTargets[i].position.copy(state.targetPosition);\n      expandedTargets[i].scale = state.targetScale;\n      expandedTargets[i].active = state.active;\n    });\n\n    collapsed = false; // New content means we're expanded\n    transitionStartTime = performance.now();\n  };\n\n  const transitionToIllustration = (illustration: HalftoneIllustration) => {\n    // Store current state\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Render illustration points at current grid size\n    const { points, transform } = illustration;\n    const halfGrid = gridSize / 2;\n    const renderedPoints: Array<{ x: number; y: number; z: number; scale: number }> = [];\n\n    for (const point of points) {\n      const x = (point.nx - 0.5) * gridSize * transform.scale * imageScale + transform.x;\n      const y = (0.5 - point.ny) * gridSize * transform.scale * imageScale + transform.y;\n      const z = point.nz * depthScale + transform.z;\n      const scale = point.scale * transform.scale * sphereScale * imageScale;\n      renderedPoints.push({ x, y, z, scale });\n    }\n\n    // Map rendered points to grid positions\n    const illustrationData = new Map<string, { x: number; y: number; z: number; scale: number }>();\n\n    renderedPoints.forEach((point, i) => {\n      const gx = Math.floor(point.x + halfGrid);\n      const gy = Math.floor(halfGrid - point.y);\n      const key = `${gx},${gy}`;\n\n      const existing = illustrationData.get(key);\n      if (!existing || point.scale > existing.scale) {\n        illustrationData.set(key, point);\n      }\n    });\n\n    // Update ALL sphere targets\n    sphereStates.forEach((state, i) => {\n      const key = `${state.gridX},${state.gridY}`;\n      const data = illustrationData.get(key);\n      if (data && data.scale > 0.01) {\n        state.targetPosition.set(data.x, data.y, data.z);\n        state.targetScale = data.scale;\n        state.active = true;\n      } else {\n        state.targetScale = 0;\n        state.active = false;\n      }\n      // Also update expanded targets for collapse/restore\n      expandedTargets[i].position.copy(state.targetPosition);\n      expandedTargets[i].scale = state.targetScale;\n      expandedTargets[i].active = state.active;\n    });\n\n    collapsed = false; // New content means we're expanded\n    transitionStartTime = performance.now();\n  };\n\n  const collapseToCenter = () => {\n    if (collapsed) return;\n\n    // Store current expanded state before collapsing\n    sphereStates.forEach((state, i) => {\n      expandedTargets[i].position.copy(state.targetPosition);\n      expandedTargets[i].scale = state.targetScale;\n      expandedTargets[i].active = state.active;\n      // Store current animated position for smooth transition\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Collapse to a visible floating sphere cluster\n    // Keep it centered but compact - visible as a glowing orb\n    const centerX = 0;\n    const centerY = 0;\n    const centerZ = 8; // Slightly forward\n\n    // Create a visible sphere cluster\n    const clusterRadius = 4; // Visible cluster size\n\n    sphereStates.forEach((state, i) => {\n      // Spherical distribution for a nice floating orb effect\n      const theta = Math.random() * Math.PI * 2;\n      const phi = Math.acos(2 * Math.random() - 1);\n      const r = clusterRadius * Math.cbrt(Math.random()); // Cubic root for even distribution\n\n      const offsetX = r * Math.sin(phi) * Math.cos(theta);\n      const offsetY = r * Math.sin(phi) * Math.sin(theta);\n      const offsetZ = r * Math.cos(phi);\n\n      state.targetPosition.set(centerX + offsetX, centerY + offsetY, centerZ + offsetZ);\n      // Visible scale - creates a glowing orb effect\n      state.targetScale = 0.35 + Math.random() * 0.15;\n      state.active = true;\n    });\n\n    collapsed = true;\n    transitionStartTime = performance.now();\n  };\n\n  const restore = () => {\n    if (!collapsed) return;\n\n    // Store current collapsed state for smooth transition\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Restore expanded targets\n    sphereStates.forEach((state, i) => {\n      state.targetPosition.copy(expandedTargets[i].position);\n      state.targetScale = expandedTargets[i].scale;\n      state.active = expandedTargets[i].active;\n    });\n\n    collapsed = false;\n    transitionStartTime = performance.now();\n  };\n\n  const isCollapsed = () => collapsed;\n\n  // Default globe colors (vibrant rainbow)\n  const defaultGlobeColors = [\n    0xff6b6b, // coral red\n    0x4ecdc4, // teal\n    0xffe66d, // yellow\n    0x95e1d3, // mint\n    0xf38181, // salmon\n    0xaa96da, // lavender\n    0xfcbad3, // pink\n    0xa8d8ea, // sky blue\n  ];\n\n  // Default solar system colors (warm golden center, cool orbits)\n  const defaultOrbitColors = [\n    0x60a5fa, // blue\n    0xa78bfa, // purple\n    0xf472b6, // pink\n    0x34d399, // green\n    0xfbbf24, // amber\n    0xf87171, // red\n  ];\n\n  const transitionToGlobe = (config: GlobeConfig = {}) => {\n    const {\n      colors = defaultGlobeColors,\n      radius = 12,\n      sphereCount = 80,\n    } = config;\n\n    // Store current state for smooth transition\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Enable instance colors\n    useInstanceColors = true;\n\n    // Randomly select which spheres to show (fewer, bigger spheres)\n    const activeIndices = new Set<number>();\n    while (activeIndices.size < Math.min(sphereCount, sphereStates.length)) {\n      activeIndices.add(Math.floor(Math.random() * sphereStates.length));\n    }\n\n    // Set up globe positions and colors\n    sphereStates.forEach((state, i) => {\n      if (activeIndices.has(i)) {\n        // Assign sphere to globe surface\n        const theta = Math.random() * Math.PI * 2;\n        const phi = Math.acos(2 * Math.random() - 1);\n\n        // Update globe params for animation\n        globeParams[i].theta = theta;\n        globeParams[i].phi = phi;\n        globeParams[i].rotationSpeed = 0.12 + Math.random() * 0.08;\n        globeParams[i].glowPhase = Math.random() * Math.PI * 2;\n\n        // Set initial target position on globe\n        state.targetPosition.set(\n          radius * Math.sin(phi) * Math.cos(theta),\n          radius * Math.cos(phi),\n          radius * Math.sin(phi) * Math.sin(theta) + 8\n        );\n        state.targetScale = 0.8 + Math.random() * 0.4; // Bigger spheres\n        state.active = true;\n\n        // Assign random color from palette\n        sphereColors[i].setHex(colors[Math.floor(Math.random() * colors.length)]);\n      } else {\n        state.targetScale = 0;\n        state.active = false;\n      }\n    });\n\n    formationMode = 'globe';\n    collapsed = false;\n    transitionStartTime = performance.now();\n  };\n\n  const transitionToSolarSystem = (config: SolarSystemConfig = {}) => {\n    const {\n      orbitColors = defaultOrbitColors,\n      centerColor = 0xffd700, // Golden\n      glowIntensity = 1.5,\n    } = config;\n\n    // Store current state for smooth transition\n    sphereStates.forEach((state, i) => {\n      prevPositions[i].copy(state.currentPosition);\n      prevScales[i] = state.currentScale;\n    });\n\n    // Enable instance colors\n    useInstanceColors = true;\n\n    // Set up solar system: one large center, rest orbiting\n    sphereStates.forEach((state, i) => {\n      if (i === 0) {\n        // Center sphere - large and golden\n        solarParams[i].isCenter = true;\n        state.targetPosition.set(0, 0, 8);\n        state.targetScale = 3;\n        state.active = true;\n        sphereColors[i].setHex(centerColor);\n      } else if (i < 60) {\n        // Orbiting spheres (use first ~60 spheres)\n        solarParams[i].isCenter = false;\n        solarParams[i].orbitRadius = 6 + Math.random() * 14;\n        solarParams[i].orbitAngle = Math.random() * Math.PI * 2;\n        solarParams[i].orbitSpeed = 0.08 + Math.random() * 0.12;\n        solarParams[i].orbitTilt = (Math.random() - 0.5) * Math.PI * 0.4;\n        solarParams[i].glowPhase = Math.random() * Math.PI * 2;\n\n        const angle = solarParams[i].orbitAngle;\n        const r = solarParams[i].orbitRadius;\n        state.targetPosition.set(\n          Math.cos(angle) * r,\n          Math.sin(angle) * r * 0.3,\n          8\n        );\n        state.targetScale = 0.4;\n        state.active = true;\n\n        // Assign random orbit color\n        sphereColors[i].setHex(orbitColors[Math.floor(Math.random() * orbitColors.length)]);\n      } else {\n        // Hide remaining spheres\n        state.targetScale = 0;\n        state.active = false;\n      }\n    });\n\n    formationMode = 'solarSystem';\n    collapsed = false;\n    transitionStartTime = performance.now();\n  };\n\n  const resize = (width: number, height: number) => {\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n  };\n\n  const dispose = () => {\n    stop();\n    window.removeEventListener('mousemove', handleMouseMove);\n    renderer.dispose();\n    sphereGeometry.dispose();\n    sphereMaterial.dispose();\n  };\n\n  return {\n    canvas: renderer.domElement,\n    start,\n    stop,\n    setScrollProgress,\n    transitionToImage,\n    transitionToTypeCase,\n    transitionToIllustration,\n    transitionToGlobe,\n    transitionToSolarSystem,\n    collapseToCenter,\n    restore,\n    isCollapsed,\n    dispose,\n    resize,\n  };\n}\n";