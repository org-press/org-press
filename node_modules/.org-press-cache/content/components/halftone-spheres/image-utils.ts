// Source display only (not executed)
export default "/**\n * Check if a URL is external (not same origin)\n */\nexport function isExternalUrl(url: string): boolean {\n  if (url.startsWith('/') || url.startsWith('./') || url.startsWith('../')) {\n    return false;\n  }\n  try {\n    const parsed = new URL(url, window.location.origin);\n    return parsed.origin !== window.location.origin;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Wrap an external URL through the CORS proxy\n * Returns the original URL for local paths\n */\nexport function proxyImageUrl(url: string): string {\n  if (!isExternalUrl(url)) {\n    return url;\n  }\n  return `/api/image-proxy?url=${encodeURIComponent(url)}`;\n}\n\n/**\n * Process image with optional background removal\n */\nexport async function processImage(\n  url: string,\n  options: {\n    whiteThreshold?: number;\n    grayscale?: boolean;\n    invert?: boolean;\n    contrast?: number;\n  } = {}\n): Promise<{ imageData: ImageData; canvas: HTMLCanvasElement }> {\n  const { whiteThreshold = 240, grayscale = false, invert = false, contrast = 1 } = options;\n\n  // Use proxy for external URLs\n  const proxyUrl = proxyImageUrl(url);\n\n  const img = await new Promise<HTMLImageElement>((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error(`Failed to load image: ${url}`));\n    img.src = proxyUrl;\n  });\n\n  const canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, img.width, img.height);\n  const { data } = imageData;\n\n  // Process pixels\n  for (let i = 0; i < data.length; i += 4) {\n    let r = data[i];\n    let g = data[i + 1];\n    let b = data[i + 2];\n    const a = data[i + 3];\n\n    // Remove white background\n    if (r >= whiteThreshold && g >= whiteThreshold && b >= whiteThreshold) {\n      data[i + 3] = 0; // Make transparent\n      continue;\n    }\n\n    // Apply contrast\n    if (contrast !== 1) {\n      r = Math.min(255, Math.max(0, ((r / 255 - 0.5) * contrast + 0.5) * 255));\n      g = Math.min(255, Math.max(0, ((g / 255 - 0.5) * contrast + 0.5) * 255));\n      b = Math.min(255, Math.max(0, ((b / 255 - 0.5) * contrast + 0.5) * 255));\n    }\n\n    // Grayscale\n    if (grayscale) {\n      const gray = 0.299 * r + 0.587 * g + 0.114 * b;\n      r = g = b = gray;\n    }\n\n    // Invert\n    if (invert) {\n      r = 255 - r;\n      g = 255 - g;\n      b = 255 - b;\n    }\n\n    data[i] = r;\n    data[i + 1] = g;\n    data[i + 2] = b;\n  }\n\n  ctx.putImageData(imageData, 0, 0);\n  return { imageData, canvas };\n}\n";