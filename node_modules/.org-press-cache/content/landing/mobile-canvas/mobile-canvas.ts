type Formation = 'grid' | 'cube' | 'pipeline' | 'globe' | 'prism' | 'warp';

interface Dot {
  brightness: number;
  scale: number;
  delay: number;
}

interface Blob {
  x: number;
  y: number;
  vx: number;
  vy: number;
  radius: number;
  phase: number;
}

export interface MobileCanvasController {
  canvas: HTMLCanvasElement;
  setFormation: (formation: Formation) => void;
  dispose: () => void;
}

export function createMobileCanvas(container: HTMLElement): MobileCanvasController {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d')!;

  canvas.style.position = 'fixed';
  canvas.style.top = '0';
  canvas.style.left = '0';
  canvas.style.width = '100vw';
  canvas.style.height = '100vh';
  canvas.style.zIndex = '0';
  canvas.style.pointerEvents = 'none';
  container.appendChild(canvas);

  const cols = 60;
  const rows = 100;
  const baseRadius = 1.2;
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
  const bgColor = prefersDark ? '#0a0a0f' : '#f5f5f7';
  const dotColor = prefersDark ? [153, 153, 153] : [119, 119, 119];

  let width = 0, height = 0, spacingX = 0, spacingY = 0;
  const dots: Dot[] = [];

  // Lava lamp blobs
  const blobs: Blob[] = Array.from({ length: 6 }, () => ({
    x: 0.2 + Math.random() * 0.6,
    y: 0.2 + Math.random() * 0.6,
    vx: (Math.random() - 0.5) * 0.0003,
    vy: (Math.random() - 0.5) * 0.0003,
    radius: 0.08 + Math.random() * 0.06,
    phase: Math.random() * Math.PI * 2,
  }));

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio, 2);
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    spacingX = width / cols;
    spacingY = height / rows;
    initDots();
  }

  function initDots() {
    dots.length = 0;
    for (let i = 0; i < rows * cols; i++) {
      dots.push({
        brightness: 0.1,
        scale: 1,
        delay: Math.random(),
      });
    }
  }

  let formation: Formation = 'grid';
  let time = 0;

  function setFormation(f: Formation) {
    if (f === formation) return;
    formation = f;
  }

  let frameId: number;
  let lastTime = 0;

  function animate(now: number) {
    const dt = Math.min(now - lastTime, 50);
    lastTime = now;
    time += dt;

    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, width, height);

    // Update lava blobs (slow movement)
    for (const blob of blobs) {
      blob.x += blob.vx;
      blob.y += blob.vy;
      // Bounce off edges
      if (blob.x < 0.1 || blob.x > 0.9) blob.vx *= -1;
      if (blob.y < 0.1 || blob.y > 0.9) blob.vy *= -1;
      // Slight random drift
      blob.vx += (Math.random() - 0.5) * 0.00005;
      blob.vy += (Math.random() - 0.5) * 0.00005;
      // Clamp velocity
      blob.vx = Math.max(-0.0005, Math.min(0.0005, blob.vx));
      blob.vy = Math.max(-0.0005, Math.min(0.0005, blob.vy));
    }

    const easing = 0.05; // Slower easing

    dots.forEach((dot, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = col * spacingX + spacingX / 2;
      const y = row * spacingY + spacingY / 2;
      const dotX = col / cols;
      const dotY = row / rows;

      let tb = 0.1;
      let ts = 1;

      switch (formation) {
        case 'grid': {
          // Stars - subtle random twinkling
          const twinkle = Math.sin(time * 0.0015 + dot.delay * 50) * 0.5 + 0.5;
          tb = twinkle > 0.93 ? 0.5 + twinkle * 0.3 : 0.08;
          ts = twinkle > 0.93 ? 1.3 : 1;
          break;
        }

        case 'cube': {
          // Lava lamp - soft blobs
          let blobStrength = 0;
          for (const blob of blobs) {
            const pulseRadius = blob.radius * (1 + Math.sin(time * 0.001 + blob.phase) * 0.2);
            const dist = Math.sqrt((dotX - blob.x) ** 2 + (dotY - blob.y) ** 2);
            if (dist < pulseRadius) {
              const strength = (1 - dist / pulseRadius) ** 2; // Smooth falloff
              blobStrength = Math.max(blobStrength, strength);
            }
          }
          tb = 0.06 + blobStrength * 0.6;
          ts = 0.9 + blobStrength * 0.6;
          break;
        }

        case 'pipeline': {
          // Wave moving down (slowed)
          const wave = Math.sin(time * 0.002 - row * 0.15) * 0.5 + 0.5;
          tb = 0.1 + wave * 0.5;
          ts = 0.8 + wave * 0.5;
          break;
        }

        case 'globe': {
          // Expanding rings (slowed)
          const cx = (col - cols / 2) / (cols / 2);
          const cy = (row - rows / 2) / (rows / 2);
          const dist = Math.sqrt(cx * cx + cy * cy);
          const ring = Math.sin(dist * 8 - time * 0.0015) * 0.5 + 0.5;
          tb = 0.1 + ring * 0.5;
          ts = 0.8 + ring * 0.4;
          break;
        }

        case 'prism': {
          // Random sparkle (slowed)
          const sparkle = Math.sin(time * 0.0025 + dot.delay * 20) * 0.5 + 0.5;
          const flash = sparkle > 0.85 ? 1 : sparkle * 0.4;
          tb = 0.1 + flash * 0.6;
          ts = 0.8 + flash * 0.6;
          break;
        }

        case 'warp': {
          // Radial rays (slowed)
          const cx = col - cols / 2;
          const cy = row - rows / 2;
          const angle = Math.atan2(cy, cx);
          const ray = Math.sin(angle * 12 + time * 0.004) * 0.5 + 0.5;
          const dist = Math.sqrt(cx * cx + cy * cy) / Math.sqrt(cols * cols + rows * rows);
          tb = ray * (0.2 + dist * 0.5);
          ts = 0.6 + ray * dist;
          break;
        }
      }

      // Lerp (slower)
      dot.brightness += (tb - dot.brightness) * easing;
      dot.scale += (ts - dot.scale) * easing;

      // Draw
      const r = baseRadius * dot.scale;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${dotColor[0]},${dotColor[1]},${dotColor[2]},${dot.brightness})`;
      ctx.fill();
    });

    frameId = requestAnimationFrame(animate);
  }

  resize();
  window.addEventListener('resize', resize);
  frameId = requestAnimationFrame(animate);

  return {
    canvas,
    setFormation,
    dispose() {
      cancelAnimationFrame(frameId);
      window.removeEventListener('resize', resize);
      canvas.remove();
    },
  };
}

export default createMobileCanvas;
