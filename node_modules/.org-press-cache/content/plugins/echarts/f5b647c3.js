
import * as echarts from 'echarts';

// Track chart instances for cleanup
const chartRegistry = new Map();

// Export render function - exporter will call this with container ID
export default function render(containerId) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error('[ECharts] Container not found:', containerId);
    return;
  }

  // Style the container
  container.className = 'echarts-wrapper';
  container.style.cssText = 'position: relative; width: 100%; height: 400px;';

  // Create inner container for chart
  const chartContainer = document.createElement('div');
  chartContainer.style.cssText = 'width: 100%; height: 100%;';
  container.appendChild(chartContainer);

  function showError(err) {
    console.error('[ECharts] Failed to render chart:', err);
    container.innerHTML = '<div style="color: red; padding: 1rem; border: 1px solid red;">Error rendering chart: ' + (err.message || err) + '</div>';
  }

  function initChart(chartOption) {
    // Dispose existing chart if any (for HMR)
    if (chartRegistry.has(containerId)) {
      chartRegistry.get(containerId).dispose();
    }

    // Initialize ECharts
    const chart = echarts.init(chartContainer, 'light', {
      renderer: 'canvas',
    });

    // Set option
    chart.setOption(chartOption);

    // Handle resize
    const resizeObserver = new ResizeObserver(() => {
      chart.resize();
    });
    resizeObserver.observe(container);

    // Also handle window resize for containers that don't trigger ResizeObserver
    const handleResize = () => chart.resize();
    window.addEventListener('resize', handleResize);

    // Store for cleanup
    chartRegistry.set(containerId, chart);

    // Cleanup on navigation (for SPA)
    const cleanup = () => {
      resizeObserver.disconnect();
      window.removeEventListener('resize', handleResize);
      chart.dispose();
      chartRegistry.delete(containerId);
    };

    // Watch for container removal (works with most SPA routers)
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const removed of mutation.removedNodes) {
          if (removed === container || (removed instanceof Element && removed.contains(container))) {
            cleanup();
            observer.disconnect();
            return;
          }
        }
      }
    });

    if (container.parentElement) {
      observer.observe(container.parentElement, { childList: true, subtree: true });
    }
  }

  try {
        const chartOption = {
  "title": { "text": "Traffic Sources", "left": "center" },
  "tooltip": { "trigger": "item" },
  "legend": { "orient": "vertical", "left": "left" },
  "series": [{
    "name": "Source",
    "type": "pie",
    "radius": "50%",
    "data": [
      { "value": 1048, "name": "Search Engine" },
      { "value": 735, "name": "Direct" },
      { "value": 580, "name": "Email" },
      { "value": 484, "name": "Social Media" },
      { "value": 300, "name": "Other" }
    ]
  }]
}
;
        initChart(chartOption);
      } catch (err) {
        showError(err);
      }
}
