
import * as echarts from 'echarts';

// Track chart instances for cleanup
const chartRegistry = new Map();

// Export render function - exporter will call this with container ID
export default function render(containerId) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error('[ECharts] Container not found:', containerId);
    return;
  }

  // Style the container
  container.className = 'echarts-wrapper';
  container.style.cssText = 'position: relative; width: 100%; height: 500px;';

  // Create inner container for chart
  const chartContainer = document.createElement('div');
  chartContainer.style.cssText = 'width: 100%; height: 100%;';
  container.appendChild(chartContainer);

  function showError(err) {
    console.error('[ECharts] Failed to render chart:', err);
    container.innerHTML = '<div style="color: red; padding: 1rem; border: 1px solid red;">Error rendering chart: ' + (err.message || err) + '</div>';
  }

  function initChart(chartOption) {
    // Dispose existing chart if any (for HMR)
    if (chartRegistry.has(containerId)) {
      chartRegistry.get(containerId).dispose();
    }

    // Initialize ECharts
    const chart = echarts.init(chartContainer, 'light', {
      renderer: 'canvas',
    });

    // Set option
    chart.setOption(chartOption);

    // Handle resize
    const resizeObserver = new ResizeObserver(() => {
      chart.resize();
    });
    resizeObserver.observe(container);

    // Also handle window resize for containers that don't trigger ResizeObserver
    const handleResize = () => chart.resize();
    window.addEventListener('resize', handleResize);

    // Store for cleanup
    chartRegistry.set(containerId, chart);

    // Cleanup on navigation (for SPA)
    const cleanup = () => {
      resizeObserver.disconnect();
      window.removeEventListener('resize', handleResize);
      chart.dispose();
      chartRegistry.delete(containerId);
    };

    // Watch for container removal (works with most SPA routers)
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const removed of mutation.removedNodes) {
          if (removed === container || (removed instanceof Element && removed.contains(container))) {
            cleanup();
            observer.disconnect();
            return;
          }
        }
      }
    });

    if (container.parentElement) {
      observer.observe(container.parentElement, { childList: true, subtree: true });
    }
  }

  try {
        const chartOption = {
  "title": { "text": "Quarterly Revenue" },
  "legend": { "data": ["2023", "2024"] },
  "xAxis": {
    "type": "category",
    "data": ["Q1", "Q2", "Q3", "Q4"]
  },
  "yAxis": { "type": "value", "name": "Revenue ($K)" },
  "series": [
    { "name": "2023", "type": "bar", "data": [320, 332, 301, 334] },
    { "name": "2024", "type": "bar", "data": [420, 482, 391, 484] }
  ]
}
;
        initChart(chartOption);
      } catch (err) {
        showError(err);
      }
}
