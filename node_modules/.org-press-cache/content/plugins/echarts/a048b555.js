
import * as echarts from 'echarts';

// Track chart instances for cleanup
const chartRegistry = new Map();

// Export render function - exporter will call this with container ID
export default function render(containerId) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error('[ECharts] Container not found:', containerId);
    return;
  }

  // Style the container
  container.className = 'echarts-wrapper';
  container.style.cssText = 'position: relative; width: 100%; height: 400px;';

  // Create inner container for chart
  const chartContainer = document.createElement('div');
  chartContainer.style.cssText = 'width: 100%; height: 100%;';
  container.appendChild(chartContainer);

  function showError(err) {
    console.error('[ECharts] Failed to render chart:', err);
    container.innerHTML = '<div style="color: red; padding: 1rem; border: 1px solid red;">Error rendering chart: ' + (err.message || err) + '</div>';
  }

  function initChart(chartOption) {
    // Dispose existing chart if any (for HMR)
    if (chartRegistry.has(containerId)) {
      chartRegistry.get(containerId).dispose();
    }

    // Initialize ECharts
    const chart = echarts.init(chartContainer, 'dark', {
      renderer: 'canvas',
    });

    // Set option
    chart.setOption(chartOption);

    // Handle resize
    const resizeObserver = new ResizeObserver(() => {
      chart.resize();
    });
    resizeObserver.observe(container);

    // Also handle window resize for containers that don't trigger ResizeObserver
    const handleResize = () => chart.resize();
    window.addEventListener('resize', handleResize);

    // Store for cleanup
    chartRegistry.set(containerId, chart);

    // Cleanup on navigation (for SPA)
    const cleanup = () => {
      resizeObserver.disconnect();
      window.removeEventListener('resize', handleResize);
      chart.dispose();
      chartRegistry.delete(containerId);
    };

    // Watch for container removal (works with most SPA routers)
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const removed of mutation.removedNodes) {
          if (removed === container || (removed instanceof Element && removed.contains(container))) {
            cleanup();
            observer.disconnect();
            return;
          }
        }
      }
    });

    if (container.parentElement) {
      observer.observe(container.parentElement, { childList: true, subtree: true });
    }
  }

  try {
        const chartOption = {
  "backgroundColor": "#100c2a",
  "title": { "text": "Dark Theme Chart", "textStyle": { "color": "#fff" } },
  "tooltip": { "trigger": "axis" },
  "xAxis": {
    "type": "category",
    "data": ["Mon", "Tue", "Wed", "Thu", "Fri"],
    "axisLine": { "lineStyle": { "color": "#fff" } }
  },
  "yAxis": {
    "type": "value",
    "axisLine": { "lineStyle": { "color": "#fff" } },
    "splitLine": { "lineStyle": { "color": "#333" } }
  },
  "series": [{
    "type": "bar",
    "data": [120, 200, 150, 80, 70],
    "itemStyle": {
      "color": {
        "type": "linear",
        "x": 0, "y": 0, "x2": 0, "y2": 1,
        "colorStops": [
          { "offset": 0, "color": "#83bff6" },
          { "offset": 1, "color": "#188df0" }
        ]
      }
    }
  }]
}
;
        initChart(chartOption);
      } catch (err) {
        showError(err);
      }
}
