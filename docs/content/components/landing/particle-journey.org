#+TITLE: Particle Journey
#+DESCRIPTION: Scroll-driven particle system for landing page

* Particle Journey Controller

Main controller for the scroll-driven particle animation that flows between
sections of the landing page.

#+NAME: particle-journey
#+begin_src typescript 
/**
 * Particle Journey - Scroll-driven particle animation system
 *
 * Controls particles that:
 * 1. Start as a single glowing sphere in the hero
 * 2. Split and flow to form different shapes per section
 * 3. Transition colors (white â†’ gold in final section)
 */

// Easing functions
const easeOutCubic = (t: number): number => 1 - Math.pow(1 - t, 3);
const easeInOutQuad = (t: number): number =>
  t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

// Linear interpolation
const lerp = (a: number, b: number, t: number): number => a + (b - a) * t;

// Color interpolation (hex to rgb)
function hexToRgb(hex: string): [number, number, number] {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)]
    : [255, 255, 255];
}

function lerpColor(
  color1: [number, number, number],
  color2: [number, number, number],
  t: number
): string {
  const r = Math.round(lerp(color1[0], color2[0], t));
  const g = Math.round(lerp(color1[1], color2[1], t));
  const b = Math.round(lerp(color1[2], color2[2], t));
  return `rgb(${r}, ${g}, ${b})`;
}

interface Particle {
  x: number;
  y: number;
  startX: number;
  startY: number;
  targetX: number;
  targetY: number;
  delay: number;
  scale: number;
  baseScale: number;
  opacity: number;
  color: [number, number, number];
}

interface Section {
  id: string;
  start: number;
  end: number;
  formation: 'sphere' | 'code-block' | 'terminal' | 'carousel' | 'sunburst';
  flowDirection: 'none' | 'left' | 'right' | 'center';
  colorShift?: boolean;
}

export interface ParticleJourneyOptions {
  particleCount?: number;
  baseColor?: string;
  goldColor?: string;
  particleSize?: number;
  glowSize?: number;
}

export interface ParticleJourney {
  canvas: HTMLCanvasElement;
  start: () => void;
  stop: () => void;
  setScrollProgress: (progress: number) => void;
  setSpherePosition: (x: number, y: number) => void;
  resize: (width: number, height: number) => void;
  destroy: () => void;
}

export function createParticleJourney(
  options: ParticleJourneyOptions = {}
): ParticleJourney {
  const {
    particleCount = 150,
    baseColor = '#ffffff',
    goldColor = '#ffd700',
    particleSize = 3,
    glowSize = 8,
  } = options;

  const canvas = document.createElement('canvas');
  canvas.className = 'particle-journey-canvas';
  const ctx = canvas.getContext('2d')!;

  let width = window.innerWidth;
  let height = window.innerHeight;
  let animationId: number | null = null;
  let scrollProgress = 0;
  let sphereX = width / 2;
  let sphereY = height / 2;

  const baseColorRgb = hexToRgb(baseColor);
  const goldColorRgb = hexToRgb(goldColor);

  // Define sections with scroll ranges
  const sections: Section[] = [
    { id: 'hero', start: 0, end: 0.12, formation: 'sphere', flowDirection: 'none' },
    { id: 'code-blocks', start: 0.12, end: 0.35, formation: 'code-block', flowDirection: 'right' },
    { id: 'ssg', start: 0.35, end: 0.55, formation: 'terminal', flowDirection: 'left' },
    { id: 'cli', start: 0.55, end: 0.75, formation: 'carousel', flowDirection: 'right' },
    { id: 'ai', start: 0.75, end: 1.0, formation: 'sunburst', flowDirection: 'center', colorShift: true },
  ];

  // Initialize particles in sphere formation
  const particles: Particle[] = [];
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 15;
    particles.push({
      x: sphereX + Math.cos(angle) * radius,
      y: sphereY + Math.sin(angle) * radius,
      startX: sphereX + Math.cos(angle) * radius,
      startY: sphereY + Math.sin(angle) * radius,
      targetX: sphereX + Math.cos(angle) * radius,
      targetY: sphereY + Math.sin(angle) * radius,
      delay: Math.random() * 0.3,
      scale: 0.5 + Math.random() * 0.5,
      baseScale: 0.5 + Math.random() * 0.5,
      opacity: 0.6 + Math.random() * 0.4,
      color: [...baseColorRgb] as [number, number, number],
    });
  }

  // Get formation target positions
  function getFormationTargets(formation: Section['formation'], centerX: number, centerY: number): { x: number; y: number }[] {
    const targets: { x: number; y: number }[] = [];

    switch (formation) {
      case 'sphere': {
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * 15;
          targets.push({
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius,
          });
        }
        break;
      }
      case 'code-block': {
        // Form a code block outline (rectangle with some internal lines)
        const blockWidth = Math.min(350, width * 0.35);
        const blockHeight = Math.min(250, height * 0.35);
        const offsetX = width * 0.6;
        const offsetY = height * 0.5;

        for (let i = 0; i < particleCount; i++) {
          const t = i / particleCount;
          let x: number, y: number;

          if (t < 0.4) {
            // Outline
            const outlineT = (t / 0.4) * 4;
            if (outlineT < 1) {
              x = offsetX - blockWidth / 2 + outlineT * blockWidth;
              y = offsetY - blockHeight / 2;
            } else if (outlineT < 2) {
              x = offsetX + blockWidth / 2;
              y = offsetY - blockHeight / 2 + (outlineT - 1) * blockHeight;
            } else if (outlineT < 3) {
              x = offsetX + blockWidth / 2 - (outlineT - 2) * blockWidth;
              y = offsetY + blockHeight / 2;
            } else {
              x = offsetX - blockWidth / 2;
              y = offsetY + blockHeight / 2 - (outlineT - 3) * blockHeight;
            }
          } else {
            // Internal "code lines"
            const lineIndex = Math.floor((t - 0.4) / 0.12);
            const lineT = ((t - 0.4) % 0.12) / 0.12;
            x = offsetX - blockWidth / 2 + 20 + lineT * (blockWidth * 0.6 - 40 * (lineIndex % 3));
            y = offsetY - blockHeight / 2 + 30 + lineIndex * 35;
          }

          targets.push({ x: x + (Math.random() - 0.5) * 4, y: y + (Math.random() - 0.5) * 4 });
        }
        break;
      }
      case 'terminal': {
        // Form a terminal window outline
        const termWidth = Math.min(380, width * 0.4);
        const termHeight = Math.min(220, height * 0.3);
        const offsetX = width * 0.35;
        const offsetY = height * 0.5;

        for (let i = 0; i < particleCount; i++) {
          const t = i / particleCount;
          let x: number, y: number;

          if (t < 0.35) {
            // Outline
            const outlineT = (t / 0.35) * 4;
            if (outlineT < 1) {
              x = offsetX - termWidth / 2 + outlineT * termWidth;
              y = offsetY - termHeight / 2;
            } else if (outlineT < 2) {
              x = offsetX + termWidth / 2;
              y = offsetY - termHeight / 2 + (outlineT - 1) * termHeight;
            } else if (outlineT < 3) {
              x = offsetX + termWidth / 2 - (outlineT - 2) * termWidth;
              y = offsetY + termHeight / 2;
            } else {
              x = offsetX - termWidth / 2;
              y = offsetY + termHeight / 2 - (outlineT - 3) * termHeight;
            }
          } else if (t < 0.45) {
            // Title bar dots
            const dotIndex = Math.floor((t - 0.35) / 0.033);
            x = offsetX - termWidth / 2 + 25 + dotIndex * 18;
            y = offsetY - termHeight / 2 + 15;
          } else {
            // Command prompt
            const promptT = (t - 0.45) / 0.55;
            x = offsetX - termWidth / 2 + 20 + promptT * termWidth * 0.7;
            y = offsetY - termHeight / 2 + 50 + Math.floor(promptT * 3) * 25;
          }

          targets.push({ x: x + (Math.random() - 0.5) * 3, y: y + (Math.random() - 0.5) * 3 });
        }
        break;
      }
      case 'carousel': {
        // Form a vertical list / carousel
        const listWidth = Math.min(200, width * 0.2);
        const listHeight = Math.min(280, height * 0.4);
        const offsetX = width * 0.65;
        const offsetY = height * 0.5;

        for (let i = 0; i < particleCount; i++) {
          const t = i / particleCount;
          let x: number, y: number;

          if (t < 0.3) {
            // Outline
            const outlineT = (t / 0.3) * 4;
            if (outlineT < 1) {
              x = offsetX - listWidth / 2 + outlineT * listWidth;
              y = offsetY - listHeight / 2;
            } else if (outlineT < 2) {
              x = offsetX + listWidth / 2;
              y = offsetY - listHeight / 2 + (outlineT - 1) * listHeight;
            } else if (outlineT < 3) {
              x = offsetX + listWidth / 2 - (outlineT - 2) * listWidth;
              y = offsetY + listHeight / 2;
            } else {
              x = offsetX - listWidth / 2;
              y = offsetY + listHeight / 2 - (outlineT - 3) * listHeight;
            }
          } else {
            // List items
            const itemT = (t - 0.3) / 0.7;
            const itemIndex = Math.floor(itemT * 5);
            const lineT = (itemT * 5) % 1;
            x = offsetX - listWidth / 2 + 15 + lineT * (listWidth - 30);
            y = offsetY - listHeight / 2 + 35 + itemIndex * 50;
          }

          targets.push({ x: x + (Math.random() - 0.5) * 3, y: y + (Math.random() - 0.5) * 3 });
        }
        break;
      }
      case 'sunburst': {
        // Form a sunburst / star pattern (golden glow center)
        const centerOffsetX = width / 2;
        const centerOffsetY = height * 0.35;

        for (let i = 0; i < particleCount; i++) {
          const t = i / particleCount;

          if (t < 0.3) {
            // Central glow cluster
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 25;
            targets.push({
              x: centerOffsetX + Math.cos(angle) * radius,
              y: centerOffsetY + Math.sin(angle) * radius,
            });
          } else {
            // Rays extending outward
            const rayT = (t - 0.3) / 0.7;
            const rayCount = 12;
            const rayIndex = Math.floor(rayT * rayCount);
            const rayAngle = (rayIndex / rayCount) * Math.PI * 2 - Math.PI / 2;
            const rayLength = 40 + (rayT * rayCount % 1) * 80;
            targets.push({
              x: centerOffsetX + Math.cos(rayAngle) * rayLength + (Math.random() - 0.5) * 8,
              y: centerOffsetY + Math.sin(rayAngle) * rayLength + (Math.random() - 0.5) * 8,
            });
          }
        }
        break;
      }
    }

    return targets;
  }

  // Get current section based on scroll progress
  function getCurrentSection(progress: number): Section {
    for (let i = sections.length - 1; i >= 0; i--) {
      if (progress >= sections[i].start) {
        return sections[i];
      }
    }
    return sections[0];
  }

  // Update particle targets when section changes
  let currentSectionId = 'hero';
  let lastFormationTargets: { x: number; y: number }[] = [];

  function updateParticleTargets(section: Section) {
    const targets = getFormationTargets(section.formation, width / 2, height / 2);
    lastFormationTargets = targets;

    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      p.startX = p.x;
      p.startY = p.y;
      p.targetX = targets[i]?.x ?? p.x;
      p.targetY = targets[i]?.y ?? p.y;
      p.delay = Math.random() * 0.3;
    }
  }

  // Animation loop
  function animate() {
    ctx.clearRect(0, 0, width, height);

    const section = getCurrentSection(scrollProgress);
    const sectionProgress = section.end > section.start
      ? Math.min(1, (scrollProgress - section.start) / (section.end - section.start) * 2)
      : 0;

    // Check for section change
    if (section.id !== currentSectionId) {
      currentSectionId = section.id;
      updateParticleTargets(section);
    }

    // Color shift for AI section
    const colorProgress = section.colorShift ? sectionProgress : 0;

    // Draw glow layer first (additive blending effect)
    ctx.globalCompositeOperation = 'screen';

    for (const p of particles) {
      // Animate position
      const t = Math.max(0, Math.min(1, (sectionProgress - p.delay) * 1.5));
      const eased = easeOutCubic(t);
      p.x = lerp(p.startX, p.targetX, eased);
      p.y = lerp(p.startY, p.targetY, eased);

      // Color interpolation for golden glow
      const particleColor = lerpColor(baseColorRgb, goldColorRgb, colorProgress);

      // Draw glow
      const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize * p.scale);
      gradient.addColorStop(0, particleColor.replace('rgb', 'rgba').replace(')', `, ${p.opacity * 0.6})`));
      gradient.addColorStop(1, particleColor.replace('rgb', 'rgba').replace(')', ', 0)'));

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowSize * p.scale, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw solid particles
    ctx.globalCompositeOperation = 'source-over';

    for (const p of particles) {
      const particleColor = lerpColor(baseColorRgb, goldColorRgb, colorProgress);

      ctx.fillStyle = particleColor.replace('rgb', 'rgba').replace(')', `, ${p.opacity})`);
      ctx.beginPath();
      ctx.arc(p.x, p.y, particleSize * p.scale, 0, Math.PI * 2);
      ctx.fill();
    }

    animationId = requestAnimationFrame(animate);
  }

  function resize(w: number, h: number) {
    width = w;
    height = h;
    canvas.width = w * window.devicePixelRatio;
    canvas.height = h * window.devicePixelRatio;
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    // Re-calculate targets for current section
    const section = getCurrentSection(scrollProgress);
    updateParticleTargets(section);
  }

  return {
    canvas,
    start() {
      if (!animationId) {
        resize(width, height);
        // Initialize targets for hero section
        updateParticleTargets(sections[0]);
        animate();
      }
    },
    stop() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    },
    setScrollProgress(progress: number) {
      scrollProgress = Math.max(0, Math.min(1, progress));
    },
    setSpherePosition(x: number, y: number) {
      sphereX = x;
      sphereY = y;
    },
    resize,
    destroy() {
      this.stop();
      canvas.remove();
    },
  };
}

export default createParticleJourney;
#+end_src

#+NAME: particle-journey-styles
#+begin_src css 
/* Particle journey canvas - fixed background */
.particle-journey-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  pointer-events: none;
}

/* Hide on mobile or reduced motion - will show static fallback instead */
@media (max-width: 768px), (prefers-reduced-motion: reduce) {
  .particle-journey-canvas {
    display: none;
  }
}
#+end_src
