import{g as Bg}from"./_commonjsHelpers-Cpj98o6Y.js";var ke,kc;function D(){if(kc)return ke;kc=1;const i=e=>e.reduce((r,t)=>Array.isArray(t)?r.concat(i(t)):r.concat(t),[]);return ke=i,ke}var Ne,Nc;function Vg(){return Nc||(Nc=1,Ne=e=>Object.assign({},e)),Ne}var Ge,Gc;function Og(){return Gc||(Gc=1,Ge=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e[2]=r[2]+t[2],e[3]=r[3]+t[3],e[4]=r[4]+t[4],e[5]=r[5]+t[5],e[6]=r[6]+t[6],e[7]=r[7]+t[7],e[8]=r[8]+t[8],e[9]=r[9]+t[9],e[10]=r[10]+t[10],e[11]=r[11]+t[11],e[12]=r[12]+t[12],e[13]=r[13]+t[13],e[14]=r[14]+t[14],e[15]=r[15]+t[15],e)),Ge}var De,Dc;function fc(){return Dc||(Dc=1,De=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),De}var ze,zc;function kg(){if(zc)return ze;zc=1;const i=fc();return ze=r=>{const t=i();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],t},ze}var Le,Lc;function l2(){return Lc||(Lc=1,Le=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e)),Le}var Ie,Ic;function Ng(){return Ic||(Ic=1,Ie=(e,r)=>{const t=r[0],n=r[1],s=r[2],o=r[3],c=r[4],a=r[5],u=r[6],f=r[7],h=r[8],p=r[9],g=r[10],m=r[11],v=r[12],l=r[13],d=r[14],q=r[15],y=t*a-n*c,P=t*u-s*c,w=t*f-o*c,R=n*u-s*a,x=n*f-o*a,E=s*f-o*u,A=h*l-p*v,_=h*d-g*v,S=h*q-m*v,b=p*d-g*l,T=p*q-m*l,M=g*q-m*d;let $=y*M-P*T+w*b+R*S-x*_+E*A;return $?($=1/$,e[0]=(a*M-u*T+f*b)*$,e[1]=(s*T-n*M-o*b)*$,e[2]=(l*E-d*x+q*R)*$,e[3]=(g*x-p*E-m*R)*$,e[4]=(u*S-c*M-f*_)*$,e[5]=(t*M-s*S+o*_)*$,e[6]=(d*w-v*E-q*P)*$,e[7]=(h*E-g*w+m*P)*$,e[8]=(c*T-a*S+f*A)*$,e[9]=(n*S-t*T-o*A)*$,e[10]=(v*x-l*w+q*y)*$,e[11]=(p*w-h*x-m*y)*$,e[12]=(a*_-c*b-u*A)*$,e[13]=(t*b-n*_+s*A)*$,e[14]=(l*P-v*R-d*y)*$,e[15]=(h*R-p*P+g*y)*$,e):null}),Ie}var He,Hc;function Gg(){return Hc||(Hc=1,He=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]&&e[3]===r[3]&&e[4]===r[4]&&e[5]===r[5]&&e[6]===r[6]&&e[7]===r[7]&&e[8]===r[8]&&e[9]===r[9]&&e[10]===r[10]&&e[11]===r[11]&&e[12]===r[12]&&e[13]===r[13]&&e[14]===r[14]&&e[15]===r[15]),He}var Ze,Zc;function Y(){if(Zc)return Ze;Zc=1;const i=1e5,e=1e-5,r=1e-13,t=Math.PI*2;return Ze={EPS:e,NEPS:r,TAU:t,spatialResolution:i},Ze}var Xe,Xc;function ee(){if(Xc)return Xe;Xc=1;const{NEPS:i}=Y(),e=n=>Math.abs(n)<i?0:n;return Xe={sin:n=>e(Math.sin(n)),cos:n=>e(Math.cos(n))},Xe}var Ye,Yc;function f2(){return Yc||(Yc=1,Ye=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)),Ye}var Ue,Uc;function h2(){if(Uc)return Ue;Uc=1;const{EPS:i}=Y(),{sin:e,cos:r}=ee(),t=f2();return Ue=(s,o,c)=>{let[a,u,f]=c;const h=a*a+u*u+f*f;if(Math.abs(h)<i)return t(s);const p=1/Math.sqrt(h);a*=p,u*=p,f*=p;const g=e(o),m=r(o),v=1-m;return s[0]=a*a*v+m,s[1]=u*a*v+f*g,s[2]=f*a*v-u*g,s[3]=0,s[4]=a*u*v-f*g,s[5]=u*u*v+m,s[6]=f*u*v+a*g,s[7]=0,s[8]=a*f*v+u*g,s[9]=u*f*v-a*g,s[10]=f*f*v+m,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s},Ue}var We,Wc;function Dg(){return Wc||(Wc=1,We=(e,r)=>(e[0]=r[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=r[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)),We}var Qe,Qc;function zg(){if(Qc)return Qe;Qc=1;const{sin:i,cos:e}=ee();return Qe=(t,n,s,o)=>{const c=i(n),a=e(n),u=i(s),f=e(s),h=i(o),p=e(o);return t[0]=f*a,t[1]=f*c,t[2]=-u,t[3]=0,t[4]=h*u*a-p*c,t[5]=p*a+h*u*c,t[6]=h*f,t[7]=0,t[8]=h*c+p*u*a,t[9]=p*u*c-h*a,t[10]=p*f,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Qe}var Ke,Kc;function Lg(){return Kc||(Kc=1,Ke=(e,r)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e)),Ke}var Je,Jc;function Ig(){if(Jc)return Je;Jc=1;const i=fc();return Je=(r,t,n,s,o,c,a,u,f,h,p,g,m,v,l,d)=>{const q=i();return q[0]=r,q[1]=t,q[2]=n,q[3]=s,q[4]=o,q[5]=c,q[6]=a,q[7]=u,q[8]=f,q[9]=h,q[10]=p,q[11]=g,q[12]=m,q[13]=v,q[14]=l,q[15]=d,q},Je}var je,jc;function d2(){return jc||(jc=1,je=(e,r)=>(e[0]=Math.abs(r[0]),e[1]=Math.abs(r[1]),e[2]=Math.abs(r[2]),e)),je}var et,eu;function g2(){return eu||(eu=1,et=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e[2]=r[2]+t[2],e)),et}var tt,tu;function Ee(){return tu||(tu=1,tt=(e,r)=>e[0]*r[0]+e[1]*r[1]+e[2]*r[2]),tt}var rt,ru;function Hg(){if(ru)return rt;ru=1;const i=Ee();return rt=(r,t)=>{const n=r[0],s=r[1],o=r[2],c=t[0],a=t[1],u=t[2],f=Math.sqrt(n*n+s*s+o*o),h=Math.sqrt(c*c+a*a+u*u),p=f*h,g=p&&i(r,t)/p;return Math.acos(Math.min(Math.max(g,-1),1))},rt}var nt,nu;function Ae(){return nu||(nu=1,nt=()=>[0,0,0]),nt}var st,su;function Zg(){if(su)return st;su=1;const i=Ae();return st=r=>{const t=i();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t},st}var ot,ou;function p2(){return ou||(ou=1,ot=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e)),ot}var it,iu;function pe(){return iu||(iu=1,it=(e,r,t)=>{const n=r[0],s=r[1],o=r[2],c=t[0],a=t[1],u=t[2];return e[0]=s*u-o*a,e[1]=o*c-n*u,e[2]=n*a-s*c,e}),it}var at,au;function m2(){return au||(au=1,at=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1],s=r[2]-e[2];return Math.sqrt(t*t+n*n+s*s)}),at}var ct,cu;function Xg(){return cu||(cu=1,ct=(e,r,t)=>(e[0]=r[0]/t[0],e[1]=r[1]/t[1],e[2]=r[2]/t[2],e)),ct}var ut,uu;function Yg(){return uu||(uu=1,ut=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]),ut}var lt,lu;function Ug(){return lu||(lu=1,lt=(e,r)=>(e[0]=r,e[1]=r,e[2]=r,e)),lt}var ft,fu;function Wg(){if(fu)return ft;fu=1;const i=Ae();return ft=(r,t,n)=>{const s=i();return s[0]=r,s[1]=t,s[2]=n,s},ft}var ht,hu;function Qg(){return hu||(hu=1,ht=(e,r,t=0)=>(e[0]=r[0],e[1]=r[1],e[2]=t,e)),ht}var dt,du;function v2(){return du||(du=1,dt=e=>{const r=e[0],t=e[1],n=e[2];return Math.sqrt(r*r+t*t+n*n)}),dt}var gt,gu;function Kg(){return gu||(gu=1,gt=(e,r,t,n)=>(e[0]=r[0]+n*(t[0]-r[0]),e[1]=r[1]+n*(t[1]-r[1]),e[2]=r[2]+n*(t[2]-r[2]),e)),gt}var pt,pu;function q2(){return pu||(pu=1,pt=(e,r,t)=>(e[0]=Math.max(r[0],t[0]),e[1]=Math.max(r[1],t[1]),e[2]=Math.max(r[2],t[2]),e)),pt}var mt,mu;function y2(){return mu||(mu=1,mt=(e,r,t)=>(e[0]=Math.min(r[0],t[0]),e[1]=Math.min(r[1],t[1]),e[2]=Math.min(r[2],t[2]),e)),mt}var vt,vu;function Jg(){return vu||(vu=1,vt=(e,r,t)=>(e[0]=r[0]*t[0],e[1]=r[1]*t[1],e[2]=r[2]*t[2],e)),vt}var qt,qu;function jg(){return qu||(qu=1,qt=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e[2]=-r[2],e)),qt}var yt,yu;function hc(){return yu||(yu=1,yt=(e,r)=>{const t=r[0],n=r[1],s=r[2];let o=t*t+n*n+s*s;return o>0&&(o=1/Math.sqrt(o)),e[0]=t*o,e[1]=n*o,e[2]=s*o,e}),yt}var wt,wu;function ep(){if(wu)return wt;wu=1;const i=d2(),e=Ae(),r=pe();return wt=(n,s)=>{const o=i(e(),s),c=0+(o[0]<o[1]&&o[0]<o[2]),a=0+(o[1]<=o[0]&&o[1]<o[2]),u=0+(o[2]<=o[0]&&o[2]<=o[1]);return r(n,s,[c,a,u])},wt}var Pt,Pu;function tp(){return Pu||(Pu=1,Pt=(e,r,t,n)=>{const s=[],o=[];return s[0]=r[0]-t[0],s[1]=r[1]-t[1],s[2]=r[2]-t[2],o[0]=s[0],o[1]=s[1]*Math.cos(n)-s[2]*Math.sin(n),o[2]=s[1]*Math.sin(n)+s[2]*Math.cos(n),e[0]=o[0]+t[0],e[1]=o[1]+t[1],e[2]=o[2]+t[2],e}),Pt}var Rt,Ru;function rp(){return Ru||(Ru=1,Rt=(e,r,t,n)=>{const s=[],o=[];return s[0]=r[0]-t[0],s[1]=r[1]-t[1],s[2]=r[2]-t[2],o[0]=s[2]*Math.sin(n)+s[0]*Math.cos(n),o[1]=s[1],o[2]=s[2]*Math.cos(n)-s[0]*Math.sin(n),e[0]=o[0]+t[0],e[1]=o[1]+t[1],e[2]=o[2]+t[2],e}),Rt}var xt,xu;function np(){return xu||(xu=1,xt=(e,r,t,n)=>{const s=[],o=[];return s[0]=r[0]-t[0],s[1]=r[1]-t[1],o[0]=s[0]*Math.cos(n)-s[1]*Math.sin(n),o[1]=s[0]*Math.sin(n)+s[1]*Math.cos(n),e[0]=o[0]+t[0],e[1]=o[1]+t[1],e[2]=r[2],e}),xt}var Et,Eu;function w2(){return Eu||(Eu=1,Et=(e,r,t)=>(e[0]=r[0]*t,e[1]=r[1]*t,e[2]=r[2]*t,e)),Et}var At,Au;function sp(){return Au||(Au=1,At=(e,r,t)=>(e[0]=Math.round(r[0]/t)*t+0,e[1]=Math.round(r[1]/t)*t+0,e[2]=Math.round(r[2]/t)*t+0,e)),At}var bt,bu;function P2(){return bu||(bu=1,bt=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1],s=r[2]-e[2];return t*t+n*n+s*s}),bt}var $t,$u;function R2(){return $u||($u=1,$t=e=>{const r=e[0],t=e[1],n=e[2];return r*r+t*t+n*n}),$t}var St,Su;function be(){return Su||(Su=1,St=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e[2]=r[2]-t[2],e)),St}var Tt,Tu;function op(){return Tu||(Tu=1,Tt=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`),Tt}var Mt,Mu;function ip(){return Mu||(Mu=1,Mt=(e,r,t)=>{const n=r[0],s=r[1],o=r[2];let c=t[3]*n+t[7]*s+t[11]*o+t[15];return c=c||1,e[0]=(t[0]*n+t[4]*s+t[8]*o+t[12])/c,e[1]=(t[1]*n+t[5]*s+t[9]*o+t[13])/c,e[2]=(t[2]*n+t[6]*s+t[10]*o+t[14])/c,e}),Mt}var _t,_u;function N(){return _u||(_u=1,_t={abs:d2(),add:g2(),angle:Hg(),clone:Zg(),copy:p2(),create:Ae(),cross:pe(),distance:m2(),divide:Xg(),dot:Ee(),equals:Yg(),fromScalar:Ug(),fromValues:Wg(),fromVec2:Qg(),length:v2(),lerp:Kg(),max:q2(),min:y2(),multiply:Jg(),negate:jg(),normalize:hc(),orthogonal:ep(),rotateX:tp(),rotateY:rp(),rotateZ:np(),scale:w2(),snap:sp(),squaredDistance:P2(),squaredLength:R2(),subtract:be(),toString:op(),transform:ip()}),_t}var Ct,Cu;function ap(){if(Cu)return Ct;Cu=1;const i=N(),e=h2();return Ct=(t,n,s)=>{const o=i.normalize(i.create(),n),c=i.normalize(i.create(),s),a=i.cross(i.create(),c,o),u=i.dot(c,o);if(u===-1)return e(t,Math.PI,i.orthogonal(a,o));const f=1/(1+u);return t[0]=a[0]*a[0]*f+u,t[1]=a[1]*a[0]*f-a[2],t[2]=a[2]*a[0]*f+a[1],t[3]=0,t[4]=a[0]*a[1]*f+a[2],t[5]=a[1]*a[1]*f+u,t[6]=a[2]*a[1]*f-a[0],t[7]=0,t[8]=a[0]*a[2]*f-a[1],t[9]=a[1]*a[2]*f+a[0],t[10]=a[2]*a[2]*f+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Ct}var Ft,Fu;function cp(){if(Fu)return Ft;Fu=1;const{sin:i,cos:e}=ee();return Ft=(t,n)=>{const s=i(n),o=e(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=s,t[7]=0,t[8]=0,t[9]=-s,t[10]=o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Ft}var Bt,Bu;function up(){if(Bu)return Bt;Bu=1;const{sin:i,cos:e}=ee();return Bt=(t,n)=>{const s=i(n),o=e(n);return t[0]=o,t[1]=0,t[2]=-s,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=s,t[9]=0,t[10]=o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Bt}var Vt,Vu;function lp(){if(Vu)return Vt;Vu=1;const{sin:i,cos:e}=ee();return Vt=(t,n)=>{const s=i(n),o=e(n);return t[0]=o,t[1]=s,t[2]=0,t[3]=0,t[4]=-s,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},Vt}var Ot,Ou;function fp(){return Ou||(Ou=1,Ot=e=>e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1),Ot}var kt,ku;function hp(){if(ku)return kt;ku=1;const i=r=>e(r[1])&&e(r[2])&&e(r[3])&&e(r[4])&&e(r[6])&&e(r[7])&&e(r[8])&&e(r[9])&&e(r[11])&&r[15]===1,e=r=>Math.abs(r)<Number.EPSILON;return kt=i,kt}var Nt,Nu;function dp(){return Nu||(Nu=1,Nt=e=>{const r=e[4]*e[9]-e[8]*e[5],t=e[8]*e[1]-e[0]*e[9],n=e[0]*e[5]-e[4]*e[1];return r*e[2]+t*e[6]+n*e[10]<0}),Nt}var Gt,Gu;function gp(){return Gu||(Gu=1,Gt=(e,r)=>{const[t,n,s,o]=r;return e[0]=1-2*t*t,e[1]=-2*n*t,e[2]=-2*s*t,e[3]=0,e[4]=-2*t*n,e[5]=1-2*n*n,e[6]=-2*s*n,e[7]=0,e[8]=-2*t*s,e[9]=-2*n*s,e[10]=1-2*s*s,e[11]=0,e[12]=2*t*o,e[13]=2*n*o,e[14]=2*s*o,e[15]=1,e}),Gt}var Dt,Du;function pp(){return Du||(Du=1,Dt=(e,r,t)=>{const n=r[0],s=r[1],o=r[2],c=r[3],a=r[4],u=r[5],f=r[6],h=r[7],p=r[8],g=r[9],m=r[10],v=r[11],l=r[12],d=r[13],q=r[14],y=r[15];let P=t[0],w=t[1],R=t[2],x=t[3];return e[0]=P*n+w*a+R*p+x*l,e[1]=P*s+w*u+R*g+x*d,e[2]=P*o+w*f+R*m+x*q,e[3]=P*c+w*h+R*v+x*y,P=t[4],w=t[5],R=t[6],x=t[7],e[4]=P*n+w*a+R*p+x*l,e[5]=P*s+w*u+R*g+x*d,e[6]=P*o+w*f+R*m+x*q,e[7]=P*c+w*h+R*v+x*y,P=t[8],w=t[9],R=t[10],x=t[11],e[8]=P*n+w*a+R*p+x*l,e[9]=P*s+w*u+R*g+x*d,e[10]=P*o+w*f+R*m+x*q,e[11]=P*c+w*h+R*v+x*y,P=t[12],w=t[13],R=t[14],x=t[15],e[12]=P*n+w*a+R*p+x*l,e[13]=P*s+w*u+R*g+x*d,e[14]=P*o+w*f+R*m+x*q,e[15]=P*c+w*h+R*v+x*y,e}),Dt}var zt,zu;function mp(){if(zu)return zt;zu=1;const{EPS:i}=Y(),{sin:e,cos:r}=ee(),t=l2();return zt=(s,o,c,a)=>{let[u,f,h]=a;const p=u*u+f*f+h*h;if(Math.abs(p)<i)return t(s,o);const g=1/Math.sqrt(p);u*=g,f*=g,h*=g;const m=e(c),v=r(c),l=1-v,d=o[0],q=o[1],y=o[2],P=o[3],w=o[4],R=o[5],x=o[6],E=o[7],A=o[8],_=o[9],S=o[10],b=o[11],T=u*u*l+v,M=f*u*l+h*m,$=h*u*l-f*m,C=u*f*l-h*m,F=f*f*l+v,B=h*f*l+u*m,O=u*h*l+f*m,V=f*h*l-u*m,k=h*h*l+v;return s[0]=d*T+w*M+A*$,s[1]=q*T+R*M+_*$,s[2]=y*T+x*M+S*$,s[3]=P*T+E*M+b*$,s[4]=d*C+w*F+A*B,s[5]=q*C+R*F+_*B,s[6]=y*C+x*F+S*B,s[7]=P*C+E*F+b*B,s[8]=d*O+w*V+A*k,s[9]=q*O+R*V+_*k,s[10]=y*O+x*V+S*k,s[11]=P*O+E*V+b*k,o!==s&&(s[12]=o[12],s[13]=o[13],s[14]=o[14],s[15]=o[15]),s},zt}var Lt,Lu;function vp(){if(Lu)return Lt;Lu=1;const{sin:i,cos:e}=ee();return Lt=(t,n,s)=>{const o=i(s),c=e(s),a=n[4],u=n[5],f=n[6],h=n[7],p=n[8],g=n[9],m=n[10],v=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=a*c+p*o,t[5]=u*c+g*o,t[6]=f*c+m*o,t[7]=h*c+v*o,t[8]=p*c-a*o,t[9]=g*c-u*o,t[10]=m*c-f*o,t[11]=v*c-h*o,t},Lt}var It,Iu;function qp(){if(Iu)return It;Iu=1;const{sin:i,cos:e}=ee();return It=(t,n,s)=>{const o=i(s),c=e(s),a=n[0],u=n[1],f=n[2],h=n[3],p=n[8],g=n[9],m=n[10],v=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=a*c-p*o,t[1]=u*c-g*o,t[2]=f*c-m*o,t[3]=h*c-v*o,t[8]=a*o+p*c,t[9]=u*o+g*c,t[10]=f*o+m*c,t[11]=h*o+v*c,t},It}var Ht,Hu;function yp(){if(Hu)return Ht;Hu=1;const{sin:i,cos:e}=ee();return Ht=(t,n,s)=>{const o=i(s),c=e(s),a=n[0],u=n[1],f=n[2],h=n[3],p=n[4],g=n[5],m=n[6],v=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=a*c+p*o,t[1]=u*c+g*o,t[2]=f*c+m*o,t[3]=h*c+v*o,t[4]=p*c-a*o,t[5]=g*c-u*o,t[6]=m*c-f*o,t[7]=v*c-h*o,t},Ht}var Zt,Zu;function wp(){return Zu||(Zu=1,Zt=(e,r,t)=>{const n=t[0],s=t[1],o=t[2];return e[0]=r[0]*n,e[1]=r[1]*n,e[2]=r[2]*n,e[3]=r[3]*n,e[4]=r[4]*s,e[5]=r[5]*s,e[6]=r[6]*s,e[7]=r[7]*s,e[8]=r[8]*o,e[9]=r[9]*o,e[10]=r[10]*o,e[11]=r[11]*o,e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e}),Zt}var Xt,Xu;function Pp(){return Xu||(Xu=1,Xt=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e[2]=r[2]-t[2],e[3]=r[3]-t[3],e[4]=r[4]-t[4],e[5]=r[5]-t[5],e[6]=r[6]-t[6],e[7]=r[7]-t[7],e[8]=r[8]-t[8],e[9]=r[9]-t[9],e[10]=r[10]-t[10],e[11]=r[11]-t[11],e[12]=r[12]-t[12],e[13]=r[13]-t[13],e[14]=r[14]-t[14],e[15]=r[15]-t[15],e)),Xt}var Yt,Yu;function Rp(){return Yu||(Yu=1,Yt=e=>e.map(r=>r.toFixed(7)).toString()),Yt}var Ut,Uu;function xp(){return Uu||(Uu=1,Ut=(e,r,t)=>{const n=t[0],s=t[1],o=t[2];let c,a,u,f,h,p,g,m,v,l,d,q;return r===e?(e[12]=r[0]*n+r[4]*s+r[8]*o+r[12],e[13]=r[1]*n+r[5]*s+r[9]*o+r[13],e[14]=r[2]*n+r[6]*s+r[10]*o+r[14],e[15]=r[3]*n+r[7]*s+r[11]*o+r[15]):(c=r[0],a=r[1],u=r[2],f=r[3],h=r[4],p=r[5],g=r[6],m=r[7],v=r[8],l=r[9],d=r[10],q=r[11],e[0]=c,e[1]=a,e[2]=u,e[3]=f,e[4]=h,e[5]=p,e[6]=g,e[7]=m,e[8]=v,e[9]=l,e[10]=d,e[11]=q,e[12]=c*n+h*s+v*o+r[12],e[13]=a*n+p*s+l*o+r[13],e[14]=u*n+g*s+d*o+r[14],e[15]=f*n+m*s+q*o+r[15]),e}),Ut}var Wt,Wu;function K(){return Wu||(Wu=1,Wt={add:Og(),clone:kg(),copy:l2(),create:fc(),invert:Ng(),equals:Gg(),fromRotation:h2(),fromScaling:Dg(),fromTaitBryanRotation:zg(),fromTranslation:Lg(),fromValues:Ig(),fromVectorRotation:ap(),fromXRotation:cp(),fromYRotation:up(),fromZRotation:lp(),identity:f2(),isIdentity:fp(),isOnlyTransformScale:hp(),isMirroring:dp(),mirrorByPlane:gp(),multiply:pp(),rotate:mp(),rotateX:vp(),rotateY:qp(),rotateZ:yp(),scale:wp(),subtract:Pp(),toString:Rp(),translate:xp()}),Wt}var Qt,Qu;function $e(){if(Qu)return Qt;Qu=1;const i=K();return Qt=r=>(r===void 0&&(r=[]),{sides:r,transforms:i.create()}),Qt}var Kt,Ku;function Ep(){return Ku||(Ku=1,Kt=(e,r)=>(e[0]=Math.abs(r[0]),e[1]=Math.abs(r[1]),e)),Kt}var Jt,Ju;function Ap(){return Ju||(Ju=1,Jt=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e)),Jt}var jt,ju;function dc(){return ju||(ju=1,jt=e=>Math.atan2(e[1],e[0])),jt}var er,el;function bp(){return el||(el=1,er=dc()),er}var tr,tl;function $p(){if(tl)return tr;tl=1;const i=dc();return tr=r=>i(r)*57.29577951308232,tr}var rr,rl;function Se(){return rl||(rl=1,rr=()=>[0,0]),rr}var nr,nl;function Sp(){if(nl)return nr;nl=1;const i=Se();return nr=r=>{const t=i();return t[0]=r[0],t[1]=r[1],t},nr}var sr,sl;function Tp(){return sl||(sl=1,sr=(e,r)=>(e[0]=r[0],e[1]=r[1],e)),sr}var or,ol;function Mp(){return ol||(ol=1,or=(e,r,t)=>(e[0]=0,e[1]=0,e[2]=r[0]*t[1]-r[1]*t[0],e)),or}var ir,il;function _p(){return il||(il=1,ir=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1];return Math.sqrt(t*t+n*n)}),ir}var ar,al;function Cp(){return al||(al=1,ar=(e,r,t)=>(e[0]=r[0]/t[0],e[1]=r[1]/t[1],e)),ar}var cr,cl;function Fp(){return cl||(cl=1,cr=(e,r)=>e[0]*r[0]+e[1]*r[1]),cr}var ur,ul;function Bp(){return ul||(ul=1,ur=(e,r)=>e[0]===r[0]&&e[1]===r[1]),ur}var lr,ll;function x2(){if(ll)return lr;ll=1;const{sin:i,cos:e}=ee();return lr=(t,n)=>(t[0]=e(n),t[1]=i(n),t),lr}var fr,fl;function Vp(){if(fl)return fr;fl=1;const i=x2();return fr=(r,t)=>i(r,t*.017453292519943295),fr}var hr,hl;function Op(){return hl||(hl=1,hr=(e,r)=>(e[0]=r,e[1]=r,e)),hr}var dr,dl;function kp(){if(dl)return dr;dl=1;const i=Se();return dr=(r,t)=>{const n=i();return n[0]=r,n[1]=t,n},dr}var gr,gl;function Np(){return gl||(gl=1,gr=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1])),gr}var pr,pl;function Gp(){return pl||(pl=1,pr=(e,r,t,n)=>{const s=r[0],o=r[1];return e[0]=s+n*(t[0]-s),e[1]=o+n*(t[1]-o),e}),pr}var mr,ml;function Dp(){return ml||(ml=1,mr=(e,r,t)=>(e[0]=Math.max(r[0],t[0]),e[1]=Math.max(r[1],t[1]),e)),mr}var vr,vl;function zp(){return vl||(vl=1,vr=(e,r,t)=>(e[0]=Math.min(r[0],t[0]),e[1]=Math.min(r[1],t[1]),e)),vr}var qr,ql;function Lp(){return ql||(ql=1,qr=(e,r,t)=>(e[0]=r[0]*t[0],e[1]=r[1]*t[1],e)),qr}var yr,yl;function Ip(){return yl||(yl=1,yr=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e)),yr}var wr,wl;function E2(){return wl||(wl=1,wr=(e,r,t,n)=>{const s=r[0]-t[0],o=r[1]-t[1],c=Math.cos(n),a=Math.sin(n);return e[0]=s*c-o*a+t[0],e[1]=s*a+o*c+t[1],e}),wr}var Pr,Pl;function Hp(){if(Pl)return Pr;Pl=1;const{TAU:i}=Y(),e=Se(),r=E2();return Pr=(n,s)=>r(n,s,e(),i/4),Pr}var Rr,Rl;function Zp(){return Rl||(Rl=1,Rr=(e,r)=>{const t=r[0],n=r[1];let s=t*t+n*n;return s>0&&(s=1/Math.sqrt(s)),e[0]=t*s,e[1]=n*s,e}),Rr}var xr,xl;function Xp(){return xl||(xl=1,xr=(e,r,t)=>(e[0]=r[0]*t,e[1]=r[1]*t,e)),xr}var Er,El;function Yp(){return El||(El=1,Er=(e,r,t)=>(e[0]=Math.round(r[0]/t)*t+0,e[1]=Math.round(r[1]/t)*t+0,e)),Er}var Ar,Al;function Up(){return Al||(Al=1,Ar=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1];return t*t+n*n}),Ar}var br,bl;function Wp(){return bl||(bl=1,br=e=>{const r=e[0],t=e[1];return r*r+t*t}),br}var $r,$l;function Qp(){return $l||($l=1,$r=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e)),$r}var Sr,Sl;function Kp(){return Sl||(Sl=1,Sr=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`),Sr}var Tr,Tl;function Jp(){return Tl||(Tl=1,Tr=(e,r,t)=>{const n=r[0],s=r[1];return e[0]=t[0]*n+t[4]*s+t[12],e[1]=t[1]*n+t[5]*s+t[13],e}),Tr}var Mr,Ml;function I(){return Ml||(Ml=1,Mr={abs:Ep(),add:Ap(),angle:bp(),angleDegrees:$p(),angleRadians:dc(),clone:Sp(),copy:Tp(),create:Se(),cross:Mp(),distance:_p(),divide:Cp(),dot:Fp(),equals:Bp(),fromAngleDegrees:Vp(),fromAngleRadians:x2(),fromScalar:Op(),fromValues:kp(),length:Np(),lerp:Gp(),max:Dp(),min:zp(),multiply:Lp(),negate:Ip(),normal:Hp(),normalize:Zp(),rotate:E2(),scale:Xp(),snap:Yp(),squaredDistance:Up(),squaredLength:Wp(),subtract:Qp(),toString:Kp(),transform:Jp()}),Mr}var _r,_l;function jp(){if(_l)return _r;_l=1;const i=I(),e=$e();return _r=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");let n=t.length;if(n<3)throw new Error("the given points must define a closed geometry with three or more points");i.equals(t[0],t[n-1])&&--n;const s=[];let o=t[n-1];for(let c=0;c<n;c++){const a=t[c];s.push([i.clone(o),i.clone(a)]),o=a}return e(s)},_r}var Cr,Cl;function em(){if(Cl)return Cr;Cl=1;const i=K(),e=I(),r=$e();return Cr=n=>{if(n[0]!==0)throw new Error("invalid compact binary data");const s=r();s.transforms=i.clone(n.slice(1,17));for(let o=21;o<n.length;o+=4){const c=e.fromValues(n[o+0],n[o+1]),a=e.fromValues(n[o+2],n[o+3]);s.sides.push([c,a])}return n[17]>=0&&(s.color=[n[17],n[18],n[19],n[20]]),s},Cr}var Fr,Fl;function A2(){return Fl||(Fl=1,Fr=e=>!!(e&&typeof e=="object"&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms)),Fr}var Br,Bl;function tm(){if(Bl)return Br;Bl=1;const i=K(),e=I();return Br=t=>(i.isIdentity(t.transforms)||(t.sides=t.sides.map(n=>{const s=e.transform(e.create(),n[0],t.transforms),o=e.transform(e.create(),n[1],t.transforms);return[s,o]}),t.transforms=i.create()),t),Br}var Vr,Vl;function me(){if(Vl)return Vr;Vl=1;const i=tm();return Vr=r=>i(r).sides,Vr}var Or,Ol;function b2(){if(Ol)return Or;Ol=1;const i=$e(),e=me();return Or=t=>{const s=e(t).map(o=>[o[1],o[0]]);return s.reverse(),i(s)},Or}var kr,kl;function $2(){if(kl)return kr;kl=1;const i=I(),e=me(),r=o=>{const c=new Map,a=u=>{const f=u.toString();return c.has(f)?c.get(f):(c.set(f,u),u)};return o.map(u=>u.map(a))},t=o=>{const c=new Map;return r(o).forEach(u=>{c.has(u[0])?c.get(u[0]).push(u):c.set(u[0],[u])}),c},n=o=>{const c=t(e(o)),a=[];for(;;){let u;for(const[p,g]of c){if(u=g.shift(),!u){c.delete(p);continue}break}if(u===void 0)break;const f=[],h=u[0];for(;;){f.push(u[0]);const p=u[1];if(p===h)break;const g=c.get(p);if(!g)throw new Error(`geometry is not closed at vertex ${p}`);const m=s(u,g);g.length===0&&c.delete(p),u=m}f.length>0&&f.push(f.shift()),a.push(f)}return c.clear(),a},s=(o,c)=>{if(c.length===1)return c.pop();const a=i.create(),u=i.angleDegrees(i.subtract(a,o[1],o[0]));let f,h;c.forEach((g,m)=>{let l=i.angleDegrees(i.subtract(a,g[1],g[0]))-u;l<-180&&(l+=360),l>=180&&(l-=360),(h===void 0||l>f)&&(h=m,f=l)});const p=c[h];return c.splice(h,1),p};return kr=n,kr}var Nr,Nl;function rm(){if(Nl)return Nr;Nl=1;const i=me();return Nr=r=>{const n=i(r).map(s=>s[0]);return n.length>0&&n.push(n.shift()),n},Nr}var Gr,Gl;function nm(){if(Gl)return Gr;Gl=1;const i=I(),e=me();return Gr=t=>{const n=e(t);let s="geom2 ("+n.length+` sides):
[
`;return n.forEach(o=>{s+="  ["+i.toString(o[0])+", "+i.toString(o[1])+`]
`}),s+=`]
`,s},Gr}var Dr,Dl;function sm(){return Dl||(Dl=1,Dr=e=>{const r=e.sides,t=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(21+r.length*4);s[0]=0,s[1]=t[0],s[2]=t[1],s[3]=t[2],s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=t[6],s[8]=t[7],s[9]=t[8],s[10]=t[9],s[11]=t[10],s[12]=t[11],s[13]=t[12],s[14]=t[13],s[15]=t[14],s[16]=t[15],s[17]=n[0],s[18]=n[1],s[19]=n[2],s[20]=n[3];for(let o=0;o<r.length;o++){const c=o*4+21,a=r[o][0],u=r[o][1];s[c+0]=a[0],s[c+1]=a[1],s[c+2]=u[0],s[c+3]=u[1]}return s}),Dr}var zr,zl;function om(){if(zl)return zr;zl=1;const i=K(),e=b2();return zr=(t,n)=>{const s=i.multiply(i.create(),t,n.transforms),o=Object.assign({},n,{transforms:s});return t[0]*t[5]-t[4]*t[1]<0?e(o):o},zr}var Lr,Ll;function im(){if(Ll)return Lr;Ll=1;const i=I(),e=A2(),r=$2();return Lr=n=>{if(!e(n))throw new Error("invalid geom2 structure");if(r(n),n.sides.forEach(s=>{if(i.equals(s[0],s[1]))throw new Error(`geom2 self-edge ${s[0]}`)}),!n.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${n.transforms}`)},Lr}var Ir,Il;function z(){return Il||(Il=1,Ir={clone:Vg(),create:$e(),fromPoints:jp(),fromCompactBinary:em(),isA:A2(),reverse:b2(),toOutlines:$2(),toPoints:rm(),toSides:me(),toString:nm(),toCompactBinary:sm(),transform:om(),validate:im()}),Ir}var Hr,Hl;function am(){return Hl||(Hl=1,Hr=e=>Object.assign({},e)),Hr}var Zr,Zl;function ve(){if(Zl)return Zr;Zl=1;const i=K();return Zr=r=>(r===void 0&&(r=[]),{polygons:r,transforms:i.create()}),Zr}var Xr,Xl;function cm(){if(Xl)return Xr;Xl=1;const i=pe(),e=be(),r=R2(),t=(s,o,c)=>{const a=[],u=[],f=[];e(a,c,o),e(u,s,o);const h=r(i(f,u,a)),p=r(a);if(p===0)throw Error("a and b are the same point");return h/p};return Xr=(s,o,c)=>Math.sqrt(t(s,o,c)),Xr}var Yr,Yl;function um(){if(Yl)return Yr;Yl=1;const i=pe(),e=hc(),r=be();return Yr=(n,s,o,c)=>{const a=[0,0,0];return r(n,s,o),r(a,o,c),i(n,n,a),e(n,n)},Yr}var Ur,Ul;function lm(){if(Ul)return Ur;Ul=1;class i{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(r,t){t.prev=r.prev,t.next=r,t.prev?t.prev.next=t:this.head=t,r.prev=t}insertAfter(r,t){t.prev=r,t.next=r.next,t.next?t.next.prev=t:this.tail=t,r.next=t}add(r){this.head?this.tail.next=r:this.head=r,r.prev=this.tail,r.next=null,this.tail=r}addAll(r){for(this.head?this.tail.next=r:this.head=r,r.prev=this.tail;r.next;)r=r.next;this.tail=r}remove(r){r.prev?r.prev.next=r.next:this.head=r.next,r.next?r.next.prev=r.prev:this.tail=r.prev}removeChain(r,t){r.prev?r.prev.next=t.next:this.head=t.next,t.next?t.next.prev=r.prev:this.tail=r.prev}first(){return this.head}isEmpty(){return!this.head}}return Ur=i,Ur}var Wr,Wl;function fm(){if(Wl)return Wr;Wl=1;class i{constructor(r,t){this.point=r,this.index=t,this.next=null,this.prev=null,this.face=null}}return Wr=i,Wr}var Qr,Ql;function hm(){if(Ql)return Qr;Ql=1;const i=m2(),e=P2();class r{constructor(n,s){this.vertex=n,this.face=s,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?i(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?e(this.tail().point,this.head().point):-1}setOpposite(n){this.opposite=n,n.opposite=this}}return Qr=r,Qr}var Kr,Kl;function dm(){if(Kl)return Kr;Kl=1;const i=g2(),e=p2(),r=pe(),t=Ee(),n=v2(),s=hc(),o=w2(),c=be(),a=hm(),u=0,f=1,h=2;class p{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=u,this.edge=null,this.nVertices=0}getEdge(m){if(typeof m!="number")throw Error("requires a number");let v=this.edge;for(;m>0;)v=v.next,m-=1;for(;m<0;)v=v.prev,m+=1;return v}computeNormal(){const m=this.edge,v=m.next;let l=v.next;const d=c([],v.head().point,m.head().point),q=[],y=[];for(this.nVertices=2,this.normal=[0,0,0];l!==m;)e(y,d),c(d,l.head().point,m.head().point),i(this.normal,this.normal,r(q,y,d)),l=l.next,this.nVertices+=1;this.area=n(this.normal),this.normal=o(this.normal,this.normal,1/this.area)}computeNormalMinArea(m){if(this.computeNormal(),this.area<m){let v,l=0,d=this.edge;do{const x=d.lengthSquared();x>l&&(v=d,l=x),d=d.next}while(d!==this.edge);const q=v.tail().point,y=v.head().point,P=c([],y,q),w=Math.sqrt(l);o(P,P,1/w);const R=t(this.normal,P);o(P,P,-R),i(this.normal,this.normal,P),s(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let m=this.edge;do i(this.centroid,this.centroid,m.head().point),m=m.next;while(m!==this.edge);o(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(m){typeof m<"u"?this.computeNormalMinArea(m):this.computeNormal(),this.computeCentroid(),this.offset=t(this.normal,this.centroid)}distanceToPlane(m){return t(this.normal,m)-this.offset}connectHalfEdges(m,v){let l;if(m.opposite.face===v.opposite.face){const d=v.opposite.face;let q;m===this.edge&&(this.edge=v),d.nVertices===3?(q=v.opposite.prev.opposite,d.mark=h,l=d):(q=v.opposite.next,d.edge===q.prev&&(d.edge=q),q.prev=q.prev.prev,q.prev.next=q),v.prev=m.prev,v.prev.next=v,v.setOpposite(q),d.computeNormalAndCentroid()}else m.next=v,v.prev=m;return l}mergeAdjacentFaces(m,v){const l=m.opposite,d=l.face;v.push(d),d.mark=h;let q=m.prev,y=m.next,P=l.prev,w=l.next;for(;q.opposite.face===d;)q=q.prev,w=w.next;for(;y.opposite.face===d;)y=y.next,P=P.prev;let R;for(R=w;R!==P.next;R=R.next)R.face=this;this.edge=y;let x;return x=this.connectHalfEdges(P,y),x&&v.push(x),x=this.connectHalfEdges(q,w),x&&v.push(x),this.computeNormalAndCentroid(),v}collectIndices(){const m=[];let v=this.edge;do m.push(v.head().index),v=v.next;while(v!==this.edge);return m}static createTriangle(m,v,l,d=0){const q=new p,y=new a(m,q),P=new a(v,q),w=new a(l,q);return y.next=w.prev=P,P.next=y.prev=w,w.next=P.prev=y,q.edge=y,q.computeNormalAndCentroid(d),q}}return Kr={VISIBLE:u,NON_CONVEX:f,DELETED:h,Face:p},Kr}var Jr,Jl;function gm(){if(Jl)return Jr;Jl=1;const i=Ee(),e=cm(),r=um(),t=lm(),n=fm(),{Face:s,VISIBLE:o,NON_CONVEX:c,DELETED:a}=dm(),u=1,f=2;class h{constructor(g){if(!Array.isArray(g))throw TypeError("input is not a valid array");if(g.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=g.length,this.faces=[],this.newFaces=[],this.claimed=new t,this.unclaimed=new t,this.vertices=[];for(let m=0;m<g.length;m+=1)this.vertices.push(new n(g[m],m));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(g,m){g.face=m,m.outside?this.claimed.insertBefore(m.outside,g):this.claimed.add(g),m.outside=g}removeVertexFromFace(g,m){g===m.outside&&(g.next&&g.next.face===m?m.outside=g.next:m.outside=null),this.claimed.remove(g)}removeAllVerticesFromFace(g){if(g.outside){let m=g.outside;for(;m.next&&m.next.face===g;)m=m.next;return this.claimed.removeChain(g.outside,m),m.next=null,g.outside}}deleteFaceVertices(g,m){const v=this.removeAllVerticesFromFace(g);if(v)if(!m)this.unclaimed.addAll(v);else{let l;for(let d=v;d;d=l)l=d.next,m.distanceToPlane(d.point)>this.tolerance?this.addVertexToFace(d,m):this.unclaimed.add(d)}}resolveUnclaimedPoints(g){let m=this.unclaimed.first();for(let v=m;v;v=m){m=v.next;let l=this.tolerance,d;for(let q=0;q<g.length;q+=1){const y=g[q];if(y.mark===o){const P=y.distanceToPlane(v.point);if(P>l&&(l=P,d=y),l>1e3*this.tolerance)break}}d&&this.addVertexToFace(v,d)}}computeExtremes(){const g=[],m=[],v=[],l=[];let d,q;for(d=0;d<3;d+=1)v[d]=l[d]=this.vertices[0];for(d=0;d<3;d+=1)g[d]=m[d]=this.vertices[0].point[d];for(d=1;d<this.vertices.length;d+=1){const y=this.vertices[d],P=y.point;for(q=0;q<3;q+=1)P[q]<g[q]&&(g[q]=P[q],v[q]=y);for(q=0;q<3;q+=1)P[q]>m[q]&&(m[q]=P[q],l[q]=y)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(g[0]),Math.abs(m[0]))+Math.max(Math.abs(g[1]),Math.abs(m[1]))+Math.max(Math.abs(g[2]),Math.abs(m[2]))),[v,l]}createInitialSimplex(){const g=this.vertices,[m,v]=this.computeExtremes();let l,d,q,y,P=0,w=0;for(q=0;q<3;q+=1){const S=v[q].point[q]-m[q].point[q];S>P&&(P=S,w=q)}const R=m[w],x=v[w];for(P=0,q=0;q<this.vertices.length;q+=1){const S=this.vertices[q];if(S!==R&&S!==x){const b=e(S.point,R.point,x.point);b>P&&(P=b,l=S)}}const E=r([],R.point,x.point,l.point),A=i(R.point,E);for(P=-1,q=0;q<this.vertices.length;q+=1){const S=this.vertices[q];if(S!==R&&S!==x&&S!==l){const b=Math.abs(i(E,S.point)-A);b>P&&(P=b,d=S)}}const _=[];if(i(d.point,E)-A<0)for(_.push(s.createTriangle(R,x,l),s.createTriangle(d,x,R),s.createTriangle(d,l,x),s.createTriangle(d,R,l)),q=0;q<3;q+=1){const S=(q+1)%3;_[q+1].getEdge(2).setOpposite(_[0].getEdge(S)),_[q+1].getEdge(1).setOpposite(_[S+1].getEdge(0))}else for(_.push(s.createTriangle(R,l,x),s.createTriangle(d,R,x),s.createTriangle(d,x,l),s.createTriangle(d,l,R)),q=0;q<3;q+=1){const S=(q+1)%3;_[q+1].getEdge(2).setOpposite(_[0].getEdge((3-q)%3)),_[q+1].getEdge(0).setOpposite(_[S+1].getEdge(1))}for(q=0;q<4;q+=1)this.faces.push(_[q]);for(q=0;q<g.length;q+=1){const S=g[q];if(S!==R&&S!==x&&S!==l&&S!==d){P=this.tolerance;let b;for(y=0;y<4;y+=1){const T=_[y].distanceToPlane(S.point);T>P&&(P=T,b=_[y])}b&&this.addVertexToFace(S,b)}}}reindexFaceAndVertices(){const g=[];for(let m=0;m<this.faces.length;m+=1){const v=this.faces[m];v.mark===o&&g.push(v)}this.faces=g}collectFaces(g){const m=[];for(let v=0;v<this.faces.length;v+=1){if(this.faces[v].mark!==o)throw Error("attempt to include a destroyed face in the hull");const l=this.faces[v].collectIndices();if(g)m.push(l);else for(let d=0;d<l.length-2;d+=1)m.push([l[0],l[d+1],l[d+2]])}return m}nextVertexToAdd(){if(!this.claimed.isEmpty()){let g,m,v=0;const l=this.claimed.first().face;for(m=l.outside;m&&m.face===l;m=m.next){const d=l.distanceToPlane(m.point);d>v&&(v=d,g=m)}return g}}computeHorizon(g,m,v,l){this.deleteFaceVertices(v),v.mark=a;let d;m?d=m.next:d=m=v.getEdge(0);do{const q=d.opposite,y=q.face;y.mark===o&&(y.distanceToPlane(g)>this.tolerance?this.computeHorizon(g,q,y,l):l.push(d)),d=d.next}while(d!==m)}addAdjoiningFace(g,m){const v=s.createTriangle(g,m.tail(),m.head());return this.faces.push(v),v.getEdge(-1).setOpposite(m.opposite),v.getEdge(0)}addNewFaces(g,m){this.newFaces=[];let v,l;for(let d=0;d<m.length;d+=1){const q=m[d],y=this.addAdjoiningFace(g,q);v?y.next.setOpposite(l):v=y,this.newFaces.push(y.face),l=y}v.next.setOpposite(l)}oppositeFaceDistance(g){return g.face.distanceToPlane(g.opposite.face.centroid)}doAdjacentMerge(g,m){let v=g.edge,l=!0,d=0;do{if(d>=g.nVertices)throw Error("merge recursion limit exceeded");const q=v.opposite.face;let y=!1;if(m===f?(this.oppositeFaceDistance(v)>-this.tolerance||this.oppositeFaceDistance(v.opposite)>-this.tolerance)&&(y=!0):g.area>q.area?this.oppositeFaceDistance(v)>-this.tolerance?y=!0:this.oppositeFaceDistance(v.opposite)>-this.tolerance&&(l=!1):this.oppositeFaceDistance(v.opposite)>-this.tolerance?y=!0:this.oppositeFaceDistance(v)>-this.tolerance&&(l=!1),y){const P=g.mergeAdjacentFaces(v,[]);for(let w=0;w<P.length;w+=1)this.deleteFaceVertices(P[w],g);return!0}v=v.next,d+=1}while(v!==g.edge);return l||(g.mark=c),!1}addVertexToHull(g){const m=[];this.unclaimed.clear(),this.removeVertexFromFace(g,g.face),this.computeHorizon(g.point,null,g.face,m),this.addNewFaces(g,m);for(let v=0;v<this.newFaces.length;v+=1){const l=this.newFaces[v];if(l.mark===o)for(;this.doAdjacentMerge(l,u););}for(let v=0;v<this.newFaces.length;v+=1){const l=this.newFaces[v];if(l.mark===c)for(l.mark=o;this.doAdjacentMerge(l,f););}this.resolveUnclaimedPoints(this.newFaces)}build(){let g;for(this.createInitialSimplex();g=this.nextVertexToAdd();)this.addVertexToHull(g);this.reindexFaceAndVertices()}}return Jr=h,Jr}var jr,jl;function S2(){if(jl)return jr;jl=1;const i=gm();return jr=(r,t={})=>{const n=new i(r);return n.build(),n.collectFaces(t.skipTriangulation)},jr}var en,e1;function le(){return e1||(e1=1,en=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e})),en}var tn,t1;function pm(){if(t1)return tn;t1=1;const i=le(),e=N();return tn=(...t)=>{let n,s;return t.length===1?(n=i(),s=t[0]):(n=t[0],s=t[1]),n.vertices=s.vertices.map(o=>e.clone(o)),n},tn}var rn,r1;function mm(){if(r1)return rn;r1=1;const i=N(),e=le();return rn=t=>{const n=t.map(s=>i.clone(s));return e(n)},rn}var nn,n1;function vm(){if(n1)return nn;n1=1;const i=le();return nn=(r,t)=>{const n=i(r);return n.plane=t,n},nn}var sn,s1;function Te(){return s1||(s1=1,sn=()=>[0,0,0,0]),sn}var on,o1;function T2(){if(o1)return on;o1=1;const i=Te();return on=r=>{const t=i();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t},on}var an,i1;function M2(){return i1||(i1=1,an=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e)),an}var cn,a1;function _2(){return a1||(a1=1,cn=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]&&e[3]===r[3]),cn}var un,c1;function C2(){return c1||(c1=1,un=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e[2]=-r[2],e[3]=-r[3],e)),un}var ln,u1;function F2(){if(u1)return ln;u1=1;const i=N();return ln=(r,t,n)=>{const s=i.normalize(i.create(),t),o=i.dot(n,s);return r[0]=s[0],r[1]=s[1],r[2]=s[2],r[3]=o,r},ln}var fn,l1;function B2(){if(l1)return fn;l1=1;const i=Te();return fn=(r,t,n,s)=>{const o=i();return o[0]=r,o[1]=t,o[2]=n,o[3]=s,o},fn}var hn,f1;function qm(){if(f1)return hn;f1=1;const i=N(),e=F2();return hn=(t,...n)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0;const s=n.length;n.forEach(l=>{i.add(t,t,l)}),i.scale(t,t,1/s);let o=0,c=0,a=0,u=0,f=0,h=0;const p=i.create();n.forEach(l=>{i.subtract(p,l,t),o+=p[0]*p[0],c+=p[0]*p[1],a+=p[0]*p[2],u+=p[1]*p[1],f+=p[1]*p[2],h+=p[2]*p[2]}),o/=s,c/=s,a/=s,u/=s,f/=s,h/=s,p[0]=0,p[1]=0,p[2]=0;const g=i.create();let m=u*h-f*f;g[0]=m,g[1]=a*f-c*h,g[2]=c*f-a*u;let v=m*m;return i.add(p,p,i.scale(g,g,v)),m=o*h-a*a,g[0]=a*f-c*h,g[1]=m,g[2]=c*a-f*o,v=m*m,i.dot(p,g)<0&&(v=-v),i.add(p,p,i.scale(g,g,v)),m=o*u-c*c,g[0]=c*f-a*u,g[1]=c*a-f*o,g[2]=m,v=m*m,i.dot(p,g)<0&&(v=-v),i.add(p,p,i.scale(g,g,v)),e(t,p,t)},hn}var dn,h1;function V2(){if(h1)return dn;h1=1;const i=N();return dn=(r,...t)=>{const n=t.length,s=i.create(),o=i.create(),c=a=>{const u=t[a],f=t[(a+1)%n],h=t[(a+2)%n];return i.subtract(s,f,u),i.subtract(o,h,u),i.cross(s,s,o),i.normalize(s,s),s};return r[0]=0,r[1]=0,r[2]=0,n===3?i.copy(r,c(0)):(t.forEach((a,u)=>{i.add(r,r,c(u))}),i.normalize(r,r)),r[3]=i.dot(r,t[0]),r},dn}var gn,d1;function ym(){if(d1)return gn;d1=1;const{EPS:i}=Y(),e=N();return gn=(t,n,s,o)=>{let c=e.subtract(e.create(),s,n),a=e.subtract(e.create(),o,n);e.length(c)<i&&(c=e.orthogonal(c,a)),e.length(a)<i&&(a=e.orthogonal(a,c));let u=e.cross(e.create(),c,a);e.length(u)<i&&(a=e.orthogonal(a,c),u=e.cross(u,c,a)),u=e.normalize(u,u);const f=e.dot(u,n);return t[0]=u[0],t[1]=u[1],t[2]=u[2],t[3]=f,t},gn}var pn,g1;function wm(){if(g1)return pn;g1=1;const i=N();return pn=(r,t)=>{const n=t[0]*r[0]+t[1]*r[1]+t[2]*r[2]-r[3],s=t[0]-n*r[0],o=t[1]-n*r[1],c=t[2]-n*r[2];return i.fromValues(s,o,c)},pn}var mn,p1;function O2(){if(p1)return mn;p1=1;const i=N();return mn=(r,t)=>i.dot(r,t)-r[3],mn}var vn,m1;function k2(){return m1||(m1=1,vn=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`),vn}var qn,v1;function Pm(){if(v1)return qn;v1=1;const i=K(),e=N(),r=V2(),t=C2();return qn=(s,o,c)=>{const a=i.isMirroring(c),u=e.orthogonal(e.create(),o),f=e.cross(u,o,u),h=e.cross(e.create(),o,f);let p=e.fromScalar(e.create(),o[3]);e.multiply(p,p,o);let g=e.add(e.create(),p,f),m=e.add(e.create(),p,h);return p=e.transform(p,p,c),g=e.transform(g,g,c),m=e.transform(m,m,c),r(s,p,g,m),a&&t(s,s),s},qn}var yn,q1;function re(){return q1||(q1=1,yn={clone:T2(),copy:M2(),create:Te(),equals:_2(),flip:C2(),fromNormalAndPoint:F2(),fromValues:B2(),fromNoisyPoints:qm(),fromPoints:V2(),fromPointsRandom:ym(),projectionOfPoint:wm(),signedDistanceToPoint:O2(),toString:k2(),transform:Pm()}),yn}var wn,y1;function Rm(){if(y1)return wn;y1=1;const i=re(),e=le();return wn=t=>{const n=t.vertices.slice().reverse(),s=e(n);return t.plane&&(s.plane=i.flip(i.create(),t.plane)),s},wn}var Pn,w1;function N2(){return w1||(w1=1,Pn=e=>!!(e&&typeof e=="object"&&"vertices"in e&&Array.isArray(e.vertices))),Pn}var Rn,P1;function G2(){if(P1)return Rn;P1=1;const i=re(),e=N(),r=s=>t(s.vertices),t=s=>{const o=s.length;if(o>2){const c=i.fromPoints(i.create(),...s);let a=s[o-2],u=s[o-1];for(let f=0;f<o;f++){const h=s[f];if(!n(a,u,h,c))return!1;a=u,u=h}}return!0},n=(s,o,c,a)=>{const u=e.cross(e.create(),e.subtract(e.create(),o,s),e.subtract(e.create(),c,o));return e.dot(u,a)>=0};return Rn=r,Rn}var xn,R1;function gc(){if(R1)return xn;R1=1;const i=re();return xn=r=>(r.plane||(r.plane=i.fromPoints(i.create(),...r.vertices)),r.plane),xn}var En,x1;function D2(){if(x1)return En;x1=1;const i=gc();return En=r=>{const t=r.vertices.length;if(t<3)return 0;const n=r.vertices,s=i(r),o=Math.abs(s[0]),c=Math.abs(s[1]),a=Math.abs(s[2]);if(o+c+a===0)return 0;let u=3;o>c&&o>a?u=1:c>a&&(u=2);let f=0,h=0,p=1,g=2;switch(u){case 1:for(p=1;p<t;p++)h=p-1,g=(p+1)%t,f+=n[p][1]*(n[g][2]-n[h][2]);f+=n[0][1]*(n[1][2]-n[t-1][2]),f/=2*s[0];break;case 2:for(p=1;p<t;p++)h=p-1,g=(p+1)%t,f+=n[p][2]*(n[g][0]-n[h][0]);f+=n[0][2]*(n[1][0]-n[t-1][0]),f/=2*s[1];break;default:for(p=1;p<t;p++)h=p-1,g=(p+1)%t,f+=n[p][0]*(n[g][1]-n[h][1]);f+=n[0][0]*(n[1][1]-n[t-1][1]),f/=2*s[2];break}return f},En}var An,E1;function xm(){if(E1)return An;E1=1;const i=N();return An=r=>{const t=r.vertices,n=t.length,s=n===0?i.create():i.clone(t[0]),o=i.clone(s);for(let c=1;c<n;c++)i.min(s,s,t[c]),i.max(o,o,t[c]);return[s,o]},An}var bn,A1;function Em(){return A1||(A1=1,bn=(e,r)=>e[0]*r[0]+e[1]*r[1]+e[2]*r[2]+e[3]*r[3]),bn}var $n,b1;function Am(){return b1||(b1=1,$n=(e,r)=>(e[0]=r,e[1]=r,e[2]=r,e[3]=r,e)),$n}var Sn,$1;function bm(){return $1||($1=1,Sn=(e,r,t)=>{const[n,s,o,c]=r;return e[0]=t[0]*n+t[4]*s+t[8]*o+t[12]*c,e[1]=t[1]*n+t[5]*s+t[9]*o+t[13]*c,e[2]=t[2]*n+t[6]*s+t[10]*o+t[14]*c,e[3]=t[3]*n+t[7]*s+t[11]*o+t[15]*c,e}),Sn}var Tn,S1;function z2(){return S1||(S1=1,Tn={clone:T2(),copy:M2(),create:Te(),dot:Em(),equals:_2(),fromScalar:Am(),fromValues:B2(),toString:k2(),transform:bm()}),Tn}var Mn,T1;function $m(){if(T1)return Mn;T1=1;const i=z2(),e=new WeakMap;return Mn=t=>{const n=e.get(t);if(n)return n;const s=t.vertices,o=i.create();if(s.length===0)return o[0]=0,o[1]=0,o[2]=0,o[3]=0,o;let c=s[0],a=c,u=c,f=c,h=c,p=c;s.forEach(l=>{c[0]>l[0]&&(c=l),a[1]>l[1]&&(a=l),u[2]>l[2]&&(u=l),f[0]<l[0]&&(f=l),h[1]<l[1]&&(h=l),p[2]<l[2]&&(p=l)}),o[0]=(c[0]+f[0])*.5,o[1]=(a[1]+h[1])*.5,o[2]=(u[2]+p[2])*.5;const g=o[0]-f[0],m=o[1]-h[1],v=o[2]-p[2];return o[3]=Math.sqrt(g*g+m*m+v*v),e.set(t,o),o},Mn}var _n,M1;function Sm(){if(M1)return _n;M1=1;const i=N();return _n=r=>{let t=0;const n=r.vertices,s=i.create();for(let o=0;o<n.length-2;o++)i.cross(s,n[o+1],n[o+2]),t+=i.dot(n[0],s);return t/=6,t},_n}var Cn,_1;function Tm(){return _1||(_1=1,Cn=e=>e.vertices),Cn}var Fn,C1;function Mm(){if(C1)return Fn;C1=1;const i=N();return Fn=r=>{let t="poly3: vertices: [";return r.vertices.forEach(n=>{t+=`${i.toString(n)}, `}),t+="]",t},Fn}var Bn,F1;function _m(){if(F1)return Bn;F1=1;const i=K(),e=N(),r=le();return Bn=(n,s)=>{const o=s.vertices.map(c=>e.transform(e.create(),c,n));return i.isMirroring(n)&&o.reverse(),r(o)},Bn}var Vn,B1;function Cm(){if(B1)return Vn;B1=1;const i=O2(),{NEPS:e}=Y(),r=N(),t=N2(),n=G2(),s=D2(),o=gc();return Vn=a=>{if(!t(a))throw new Error("invalid poly3 structure");if(a.vertices.length<3)throw new Error(`poly3 not enough vertices ${a.vertices.length}`);if(s(a)<=0)throw new Error("poly3 area must be greater than zero");for(let u=0;u<a.vertices.length;u++)if(r.equals(a.vertices[u],a.vertices[(u+1)%a.vertices.length]))throw new Error(`poly3 duplicate vertex ${a.vertices[u]}`);if(!n(a))throw new Error("poly3 must be convex");if(a.vertices.forEach(u=>{if(!u.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${u}`)}),a.vertices.length>3){const u=o(a);a.vertices.forEach(f=>{const h=Math.abs(i(u,f));if(h>e)throw new Error(`poly3 must be coplanar: vertex ${f} distance ${h}`)})}},Vn}var On,V1;function X(){return V1||(V1=1,On={clone:pm(),create:le(),fromPoints:mm(),fromPointsAndPlane:vm(),invert:Rm(),isA:N2(),isConvex:G2(),measureArea:D2(),measureBoundingBox:xm(),measureBoundingSphere:$m(),measureSignedVolume:Sm(),plane:gc(),toPoints:Tm(),toString:Mm(),transform:_m(),validate:Cm()}),On}var kn,O1;function Fm(){if(O1)return kn;O1=1;const i=S2(),e=ve(),r=X();return kn=n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");const o=i(n,{skipTriangulation:!0}).map(c=>{const a=c.map(u=>n[u]);return r.create(a)});return e(o)},kn}var Nn,k1;function Bm(){if(k1)return Nn;k1=1;const i=X(),e=ve();return Nn=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");const n=t.map((o,c)=>i.create(o));return e(n)},Nn}var Gn,N1;function Vm(){if(N1)return Gn;N1=1;const i=N(),e=K(),r=X(),t=ve();return Gn=s=>{if(s[0]!==1)throw new Error("invalid compact binary data");const o=t();o.transforms=e.clone(s.slice(1,17));const c=s[21];let a=22,u=s.length-c*3;for(;u<s.length;){const f=s[a];a++;const h=[];for(let p=0;p<f;p++)h.push(i.fromValues(s[u],s[u+1],s[u+2])),u+=3;o.polygons.push(r.create(h))}return s[17]>=0&&(o.color=[s[17],s[18],s[19],s[20]]),o},Gn}var Dn,G1;function Om(){if(G1)return Dn;G1=1;const i=K(),e=X();return Dn=t=>(i.isIdentity(t.transforms)||(t.polygons=t.polygons.map(n=>e.transform(t.transforms,n)),t.transforms=i.create()),t),Dn}var zn,D1;function Me(){if(D1)return zn;D1=1;const i=Om();return zn=r=>i(r).polygons,zn}var Ln,z1;function km(){if(z1)return Ln;z1=1;const i=X(),e=ve(),r=Me();return Ln=n=>{const o=r(n).map(c=>i.invert(c));return e(o)},Ln}var In,L1;function L2(){return L1||(L1=1,In=e=>!!(e&&typeof e=="object"&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms)),In}var Hn,I1;function Nm(){if(I1)return Hn;I1=1;const i=X(),e=Me();return Hn=t=>e(t).map(o=>i.toPoints(o)),Hn}var Zn,H1;function Gm(){if(H1)return Zn;H1=1;const i=X(),e=Me();return Zn=t=>{const n=e(t);let s="geom3 ("+n.length+` polygons):
`;return n.forEach(o=>{s+="  "+i.toString(o)+`
`}),s},Zn}var Xn,Z1;function Dm(){if(Z1)return Xn;Z1=1;const i=X();return Xn=r=>{const t=r.polygons,n=r.transforms,s=t.length,o=t.reduce((h,p)=>h+p.vertices.length,0);let c=[-1,-1,-1,-1];r.color&&(c=r.color);const a=new Float32Array(22+s+o*3);a[0]=1,a[1]=n[0],a[2]=n[1],a[3]=n[2],a[4]=n[3],a[5]=n[4],a[6]=n[5],a[7]=n[6],a[8]=n[7],a[9]=n[8],a[10]=n[9],a[11]=n[10],a[12]=n[11],a[13]=n[12],a[14]=n[13],a[15]=n[14],a[16]=n[15],a[17]=c[0],a[18]=c[1],a[19]=c[2],a[20]=c[3],a[21]=o;let u=22,f=u+s;return t.forEach(h=>{const p=i.toPoints(h);a[u]=p.length,u++;for(let g=0;g<p.length;g++){const m=p[g];a[f+0]=m[0],a[f+1]=m[1],a[f+2]=m[2],f+=3}}),a},Xn}var Yn,X1;function zm(){if(X1)return Yn;X1=1;const i=K();return Yn=(r,t)=>{const n=i.multiply(i.create(),r,t.transforms);return Object.assign({},t,{transforms:n})},Yn}var Un,Y1;function Lm(){if(Y1)return Un;Y1=1;const i=X(),e=L2(),r=n=>{if(!e(n))throw new Error("invalid geom3 structure");if(n.polygons.forEach(i.validate),t(n),!n.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${n.transforms}`)},t=n=>{const s=new Map;n.polygons.forEach(({vertices:c})=>{c.forEach((a,u)=>{const f=`${a}`,h=`${c[(u+1)%c.length]}`,p=`${f}/${h}`,g=s.has(p)?s.get(p):0;s.set(p,g+1)})});const o=[];if(s.forEach((c,a)=>{const u=a.split("/").reverse().join("/"),f=s.get(u);c!==f&&o.push(a.replace("/"," -> "))}),o.length>0)throw new Error(`non-manifold edges ${o.length}
${o.join(`
`)}`)};return Un=r,Un}var Wn,U1;function L(){return U1||(U1=1,Wn={clone:am(),create:ve(),fromPointsConvex:Fm(),fromPoints:Bm(),fromCompactBinary:Vm(),invert:km(),isA:L2(),toPoints:Nm(),toPolygons:Me(),toString:Gm(),toCompactBinary:Dm(),transform:zm(),validate:Lm()}),Wn}var Qn,W1;function pc(){return W1||(W1=1,Qn=e=>Object.assign({},e)),Qn}var Kn,Q1;function I2(){if(Q1)return Kn;Q1=1;const{EPS:i}=Y(),e=I(),r=pc();return Kn=n=>{if(n.isClosed)return n;const s=r(n);if(s.isClosed=!0,s.points.length>1){const o=s.points,c=o[0];let a=o[o.length-1];for(;e.distance(c,a)<i*i&&(o.pop(),o.length!==1);)a=o[o.length-1]}return s},Kn}var Jn,K1;function _e(){if(K1)return Jn;K1=1;const i=K();return Jn=r=>(r===void 0&&(r=[]),{points:r,isClosed:!1,transforms:i.create()}),Jn}var jn,J1;function mc(){if(J1)return jn;J1=1;const{EPS:i}=Y(),e=I(),r=I2(),t=_e();return jn=(s,o)=>{const c={closed:!1};let{closed:a}=Object.assign({},c,s),u=t();if(u.points=o.map(f=>e.clone(f)),u.points.length>1){const f=u.points[0],h=u.points[u.points.length-1];e.distance(f,h)<i*i&&(a=!0)}return a===!0&&(u=r(u)),u},jn}var es,j1;function Im(){if(j1)return es;j1=1;const i=K(),e=I();return es=t=>(i.isIdentity(t.transforms)||(t.points=t.points.map(n=>e.transform(e.create(),n,t.transforms)),t.transforms=i.create()),t),es}var ts,ef;function fe(){if(ef)return ts;ef=1;const i=Im();return ts=r=>i(r).points,ts}var rs,tf;function Hm(){if(tf)return rs;tf=1;const{TAU:i}=Y(),e=I(),r=mc(),t=fe();return rs=(s,o)=>{const c={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:a,radius:u,xaxisrotation:f,clockwise:h,large:p,segments:g}=Object.assign({},c,s);if(!Array.isArray(a))throw new Error("endpoint must be an array of X and Y values");if(a.length<2)throw new Error("endpoint must contain X and Y values");if(a=e.clone(a),!Array.isArray(u))throw new Error("radius must be an array of X and Y values");if(u.length<2)throw new Error("radius must contain X and Y values");if(g<4)throw new Error("segments must be four or more");const m=1e5;if(o.isClosed)throw new Error("the given path cannot be closed");const v=t(o);if(v.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let l=u[0],d=u[1];const q=v[v.length-1];l=Math.round(l*m)/m,d=Math.round(d*m)/m,a=e.fromValues(Math.round(a[0]*m)/m,Math.round(a[1]*m)/m);const y=!h;let P=[];if(l===0||d===0)P.push(a);else{l=Math.abs(l),d=Math.abs(d);const R=f,x=Math.cos(R),E=Math.sin(R),A=e.subtract(e.create(),q,a);e.scale(A,A,.5);const _=Math.round((x*A[0]+E*A[1])*m)/m,S=Math.round((-E*A[0]+x*A[1])*m)/m,b=e.fromValues(_,S),T=b[0]*b[0]/(l*l)+b[1]*b[1]/(d*d);if(T>1){const Z=Math.sqrt(T);l*=Z,d*=Z,l=Math.round(l*m)/m,d=Math.round(d*m)/m}let M=Math.sqrt((l*l*d*d-l*l*b[1]*b[1]-d*d*b[0]*b[0])/(l*l*b[1]*b[1]+d*d*b[0]*b[0]));y===p&&(M=-M);const $=e.fromValues(l*b[1]/d,-d*b[0]/l);e.scale($,$,M);let C=e.fromValues(x*$[0]-E*$[1],E*$[0]+x*$[1]);C=e.add(C,C,e.scale(e.create(),e.add(e.create(),q,a),.5));const F=e.fromValues((b[0]-$[0])/l,(b[1]-$[1])/d),B=e.fromValues((-b[0]-$[0])/l,(-b[1]-$[1])/d),O=e.angleRadians(F);let k=e.angleRadians(B)-O;k=k%i,!y&&k>0?k-=i:y&&k<0&&(k+=i);let G=Math.ceil(Math.abs(k)/i*g)+1;G<1&&(G=1);for(let Z=1;Z<G;Z++){const U=O+Z/G*k,J=Math.cos(U),W=Math.sin(U),H=e.fromValues(x*l*J-E*d*W,E*l*J+x*d*W);e.add(H,H,C),P.push(H)}G&&P.push(s.endpoint)}return P=v.concat(P),r({},P)},rs}var ns,rf;function H2(){if(rf)return ns;rf=1;const i=mc(),e=fe(),{equals:r}=I();return ns=(...n)=>{let s=!1,o=[];return n.forEach((c,a)=>{const u=e(c).slice();if(o.length>0&&u.length>0&&r(u[0],o[o.length-1])&&u.shift(),u.length>0&&s)throw new Error(`Cannot concatenate to a closed path; check the ${a}th path`);s=c.isClosed,o=o.concat(u)}),i({closed:s},o)},ns}var ss,nf;function Z2(){if(nf)return ss;nf=1;const i=H2(),e=_e();return ss=(t,n)=>i(n,e(t)),ss}var os,sf;function Zm(){if(sf)return os;sf=1;const{TAU:i}=Y(),e=I(),r=I(),t=Z2(),n=fe();return os=(o,c)=>{const a={segments:16};let{controlPoints:u,segments:f}=Object.assign({},a,o);if(!Array.isArray(u))throw new Error("controlPoints must be an array of one or more points");if(u.length<1)throw new Error("controlPoints must be an array of one or more points");if(f<4)throw new Error("segments must be four or more");if(c.isClosed)throw new Error("the given geometry cannot be closed");const h=n(c);if(h.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(u=u.slice(),u[0]===null){if(u.length<2)throw new Error("a null control point must be passed with one more control points");let b=h[h.length-2];if("lastBezierControlPoint"in c&&(b=c.lastBezierControlPoint),!Array.isArray(b))throw new Error("the given path must contain TWO or more points if given a null control point");const T=e.scale(e.create(),h[h.length-1],2);e.subtract(T,T,b),u[0]=T}u.unshift(h[h.length-1]);const g=u.length-1,m=[];let v=1;for(let b=0;b<=g;++b)b>0&&(v*=b),m.push(v);const l=[];for(let b=0;b<=g;++b){const T=m[g]/(m[b]*m[g-b]);l.push(T)}const d=e.create(),q=e.create(),y=r.create(),P=b=>{let T=1,M=Math.pow(1-b,g);const $=b!==1?1/(1-b):1,C=e.create();for(let F=0;F<=g;++F){F===g&&(M=1);const B=l[F]*T*M,O=e.scale(d,u[F],B);e.add(C,C,O),T*=b,M*=$}return C},w=[],R=[],x=g+1;for(let b=0;b<x;++b){const T=b/(x-1),M=P(T);w.push(M),R.push(T)}let E=1;const A=i/f,_=Math.sin(A);for(;E<w.length-1;){const b=e.subtract(d,w[E],w[E-1]);e.normalize(b,b);const T=e.subtract(q,w[E+1],w[E]);e.normalize(T,T);const M=e.cross(y,b,T);if(Math.abs(M[2])>_){const $=R[E-1],C=R[E+1],F=$+(C-$)*1/3,B=$+(C-$)*2/3,O=P(F),V=P(B);w.splice(E,1,O,V),R.splice(E,1,F,B),E--,E<1&&(E=1)}else++E}w.shift();const S=t(w,c);return S.lastBezierControlPoint=u[u.length-2],S},os}var is,of;function Xm(){if(of)return is;of=1;const i=I(),e=fe();return is=(t,n)=>{if(t.isClosed!==n.isClosed||t.points.length!==n.points.length)return!1;const s=e(t),o=e(n),c=s.length;let a=0;do{let u=!1;for(let f=0;f<c;f++)if(!i.equals(s[f],o[(f+a)%c])){u=!0;break}if(u===!1)return!0;if(!t.isClosed)return!1}while(++a<c);return!1},is}var as,af;function Ym(){if(af)return as;af=1;const i=K(),e=I(),r=_e();return as=n=>{if(n[0]!==2)throw new Error("invalid compact binary data");const s=r();s.transforms=i.clone(n.slice(1,17)),s.isClosed=!!n[17];for(let o=22;o<n.length;o+=2){const c=e.fromValues(n[o],n[o+1]);s.points.push(c)}return n[18]>=0&&(s.color=[n[18],n[19],n[20],n[21]]),s},as}var cs,cf;function X2(){return cf||(cf=1,cs=e=>!!(e&&typeof e=="object"&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms)),cs}var us,uf;function Um(){if(uf)return us;uf=1;const i=pc();return us=r=>{const t=i(r);return t.points=r.points.slice().reverse(),t},us}var ls,lf;function Wm(){if(lf)return ls;lf=1;const i=I(),e=fe();return ls=t=>{const n=e(t);let s="path ("+n.length+" points, "+t.isClosed+`):
[
`;return n.forEach(o=>{s+="  "+i.toString(o)+`,
`}),s+=`]
`,s},ls}var fs,ff;function Qm(){return ff||(ff=1,fs=e=>{const r=e.points,t=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(22+r.length*2);s[0]=2,s[1]=t[0],s[2]=t[1],s[3]=t[2],s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=t[6],s[8]=t[7],s[9]=t[8],s[10]=t[9],s[11]=t[10],s[12]=t[11],s[13]=t[12],s[14]=t[13],s[15]=t[14],s[16]=t[15],s[17]=e.isClosed?1:0,s[18]=n[0],s[19]=n[1],s[20]=n[2],s[21]=n[3];for(let o=0;o<r.length;o++){const c=o*2+22,a=r[o];s[c]=a[0],s[c+1]=a[1]}return s}),fs}var hs,hf;function Km(){if(hf)return hs;hf=1;const i=K();return hs=(r,t)=>{const n=i.multiply(i.create(),r,t.transforms);return Object.assign({},t,{transforms:n})},hs}var ds,df;function Jm(){if(df)return ds;df=1;const i=I(),e=X2();return ds=t=>{if(!e(t))throw new Error("invalid path2 structure");if(t.points.length>1){for(let n=0;n<t.points.length;n++)if(i.equals(t.points[n],t.points[(n+1)%t.points.length]))throw new Error(`path2 duplicate points ${t.points[n]}`)}if(t.points.forEach(n=>{if(!n.every(Number.isFinite))throw new Error(`path2 invalid point ${n}`)}),!t.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${t.transforms}`)},ds}var gs,gf;function Q(){return gf||(gf=1,gs={appendArc:Hm(),appendBezier:Zm(),appendPoints:Z2(),clone:pc(),close:I2(),concat:H2(),create:_e(),equals:Xm(),fromPoints:mc(),fromCompactBinary:Ym(),isA:X2(),reverse:Um(),toPoints:fe(),toString:Wm(),toCompactBinary:Qm(),transform:Km(),validate:Jm()}),gs}var ps,pf;function jm(){if(pf)return ps;pf=1;const i=D(),e=z(),r=L(),t=Q(),n=X(),s=(f,h)=>{const p=e.clone(h);return p.color=f,p},o=(f,h)=>{const p=r.clone(h);return p.color=f,p},c=(f,h)=>{const p=t.clone(h);return p.color=f,p},a=(f,h)=>{const p=n.clone(h);return p.color=f,p};return ps=(f,...h)=>{if(!Array.isArray(f))throw new Error("color must be an array");if(f.length<3)throw new Error("color must contain R, G and B values");if(f.length===3&&(f=[f[0],f[1],f[2],1]),h=i(h),h.length===0)throw new Error("wrong number of arguments");const p=h.map(g=>e.isA(g)?s(f,g):r.isA(g)?o(f,g):t.isA(g)?c(f,g):n.isA(g)?a(f,g):(g.color=f,g));return p.length===1?p[0]:p},ps}var ms,mf;function Y2(){return mf||(mf=1,ms={black:[0/255,0/255,0/255],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[255/255,255/255,255/255],maroon:[128/255,0/255,0/255],red:[255/255,0/255,0/255],purple:[128/255,0/255,128/255],fuchsia:[255/255,0/255,255/255],green:[0/255,128/255,0/255],lime:[0/255,255/255,0/255],olive:[128/255,128/255,0/255],yellow:[255/255,255/255,0/255],navy:[0/255,0/255,128/255],blue:[0/255,0/255,255/255],teal:[0/255,128/255,128/255],aqua:[0/255,255/255,255/255],aliceblue:[240/255,248/255,255/255],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,255/255,212/255],azure:[240/255,255/255,255/255],beige:[245/255,245/255,220/255],bisque:[255/255,228/255,196/255],blanchedalmond:[255/255,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,255/255,0/255],chocolate:[210/255,105/255,30/255],coral:[255/255,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[255/255,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0/255,255/255,255/255],darkblue:[0/255,0/255,139/255],darkcyan:[0/255,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0/255,100/255,0/255],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0/255,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[255/255,140/255,0/255],darkorchid:[153/255,50/255,204/255],darkred:[139/255,0/255,0/255],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0/255,206/255,209/255],darkviolet:[148/255,0/255,211/255],deeppink:[255/255,20/255,147/255],deepskyblue:[0/255,191/255,255/255],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,255/255],firebrick:[178/255,34/255,34/255],floralwhite:[255/255,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,255/255],gold:[255/255,215/255,0/255],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,255/255,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,255/255,240/255],hotpink:[255/255,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0/255,130/255],ivory:[255/255,255/255,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[255/255,240/255,245/255],lawngreen:[124/255,252/255,0/255],lemonchiffon:[255/255,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,255/255,255/255],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[255/255,182/255,193/255],lightsalmon:[255/255,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,153/255],lightslategrey:[119/255,136/255,153/255],lightsteelblue:[176/255,196/255,222/255],lightyellow:[255/255,255/255,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[255/255,0/255,255/255],mediumaquamarine:[102/255,205/255,170/255],mediumblue:[0/255,0/255,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0/255,250/255,154/255],mediumturquoise:[72/255,209/255,204/255],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,255/255,250/255],mistyrose:[255/255,228/255,225/255],moccasin:[255/255,228/255,181/255],navajowhite:[255/255,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[255/255,165/255,0/255],orangered:[255/255,69/255,0/255],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[255/255,239/255,213/255],peachpuff:[255/255,218/255,185/255],peru:[205/255,133/255,63/255],pink:[255/255,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[255/255,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[255/255,250/255,250/255],springgreen:[0/255,255/255,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[255/255,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]}),ms}var vs,vf;function ev(){if(vf)return vs;vf=1;const i=Y2();return vs=r=>i[r.toLowerCase()],vs}var qs,qf;function tv(){return qf||(qf=1,qs=e=>{if(e=e.replace("#",""),e.length<6)throw new Error("the given notation must contain 3 or more hex values");const r=parseInt(e.substring(0,2),16)/255,t=parseInt(e.substring(2,4),16)/255,n=parseInt(e.substring(4,6),16)/255;if(e.length>=8){const s=parseInt(e.substring(6,8),16)/255;return[r,t,n,s]}return[r,t,n]}),qs}var ys,yf;function U2(){return yf||(yf=1,ys=(e,r,t)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+(r-e)*6*t:t<1/2?r:t<2/3?e+(r-e)*(2/3-t)*6:e)),ys}var ws,wf;function rv(){if(wf)return ws;wf=1;const i=D(),e=U2();return ws=(...t)=>{if(t=i(t),t.length<3)throw new Error("values must contain H, S and L values");const n=t[0],s=t[1],o=t[2];let c=o,a=o,u=o;if(s!==0){const f=o<.5?o*(1+s):o+s-o*s,h=2*o-f;c=e(h,f,n+1/3),a=e(h,f,n),u=e(h,f,n-1/3)}if(t.length>3){const f=t[3];return[c,a,u,f]}return[c,a,u]},ws}var Ps,Pf;function nv(){if(Pf)return Ps;Pf=1;const i=D();return Ps=(...r)=>{if(r=i(r),r.length<3)throw new Error("values must contain H, S and V values");const t=r[0],n=r[1],s=r[2];let o=0,c=0,a=0;const u=Math.floor(t*6),f=t*6-u,h=s*(1-n),p=s*(1-f*n),g=s*(1-(1-f)*n);switch(u%6){case 0:o=s,c=g,a=h;break;case 1:o=p,c=s,a=h;break;case 2:o=h,c=s,a=g;break;case 3:o=h,c=p,a=s;break;case 4:o=g,c=h,a=s;break;case 5:o=s,c=h,a=p;break}if(r.length>3){const m=r[3];return[o,c,a,m]}return[o,c,a]},Ps}var Rs,Rf;function sv(){if(Rf)return Rs;Rf=1;const i=D();return Rs=(...r)=>{if(r=i(r),r.length<3)throw new Error("values must contain R, G and B values");const t=r[0]*255,n=r[1]*255,s=r[2]*255;let o=`#${Number(16777216+t*65536+n*256+s).toString(16).substring(1,7)}`;return r.length>3&&(o=o+Number(r[3]*255).toString(16)),o},Rs}var xs,xf;function ov(){if(xf)return xs;xf=1;const i=D();return xs=(...r)=>{if(r=i(r),r.length<3)throw new Error("values must contain R, G and B values");const t=r[0],n=r[1],s=r[2],o=Math.max(t,n,s),c=Math.min(t,n,s);let a,u;const f=(o+c)/2;if(o===c)a=u=0;else{const h=o-c;switch(u=f>.5?h/(2-o-c):h/(o+c),o){case t:a=(n-s)/h+(n<s?6:0);break;case n:a=(s-t)/h+2;break;case s:a=(t-n)/h+4;break}a/=6}if(r.length>3){const h=r[3];return[a,u,f,h]}return[a,u,f]},xs}var Es,Ef;function iv(){if(Ef)return Es;Ef=1;const i=D();return Es=(...r)=>{if(r=i(r),r.length<3)throw new Error("values must contain R, G and B values");const t=r[0],n=r[1],s=r[2],o=Math.max(t,n,s),c=Math.min(t,n,s);let a;const u=o,f=o-c,h=o===0?0:f/o;if(o===c)a=0;else{switch(o){case t:a=(n-s)/f+(n<s?6:0);break;case n:a=(s-t)/f+2;break;case s:a=(t-n)/f+4;break}a/=6}if(r.length>3){const p=r[3];return[a,h,u,p]}return[a,h,u]},Es}var As,Af;function av(){return Af||(Af=1,As={colorize:jm(),colorNameToRgb:ev(),cssColors:Y2(),hexToRgb:tv(),hslToRgb:rv(),hsvToRgb:nv(),hueToColorComponent:U2(),rgbToHex:sv(),rgbToHsl:ov(),rgbToHsv:iv()}),As}var bs,bf;function cv(){if(bf)return bs;bf=1;const i=n=>{if(!Array.isArray(n))throw new Error("Bezier points must be a valid array/");if(n.length<2)throw new Error("Bezier points must contain at least 2 values.");const s=e(n);return{points:n,pointType:s,dimensions:s==="float_single"?0:n[0].length,permutations:r(n.length-1),tangentPermutations:r(n.length-2)}},e=function(n){let s=null;return n.forEach(o=>{let c="";if(Number.isFinite(o))c="float_single";else if(Array.isArray(o))o.forEach(a=>{if(!Number.isFinite(a))throw new Error("Bezier point values must all be numbers.")}),c="float_"+o.length;else throw new Error("Bezier points must all be numbers or arrays of number.");if(s==null)s=c;else if(s!==c)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")}),s},r=function(n){const s=[];for(let o=0;o<=n;o++)s.push(t(n)/(t(o)*t(n-o)));return s},t=function(n){let s=1;for(let o=2;o<=n;o++)s*=o;return s};return bs=i,bs}var $s,$f;function W2(){if($f)return $s;$f=1;const i=(r,t)=>{if(r<0||r>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if(t.pointType==="float_single")return e(t,t.points,r);{const n=[];for(let s=0;s<t.dimensions;s++){const o=[];for(let c=0;c<t.points.length;c++)o.push(t.points[c][s]);n.push(e(t,o,r))}return n}},e=function(r,t,n){const s=t.length-1;let o=0;for(let c=0;c<=s;c++)o+=r.permutations[c]*Math.pow(1-n,s-c)*Math.pow(n,c)*t[c];return o};return $s=i,$s}var Ss,Sf;function uv(){if(Sf)return Ss;Sf=1;const i=(r,t)=>{if(r<0||r>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if(t.pointType==="float_single")return e(t,t.points,r);{const n=[];for(let s=0;s<t.dimensions;s++){const o=[];for(let c=0;c<t.points.length;c++)o.push(t.points[c][s]);n.push(e(t,o,r))}return n}},e=function(r,t,n){const s=t.length-1;let o=0;for(let c=0;c<s;c++){const a=s*(t[c+1]-t[c]);o+=r.tangentPermutations[c]*Math.pow(1-n,s-1-c)*Math.pow(n,c)*a}return o};return Ss=i,Ss}var Ts,Tf;function vc(){if(Tf)return Ts;Tf=1;const i=W2(),e=(t,n)=>{let s=0;const o=[0];let c=i(0,n);for(let a=1;a<=t;a++){const u=i(a/t,n);s+=r(u,c),o.push(s),c=u}return o},r=(t,n)=>{if(Number.isFinite(t)&&Number.isFinite(n))return Math.abs(t-n);if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)throw new Error("The operands must have the same number of dimensions.");let s=0;for(let o=0;o<t.length;o++)s+=(n[o]-t[o])*(n[o]-t[o]);return Math.sqrt(s)}else throw new Error("The operands must be of the same type, either number or array.")};return Ts=e,Ts}var Ms,Mf;function lv(){if(Mf)return Ms;Mf=1;const i=vc();return Ms=(r,t)=>i(r,t)[r],Ms}var _s,_f;function fv(){if(_f)return _s;_f=1;const i=vc();return _s=(r,t)=>{const n={distance:0,segments:100},{distance:s,segments:o}=Object.assign({},n,r),c=i(o,t);let a=0,u=o;for(;a<=u;){const v=Math.floor(a+(u-a)/2),l=c[v]-s;if(l<0)a=v+1;else if(l>0)u=v-1;else{u=v;break}}const f=u;if(c[f]===s)return f/o;const h=c[f],g=c[f+1]-h,m=(s-h)/g;return(f+m)/o},_s}var Cs,Cf;function hv(){return Cf||(Cf=1,Cs={create:cv(),valueAt:W2(),tangentAt:uv(),lengths:vc(),length:lv(),arcLengthToT:fv()}),Cs}var Fs,Ff;function dv(){return Ff||(Ff=1,Fs={bezier:hv()}),Fs}var Bs,Bf;function Ce(){return Bf||(Bf=1,Bs=e=>{let r=0;for(let t=0;t<e.length;t++){const n=(t+1)%e.length;r+=e[t][0]*e[n][1],r-=e[n][0]*e[t][1]}return r/2}),Bs}var Vs,Vf;function Q2(){if(Vf)return Vs;Vf=1;const i=Ce();return Vs=r=>i(r.vertices),Vs}var Os,Of;function K2(){return Of||(Of=1,Os=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e})),Os}var ks,kf;function J2(){if(kf)return ks;kf=1;const i=K2();return ks=r=>{const t=r.vertices.slice().reverse();return i(t)},ks}var Ns,Nf;function gv(){if(Nf)return Ns;Nf=1;const i=Q2(),e=J2(),r=(n,s)=>{if(n.length===0)return 0;const o=s.vertices;return o.length<3?0:(i(s)<0&&(s=e(s)),n.reduce((a,u)=>a+t(u,o),0)===n.length?1:0)},t=(n,s)=>{const o=s.length,c=n[0],a=n[1];let u=s[o-1],f=s[0],h=u[1]>a,p=0,g=0;for(let m=o+1;--m;){const v=f[1]>a;if(h!==v){const l=u[0]>c,d=f[0]>c;(l&&d||f[0]-(f[1]-a)*(u[0]-f[0])/(u[1]-f[1])>=c)&&(p=!p)}h=v,u=f,f=s[++g]}return p};return Ns=r,Ns}var Gs,Gf;function qc(){return Gf||(Gf=1,Gs={arePointsInside:gv(),create:K2(),flip:J2(),measureArea:Q2()}),Gs}var Ds,Df;function yc(){return Df||(Df=1,Ds={geom2:z(),geom3:L(),path2:Q(),poly2:qc(),poly3:X()}),Ds}var zs,zf;function wc(){return zf||(zf=1,zs=()=>[0,1,0]),zs}var Ls,Lf;function pv(){if(Lf)return Ls;Lf=1;const i=wc();return Ls=r=>{const t=i();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t},Ls}var Is,If;function Pc(){if(If)return Is;If=1;const i=I();return Is=r=>{const t=i.normal(i.create(),r);return i.negate(t,t),t},Is}var Hs,Hf;function Fe(){if(Hf)return Hs;Hf=1;const i=I();return Hs=r=>i.scale(i.create(),r,r[2]),Hs}var Zs,Zf;function mv(){if(Zf)return Zs;Zf=1;const i=I(),e=Pc(),r=Fe();return Zs=(n,s)=>{const o=r(n),c=e(n),a=i.subtract(i.create(),s,o),u=i.dot(a,c);return i.scale(a,c,u),i.add(a,a,o),a},Zs}var Xs,Xf;function j2(){return Xf||(Xf=1,Xs=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e)),Xs}var Ys,Yf;function vv(){if(Yf)return Ys;Yf=1;const i=I();return Ys=(r,t)=>{let n=i.dot(t,r);return n=Math.abs(n-r[2]),n},Ys}var Us,Uf;function qv(){return Uf||(Uf=1,Us=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]),Us}var Ws,Wf;function eg(){if(Wf)return Ws;Wf=1;const i=I();return Ws=(r,t,n)=>{const s=i.subtract(i.create(),n,t);i.normal(s,s),i.normalize(s,s);const o=i.dot(t,s);return r[0]=s[0],r[1]=s[1],r[2]=o,r},Ws}var Qs,Qf;function tg(){if(Qf)return Qs;Qf=1;const i=wc();return Qs=(r,t,n)=>{const s=i();return s[0]=r,s[1]=t,s[2]=n,s},Qs}var Ks,Kf;function Rc(){if(Kf)return Ks;Kf=1;const{NEPS:i}=Y();return Ks=(r,t)=>Math.abs(r[0]-t[0])<=i&&Math.abs(r[1]-t[1])<=i&&Math.abs(r[2]-t[2])<=i,Ks}var Js,Jf;function rg(){return Jf||(Jf=1,Js=(e,r,t)=>{let n=t-e[1],s=r[1]-e[1];s<0&&(n=-n,s=-s);let o;return n<=0?o=0:n>=s?o=1:s<1e-10?o=.5:o=n/s,e[0]+o*(r[0]-e[0])}),Js}var js,jf;function ng(){return jf||(jf=1,js=(e,r,t,n)=>{if(e[0]===r[0]&&e[1]===r[1]||t[0]===n[0]&&t[1]===n[1])return;const s=(n[1]-t[1])*(r[0]-e[0])-(n[0]-t[0])*(r[1]-e[1]);if(Math.abs(s)<Number.MIN_VALUE)return;const o=((n[0]-t[0])*(e[1]-t[1])-(n[1]-t[1])*(e[0]-t[0]))/s,c=((r[0]-e[0])*(e[1]-t[1])-(r[1]-e[1])*(e[0]-t[0]))/s;if(o<0||o>1||c<0||c>1)return;const a=e[0]+o*(r[0]-e[0]),u=e[1]+o*(r[1]-e[1]);return[a,u]}),js}var eo,eh;function yv(){return eh||(eh=1,eo=(e,r,t,n,s,o)=>{const a=1/(e*n-r*t);let u=s*n-r*o,f=-s*t+e*o;return u*=a,f*=a,[u,f]}),eo}var to,th;function qe(){return th||(th=1,to={aboutEqualNormals:Rc(),area:Ce(),cos:ee().cos,interpolateBetween2DPointsForY:rg(),intersect:ng(),sin:ee().sin,solve2Linear:yv()}),to}var ro,rh;function wv(){if(rh)return ro;rh=1;const i=I(),{solve2Linear:e}=qe();return ro=(t,n)=>{const s=e(t[0],t[1],n[0],n[1],t[2],n[2]);return i.clone(s)},ro}var no,nh;function Pv(){if(nh)return no;nh=1;const i=I(),e=j2(),r=tg();return no=(n,s)=>{const o=i.negate(i.create(),s),c=-s[2];return e(n,r(o[0],o[1],c))},no}var so,sh;function Rv(){return sh||(sh=1,so=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`),so}var oo,oh;function xv(){if(oh)return oo;oh=1;const i=I(),e=eg(),r=Fe(),t=Pc();return oo=(s,o,c)=>{const a=r(o),u=t(o);return i.transform(a,a,c),i.transform(u,u,c),e(s,a,u)},oo}var io,ih;function Ev(){if(ih)return io;ih=1;const i=Fe();return io=(r,t)=>{let n=(r[2]-r[1]*t)/r[0];return Number.isNaN(n)&&(n=i(r)[0]),n},io}var ao,ah;function xc(){return ah||(ah=1,ao={clone:pv(),closestPoint:mv(),copy:j2(),create:wc(),direction:Pc(),distanceToPoint:vv(),equals:qv(),fromPoints:eg(),fromValues:tg(),intersectPointOfLines:wv(),origin:Fe(),reverse:Pv(),toString:Rv(),transform:xv(),xAtY:Ev()}),ao}var co,ch;function sg(){if(ch)return co;ch=1;const i=N();return co=()=>[i.fromValues(0,0,0),i.fromValues(0,0,1)],co}var uo,uh;function Av(){if(uh)return uo;uh=1;const i=N(),e=sg();return uo=t=>{const n=e();return i.copy(n[0],t[0]),i.copy(n[1],t[1]),n},uo}var lo,lh;function og(){if(lh)return lo;lh=1;const i=N();return lo=(r,t)=>{const n=r[0],s=r[1],o=i.dot(i.subtract(i.create(),t,n),s),c=i.dot(s,s),a=o/c,u=i.scale(i.create(),s,a);return i.add(u,u,n),u},lo}var fo,fh;function bv(){if(fh)return fo;fh=1;const i=N();return fo=(r,t)=>(i.copy(r[0],t[0]),i.copy(r[1],t[1]),r),fo}var ho,hh;function $v(){return hh||(hh=1,ho=e=>e[1]),ho}var go,dh;function Sv(){if(dh)return go;dh=1;const i=N(),e=og();return go=(t,n)=>{const s=e(t,n),o=i.subtract(i.create(),n,s);return i.length(o)},go}var po,gh;function Tv(){if(gh)return po;gh=1;const i=N();return po=(r,t)=>!(!i.equals(r[1],t[1])||!i.equals(r[0],t[0])),po}var mo,ph;function ye(){if(ph)return mo;ph=1;const i=N();return mo=(r,t,n)=>{const s=i.normalize(i.create(),n);return i.copy(r[0],t),i.copy(r[1],s),r},mo}var vo,mh;function Mv(){if(mh)return vo;mh=1;const i=N(),{solve2Linear:e}=qe(),{EPS:r}=Y(),t=ye();return vo=(s,o,c)=>{let a=i.cross(i.create(),o,c),u=i.length(a);if(u<r)throw new Error("parallel planes do not intersect");u=1/u,a=i.scale(a,a,u);const f=Math.abs(a[0]),h=Math.abs(a[1]),p=Math.abs(a[2]);let g,m;return f>=h&&f>=p?(m=e(o[1],o[2],c[1],c[2],o[3],c[3]),g=i.fromValues(0,m[0],m[1])):h>=f&&h>=p?(m=e(o[0],o[2],c[0],c[2],o[3],c[3]),g=i.fromValues(m[0],0,m[1])):(m=e(o[0],o[1],c[0],c[1],o[3],c[3]),g=i.fromValues(m[0],m[1],0)),t(s,g,a)},vo}var qo,vh;function _v(){if(vh)return qo;vh=1;const i=N(),e=ye();return qo=(t,n,s)=>{const o=i.subtract(i.create(),s,n);return e(t,n,o)},qo}var yo,qh;function Cv(){if(qh)return yo;qh=1;const i=N();return yo=(r,t)=>{const n=t,s=t[3],o=r[0],c=r[1],a=(s-i.dot(n,o))/i.dot(n,c);return i.add(i.create(),o,i.scale(i.create(),c,a))},yo}var wo,yh;function Fv(){return yh||(yh=1,wo=e=>e[0]),wo}var Po,wh;function Bv(){if(wh)return Po;wh=1;const i=N(),e=ye();return Po=(t,n)=>{const s=i.clone(n[0]),o=i.negate(i.create(),n[1]);return e(t,s,o)},Po}var Ro,Ph;function Vv(){return Ph||(Ph=1,Ro=e=>{const r=e[0],t=e[1];return`line3: point: (${r[0].toFixed(7)}, ${r[1].toFixed(7)}, ${r[2].toFixed(7)}) direction: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)})`}),Ro}var xo,Rh;function Ov(){if(Rh)return xo;Rh=1;const i=N(),e=ye();return xo=(t,n,s)=>{const o=n[0],c=n[1],a=i.add(i.create(),o,c),u=i.transform(i.create(),o,s),f=i.transform(a,a,s),h=i.subtract(f,f,u);return e(t,u,h)},xo}var Eo,xh;function kv(){return xh||(xh=1,Eo={clone:Av(),closestPoint:og(),copy:bv(),create:sg(),direction:$v(),distanceToPoint:Sv(),equals:Tv(),fromPlanes:Mv(),fromPointAndDirection:ye(),fromPoints:_v(),intersectPointOfLineAndPlane:Cv(),origin:Fv(),reverse:Bv(),toString:Vv(),transform:Ov()}),Eo}var Ao,Eh;function Nv(){return Eh||(Eh=1,Ao={constants:Y(),line2:xc(),line3:kv(),mat4:K(),plane:re(),utils:qe(),vec2:I(),vec3:N(),vec4:z2()}),Ao}var bo,Ah;function ig(){if(Ah)return bo;Ah=1;const i=D(),e=z(),r=L(),t=Q(),n=X(),s=new WeakMap,o=()=>0,c=f=>{let h=s.get(f);return h||(h=e.toSides(f).reduce((g,m)=>g+(m[0][0]*m[1][1]-m[0][1]*m[1][0]),0),h*=.5,s.set(f,h),h)},a=f=>{let h=s.get(f);return h||(h=r.toPolygons(f).reduce((g,m)=>g+n.measureArea(m),0),s.set(f,h),h)};return bo=(...f)=>{if(f=i(f),f.length===0)throw new Error("wrong number of arguments");const h=f.map(p=>t.isA(p)?o():e.isA(p)?c(p):r.isA(p)?a(p):0);return h.length===1?h[0]:h},bo}var $o,bh;function Gv(){if(bh)return $o;bh=1;const i=D(),e=ig();return $o=(...t)=>{if(t=i(t),t.length===0)throw new Error("measureAggregateArea: no geometries supplied");const n=e(t);return t.length===1?n:n.reduce((o,c)=>o+c,0)},$o}var So,$h;function ce(){if($h)return So;$h=1;const i=D(),e=I(),r=N(),t=z(),n=L(),s=Q(),o=X(),c=new WeakMap,a=p=>{let g=c.get(p);if(g)return g;const m=s.toPoints(p);let v;m.length===0?v=e.create():v=e.clone(m[0]);let l=e.clone(v);return m.forEach(d=>{e.min(v,v,d),e.max(l,l,d)}),v=[v[0],v[1],0],l=[l[0],l[1],0],g=[v,l],c.set(p,g),g},u=p=>{let g=c.get(p);if(g)return g;const m=t.toPoints(p);let v;m.length===0?v=e.create():v=e.clone(m[0]);let l=e.clone(v);return m.forEach(d=>{e.min(v,v,d),e.max(l,l,d)}),v=[v[0],v[1],0],l=[l[0],l[1],0],g=[v,l],c.set(p,g),g},f=p=>{let g=c.get(p);if(g)return g;const m=n.toPolygons(p);let v=r.create();if(m.length>0){const d=o.toPoints(m[0]);r.copy(v,d[0])}let l=r.clone(v);return m.forEach(d=>{o.toPoints(d).forEach(q=>{r.min(v,v,q),r.max(l,l,q)})}),v=[v[0],v[1],v[2]],l=[l[0],l[1],l[2]],g=[v,l],c.set(p,g),g};return So=(...p)=>{if(p=i(p),p.length===0)throw new Error("wrong number of arguments");const g=p.map(m=>s.isA(m)?a(m):t.isA(m)?u(m):n.isA(m)?f(m):[[0,0,0],[0,0,0]]);return g.length===1?g[0]:g},So}var To,Sh;function Ec(){if(Sh)return To;Sh=1;const i=D(),e=y2(),r=q2(),t=ce();return To=(...s)=>{if(s=i(s),s.length===0)throw new Error("measureAggregateBoundingBox: no geometries supplied");const o=t(s);if(s.length===1)return o;const c=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return o.reduce((a,u)=>(a=[e(a[0],a[0],u[0]),r(a[1],a[1],u[1])],a),c)},To}var Mo,Th;function ag(){if(Th)return Mo;Th=1;const{EPS:i}=Y();return Mo=(r,t)=>{let n=0;for(let s=0;s<t;s++)n+=r[1][s]-r[0][s];return i*n/t},Mo}var _o,Mh;function Dv(){if(Mh)return _o;Mh=1;const i=D(),e=Ec(),r=ag(),{geom2:t,geom3:n,path2:s}=yc();return _o=(...c)=>{if(c=i(c),c.length===0)throw new Error("measureAggregateEpsilon: no geometries supplied");const a=e(c);let u=0;return u=c.reduce((f,h)=>s.isA(h)||t.isA(h)?Math.max(f,2):n.isA(h)?Math.max(f,3):0,u),r(a,u)},_o}var Co,_h;function cg(){if(_h)return Co;_h=1;const i=D(),e=z(),r=L(),t=Q(),n=X(),s=new WeakMap,o=()=>0,c=()=>0,a=f=>{let h=s.get(f);return h||(h=r.toPolygons(f).reduce((g,m)=>g+n.measureSignedVolume(m),0),s.set(f,h),h)};return Co=(...f)=>{if(f=i(f),f.length===0)throw new Error("wrong number of arguments");const h=f.map(p=>t.isA(p)?o():e.isA(p)?c():r.isA(p)?a(p):0);return h.length===1?h[0]:h},Co}var Fo,Ch;function zv(){if(Ch)return Fo;Ch=1;const i=D(),e=cg();return Fo=(...t)=>{if(t=i(t),t.length===0)throw new Error("measureAggregateVolume: no geometries supplied");const n=e(t);return t.length===1?n:n.reduce((o,c)=>o+c,0)},Fo}var Bo,Fh;function Lv(){if(Fh)return Bo;Fh=1;const i=D(),e=I(),r=N(),t=z(),n=L(),s=Q(),o=X(),c=new WeakMap,a=p=>{let g=c.get(p);if(g!==void 0)return g;const m=r.create();let v=0;const l=s.toPoints(p);if(l.length>0){let d=0;const q=r.create();l.forEach(y=>{r.add(m,m,r.fromVec2(q,y,0)),d++}),r.scale(m,m,1/d),l.forEach(y=>{v=Math.max(v,e.squaredDistance(m,y))}),v=Math.sqrt(v)}return g=[m,v],c.set(p,g),g},u=p=>{let g=c.get(p);if(g!==void 0)return g;const m=r.create();let v=0;const l=t.toSides(p);if(l.length>0){let d=0;const q=r.create();l.forEach(y=>{r.add(m,m,r.fromVec2(q,y[0],0)),d++}),r.scale(m,m,1/d),l.forEach(y=>{v=Math.max(v,e.squaredDistance(m,y[0]))}),v=Math.sqrt(v)}return g=[m,v],c.set(p,g),g},f=p=>{let g=c.get(p);if(g!==void 0)return g;const m=r.create();let v=0;const l=n.toPolygons(p);if(l.length>0){let d=0;l.forEach(q=>{o.toPoints(q).forEach(y=>{r.add(m,m,y),d++})}),r.scale(m,m,1/d),l.forEach(q=>{o.toPoints(q).forEach(y=>{v=Math.max(v,r.squaredDistance(m,y))})}),v=Math.sqrt(v)}return g=[m,v],c.set(p,g),g};return Bo=(...p)=>{p=i(p);const g=p.map(m=>s.isA(m)?a(m):t.isA(m)?u(m):n.isA(m)?f(m):[[0,0,0],0]);return g.length===1?g[0]:g},Bo}var Vo,Bh;function Iv(){if(Bh)return Vo;Bh=1;const i=D(),e=ce();return Vo=(...t)=>{t=i(t);const n=t.map(s=>{const o=e(s);return[o[0][0]+(o[1][0]-o[0][0])/2,o[0][1]+(o[1][1]-o[0][1])/2,o[0][2]+(o[1][2]-o[0][2])/2]});return n.length===1?n[0]:n},Vo}var Oo,Vh;function Hv(){if(Vh)return Oo;Vh=1;const i=D(),e=N(),r=z(),t=L(),n=new WeakMap,s=a=>{let u=n.get(a);if(u!==void 0)return u;const f=r.toSides(a);let h=0,p=0,g=0;if(f.length>0){for(let v=0;v<f.length;v++){const l=f[v][0],d=f[v][1],q=l[0]*d[1]-l[1]*d[0];h+=q,p+=(l[0]+d[0])*q,g+=(l[1]+d[1])*q}h/=2;const m=1/(h*6);p*=m,g*=m}return u=e.fromValues(p,g,0),n.set(a,u),u},o=a=>{let u=n.get(a);if(u!==void 0)return u;u=e.create();const f=t.toPolygons(a);if(f.length===0)return u;let h=0;const p=e.create();return f.forEach(g=>{const m=g.vertices;for(let v=0;v<m.length-2;v++){e.cross(p,m[v+1],m[v+2]);const l=e.dot(m[0],p)/6;h+=l,e.add(p,m[0],m[v+1]),e.add(p,p,m[v+2]);const d=e.scale(p,p,1/4*l);e.add(u,u,d)}}),e.scale(u,u,1/h),n.set(a,u),u};return Oo=(...a)=>{a=i(a);const u=a.map(f=>r.isA(f)?s(f):t.isA(f)?o(f):[0,0,0]);return u.length===1?u[0]:u},Oo}var ko,Oh;function Zv(){if(Oh)return ko;Oh=1;const i=D(),e=ce();return ko=(...t)=>{t=i(t);const n=t.map(s=>{const o=e(s);return[o[1][0]-o[0][0],o[1][1]-o[0][1],o[1][2]-o[0][2]]});return n.length===1?n[0]:n},ko}var No,kh;function se(){if(kh)return No;kh=1;const i=D(),{geom2:e,geom3:r,path2:t}=yc(),n=ag(),s=ce(),o=f=>n(s(f),2),c=f=>n(s(f),2),a=f=>n(s(f),3);return No=(...f)=>{if(f=i(f),f.length===0)throw new Error("wrong number of arguments");const h=f.map(p=>t.isA(p)?o(p):e.isA(p)?c(p):r.isA(p)?a(p):0);return h.length===1?h[0]:h},No}var Go,Nh;function Xv(){return Nh||(Nh=1,Go={measureAggregateArea:Gv(),measureAggregateBoundingBox:Ec(),measureAggregateEpsilon:Dv(),measureAggregateVolume:zv(),measureArea:ig(),measureBoundingBox:ce(),measureBoundingSphere:Lv(),measureCenter:Iv(),measureCenterOfMass:Hv(),measureDimensions:Zv(),measureEpsilon:se(),measureVolume:cg()}),Go}var Do,Gh;function j(){return Gh||(Gh=1,Do={isNumberArray:(t,n)=>Array.isArray(t)&&t.length>=n?t.every(s=>Number.isFinite(s)):!1,isGT:(t,n)=>Number.isFinite(t)&&t>n,isGTE:(t,n)=>Number.isFinite(t)&&t>=n}),Do}var zo,Dh;function Yv(){if(Dh)return zo;Dh=1;const{EPS:i,TAU:e}=Y(),r=I(),t=Q(),{isGT:n,isGTE:s,isNumberArray:o}=j();return zo=a=>{const u={center:[0,0],radius:1,startAngle:0,endAngle:e,makeTangent:!1,segments:32};let{center:f,radius:h,startAngle:p,endAngle:g,makeTangent:m,segments:v}=Object.assign({},u,a);if(!o(f,2))throw new Error("center must be an array of X and Y values");if(!n(h,0))throw new Error("radius must be greater than zero");if(!s(p,0))throw new Error("startAngle must be positive");if(!s(g,0))throw new Error("endAngle must be positive");if(!s(v,4))throw new Error("segments must be four or more");p=p%e,g=g%e;let l=e;p<g&&(l=g-p),p>g&&(l=g+(e-p));const d=Math.acos((h*h+h*h-i*i)/(2*h*h)),q=r.clone(f);let y;const P=[];if(l<d)y=r.fromAngleRadians(r.create(),p),r.scale(y,y,h),r.add(y,y,q),P.push(y);else{const w=Math.max(1,Math.floor(v*(l/e)))+1;let R=w*.5/l;R>.25&&(R=.25);const x=m?w+2:w;for(let E=0;E<=x;E++){let A=E;m&&(A=(E-1)*(w-2*R)/w+R,A<0&&(A=0),A>w&&(A=w));const _=p+A*(l/w);y=r.fromAngleRadians(r.create(),_),r.scale(y,y,h),r.add(y,y,q),P.push(y)}}return t.fromPoints({closed:!1},P)},zo}var Lo,zh;function ug(){if(zh)return Lo;zh=1;const{EPS:i,TAU:e}=Y(),r=I(),t=z(),{sin:n,cos:s}=ee(),{isGTE:o,isNumberArray:c}=j();return Lo=u=>{const f={center:[0,0],radius:[1,1],startAngle:0,endAngle:e,segments:32};let{center:h,radius:p,startAngle:g,endAngle:m,segments:v}=Object.assign({},f,u);if(!c(h,2))throw new Error("center must be an array of X and Y values");if(!c(p,2))throw new Error("radius must be an array of X and Y values");if(!p.every(R=>R>=0))throw new Error("radius values must be positive");if(!o(g,0))throw new Error("startAngle must be positive");if(!o(m,0))throw new Error("endAngle must be positive");if(!o(v,3))throw new Error("segments must be three or more");if(p[0]===0||p[1]===0)return t.create();g=g%e,m=m%e;let l=e;g<m&&(l=m-g),g>m&&(l=m+(e-g));const d=Math.min(p[0],p[1]),q=Math.acos((d*d+d*d-i*i)/(2*d*d));if(l<q)throw new Error("startAngle and endAngle do not define a significant rotation");v=Math.floor(v*(l/e));const y=r.clone(h),P=l/v,w=[];v=l<e?v+1:v;for(let R=0;R<v;R++){const x=P*R+g,E=r.fromValues(p[0]*s(x),p[1]*n(x));r.add(E,y,E),w.push(E)}return l<e&&w.push(y),t.fromPoints(w)},Lo}var Io,Lh;function lg(){if(Lh)return Io;Lh=1;const{TAU:i}=Y(),e=ug(),{isGTE:r}=j();return Io=n=>{const s={center:[0,0],radius:1,startAngle:0,endAngle:i,segments:32};let{center:o,radius:c,startAngle:a,endAngle:u,segments:f}=Object.assign({},s,n);if(!r(c,0))throw new Error("radius must be positive");return c=[c,c],e({center:o,radius:c,startAngle:a,endAngle:u,segments:f})},Io}var Ho,Ih;function Ac(){if(Ih)return Ho;Ih=1;const i=L(),e=X(),{isNumberArray:r}=j();return Ho=n=>{const s={center:[0,0,0],size:[2,2,2]},{center:o,size:c}=Object.assign({},s,n);if(!r(o,3))throw new Error("center must be an array of X, Y and Z values");if(!r(c,3))throw new Error("size must be an array of width, depth and height values");if(!c.every(u=>u>=0))throw new Error("size values must be positive");return c[0]===0||c[1]===0||c[2]===0?i.create():i.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(u=>{const f=u[0].map(h=>[o[0]+c[0]/2*(2*!!(h&1)-1),o[1]+c[1]/2*(2*!!(h&2)-1),o[2]+c[2]/2*(2*!!(h&4)-1)]);return e.create(f)}))},Ho}var Zo,Hh;function Uv(){if(Hh)return Zo;Hh=1;const i=Ac(),{isGTE:e}=j();return Zo=t=>{const n={center:[0,0,0],size:2};let{center:s,size:o}=Object.assign({},n,t);if(!e(o,0))throw new Error("size must be positive");return o=[o,o,o],i({center:s,size:o})},Zo}var Xo,Zh;function fg(){if(Zh)return Xo;Zh=1;const{EPS:i,TAU:e}=Y(),r=N(),t=L(),n=X(),{sin:s,cos:o}=ee(),{isGT:c,isGTE:a,isNumberArray:u}=j();return Xo=h=>{const p={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:e,segments:32};let{center:g,height:m,startRadius:v,startAngle:l,endRadius:d,endAngle:q,segments:y}=Object.assign({},p,h);if(!u(g,3))throw new Error("center must be an array of X, Y and Z values");if(!c(m,0))throw new Error("height must be greater then zero");if(!u(v,2))throw new Error("startRadius must be an array of X and Y values");if(!v.every(V=>V>=0))throw new Error("startRadius values must be positive");if(!u(d,2))throw new Error("endRadius must be an array of X and Y values");if(!d.every(V=>V>=0))throw new Error("endRadius values must be positive");if(d.every(V=>V===0)&&v.every(V=>V===0))throw new Error("at least one radius must be positive");if(!a(l,0))throw new Error("startAngle must be positive");if(!a(q,0))throw new Error("endAngle must be positive");if(!a(y,4))throw new Error("segments must be four or more");l=l%e,q=q%e;let P=e;l<q&&(P=q-l),l>q&&(P=q+(e-l));const w=Math.min(v[0],v[1],d[0],d[1]),R=Math.acos((w*w+w*w-i*i)/(2*w*w));if(P<R)throw new Error("startAngle and endAngle do not define a significant rotation");const x=Math.floor(y*(P/e)),E=r.fromValues(0,0,-(m/2)),A=r.fromValues(0,0,m/2),_=r.subtract(r.create(),A,E),S=r.fromValues(1,0,0),b=r.fromValues(0,1,0),T=r.create(),M=r.create(),$=r.create(),C=(V,k,G)=>{const Z=k*P+l;return r.scale(T,S,G[0]*o(Z)),r.scale(M,b,G[1]*s(Z)),r.add(T,T,M),r.scale($,_,V),r.add($,$,E),r.add(r.create(),T,$)},F=(...V)=>{const k=V.map(G=>r.add(r.create(),G,g));return n.create(k)},B=[];for(let V=0;V<x;V++){const k=V/x;let G=(V+1)/x;P===e&&V===x-1&&(G=0),d[0]===v[0]&&d[1]===v[1]?(B.push(F(E,C(0,G,d),C(0,k,d))),B.push(F(C(0,G,d),C(1,G,d),C(1,k,d),C(0,k,d))),B.push(F(A,C(1,k,d),C(1,G,d)))):(v[0]>0&&v[1]>0&&B.push(F(E,C(0,G,v),C(0,k,v))),(v[0]>0||v[1]>0)&&B.push(F(C(0,k,v),C(0,G,v),C(1,k,d))),d[0]>0&&d[1]>0&&B.push(F(A,C(1,k,d),C(1,G,d))),(d[0]>0||d[1]>0)&&B.push(F(C(1,k,d),C(0,G,v),C(1,G,d))))}return P<e&&(B.push(F(E,C(0,0,v),A)),B.push(F(C(0,0,v),C(1,0,d),A)),B.push(F(E,A,C(0,1,v))),B.push(F(C(0,1,v),A,C(1,1,d)))),t.create(B)},Xo}var Yo,Xh;function hg(){if(Xh)return Yo;Xh=1;const i=L(),e=fg(),{isGTE:r}=j();return Yo=n=>{const s={center:[0,0,0],height:2,radius:1,segments:32},{center:o,height:c,radius:a,segments:u}=Object.assign({},s,n);if(!r(a,0))throw new Error("radius must be positive");return c===0||a===0?i.create():e({center:o,height:c,startRadius:[a,a],endRadius:[a,a],segments:u})},Yo}var Uo,Yh;function dg(){if(Yh)return Uo;Yh=1;const{TAU:i}=Y(),e=N(),r=L(),t=X(),{sin:n,cos:s}=ee(),{isGTE:o,isNumberArray:c}=j();return Uo=u=>{const f={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:h,radius:p,segments:g,axes:m}=Object.assign({},f,u);if(!c(h,3))throw new Error("center must be an array of X, Y and Z values");if(!c(p,3))throw new Error("radius must be an array of X, Y and Z values");if(!p.every(x=>x>=0))throw new Error("radius values must be positive");if(!o(g,4))throw new Error("segments must be four or more");if(p[0]===0||p[1]===0||p[2]===0)return r.create();const v=e.scale(e.create(),e.normalize(e.create(),m[0]),p[0]),l=e.scale(e.create(),e.normalize(e.create(),m[1]),p[1]),d=e.scale(e.create(),e.normalize(e.create(),m[2]),p[2]),q=Math.round(g/4);let y;const P=[],w=e.create(),R=e.create();for(let x=0;x<=g;x++){const E=i*x/g,A=e.add(e.create(),e.scale(w,v,s(E)),e.scale(R,l,n(E)));if(x>0){let _,S;for(let b=0;b<=q;b++){const T=i/4*b/q,M=s(T),$=n(T);if(b>0){let C=[],F;F=e.subtract(e.create(),e.scale(w,y,_),e.scale(R,d,S)),C.push(e.add(F,F,h)),F=e.subtract(e.create(),e.scale(w,A,_),e.scale(R,d,S)),C.push(e.add(F,F,h)),b<q&&(F=e.subtract(e.create(),e.scale(w,A,M),e.scale(R,d,$)),C.push(e.add(F,F,h))),F=e.subtract(e.create(),e.scale(w,y,M),e.scale(R,d,$)),C.push(e.add(F,F,h)),P.push(t.create(C)),C=[],F=e.add(e.create(),e.scale(w,y,_),e.scale(R,d,S)),C.push(e.add(e.create(),h,F)),F=e.add(F,e.scale(w,A,_),e.scale(R,d,S)),C.push(e.add(e.create(),h,F)),b<q&&(F=e.add(F,e.scale(w,A,M),e.scale(R,d,$)),C.push(e.add(e.create(),h,F))),F=e.add(F,e.scale(w,y,M),e.scale(R,d,$)),C.push(e.add(e.create(),h,F)),C.reverse(),P.push(t.create(C))}_=M,S=$}}y=A}return r.create(P)},Uo}var Wo,Uh;function gg(){if(Uh)return Wo;Uh=1;const i=L(),e=X(),{isNumberArray:r}=j();return Wo=n=>{const s={points:[],faces:[],colors:void 0,orientation:"outward"},{points:o,faces:c,colors:a,orientation:u}=Object.assign({},s,n);if(!(Array.isArray(o)&&Array.isArray(c)))throw new Error("points and faces must be arrays");if(o.length<3)throw new Error("three or more points are required");if(c.length<1)throw new Error("one or more faces are required");if(a){if(!Array.isArray(a))throw new Error("colors must be an array");if(a.length!==c.length)throw new Error("faces and colors must have the same length")}o.forEach((h,p)=>{if(!r(h,3))throw new Error(`point ${p} must be an array of X, Y, Z values`)}),c.forEach((h,p)=>{if(h.length<3)throw new Error(`face ${p} must contain 3 or more indexes`);if(!r(h,h.length))throw new Error(`face ${p} must be an array of numbers`)}),u!=="outward"&&c.forEach(h=>h.reverse());const f=c.map((h,p)=>{const g=e.create(h.map(m=>o[m]));return a&&a[p]&&(g.color=a[p]),g});return i.create(f)},Wo}var Qo,Wh;function Wv(){if(Wh)return Qo;Wh=1;const i=K(),e=N(),r=L(),t=gg(),{isGTE:n}=j();return Qo=o=>{const c={radius:1,frequency:6};let{radius:a,frequency:u}=Object.assign({},c,o);if(!n(a,0))throw new Error("radius must be positive");if(!n(u,6))throw new Error("frequency must be six or more");if(a===0)return r.create();u=Math.floor(u/6);const f=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],h=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],p=(q,y,P)=>{const w=q[0],R=q[1],x=q[2];let E=P;const A=[],_=[];for(let S=0;S<y;S++)for(let b=0;b<y-S;b++){const T=S/y,M=(S+1)/y,$=b/(y-S),C=(b+1)/(y-S),F=y-S-1?b/(y-S-1):1,B=[];B[0]=g(g(w,R,$),x,T),B[1]=g(g(w,R,C),x,T),B[2]=g(g(w,R,F),x,M);for(let O=0;O<3;O++){const V=e.length(B[O]);for(let k=0;k<3;k++)B[O][k]/=V}if(A.push(B[0],B[1],B[2]),_.push([E,E+1,E+2]),E+=3,b<y-S-1){const O=y-S-1?(b+1)/(y-S-1):1;B[0]=g(g(w,R,C),x,T),B[1]=g(g(w,R,O),x,M),B[2]=g(g(w,R,F),x,M);for(let V=0;V<3;V++){const k=e.length(B[V]);for(let G=0;G<3;G++)B[V][G]/=k}A.push(B[0],B[1],B[2]),_.push([E,E+1,E+2]),E+=3}}return{points:A,triangles:_,offset:E}},g=(q,y,P)=>{const w=1-P,R=[];for(let x=0;x<3;x++)R[x]=q[x]*w+y[x]*P;return R};let m=[],v=[],l=0;for(let q=0;q<h.length;q++){const y=p([f[h[q][0]],f[h[q][1]],f[h[q][2]]],u,l);m=m.concat(y.points),v=v.concat(y.triangles),l=y.offset}let d=t({points:m,faces:v,orientation:"inward"});return a!==1&&(d=r.transform(i.fromScaling(i.create(),[a,a,a]),d)),d},Qo}var Ko,Qh;function Qv(){if(Qh)return Ko;Qh=1;const i=Q();return Ko=r=>{if(!Array.isArray(r))throw new Error("points must be an array");return i.fromPoints({},r)},Ko}var Jo,Kh;function Kv(){if(Kh)return Jo;Kh=1;const i=z();return Jo=r=>{const t={points:[],paths:[],orientation:"counterclockwise"},{points:n,paths:s,orientation:o}=Object.assign({},t,r);if(!(Array.isArray(n)&&Array.isArray(s)))throw new Error("points and paths must be arrays");let c=n;Array.isArray(n[0])&&(Array.isArray(n[0][0])||(c=[n])),c.forEach((p,g)=>{if(!Array.isArray(p))throw new Error("list of points "+g+" must be an array");if(p.length<3)throw new Error("list of points "+g+" must contain three or more points");p.forEach((m,v)=>{if(!Array.isArray(m))throw new Error("list of points "+g+", point "+v+" must be an array");if(m.length<2)throw new Error("list of points "+g+", point "+v+" must contain by X and Y values")})});let a=s;if(s.length===0){let p=0;a=c.map(g=>g.map(m=>p++))}const u=[];c.forEach(p=>p.forEach(g=>u.push(g)));let f=[];a.forEach(p=>{const g=p.map(v=>u[v]),m=i.fromPoints(g);f=f.concat(i.toSides(m))});let h=i.create(f);return o==="clockwise"&&(h=i.reverse(h)),h},Jo}var jo,Jh;function bc(){if(Jh)return jo;Jh=1;const i=I(),e=z(),{isNumberArray:r}=j();return jo=n=>{const s={center:[0,0],size:[2,2]},{center:o,size:c}=Object.assign({},s,n);if(!r(o,2))throw new Error("center must be an array of X and Y values");if(!r(c,2))throw new Error("size must be an array of X and Y values");if(!c.every(h=>h>=0))throw new Error("size values must be positive");if(c[0]===0||c[1]===0)return e.create();const a=[c[0]/2,c[1]/2],u=[a[0],-a[1]],f=[i.subtract(i.create(),o,a),i.add(i.create(),o,u),i.add(i.create(),o,a),i.subtract(i.create(),o,u)];return e.fromPoints(f)},jo}var ei,jh;function Jv(){if(jh)return ei;jh=1;const{EPS:i,TAU:e}=Y(),r=I(),t=N(),n=L(),s=X(),{sin:o,cos:c}=ee(),{isGTE:a,isNumberArray:u}=j(),f=Ac(),h=(l,d,q,y,P,w)=>{const R=e/4*P/y,x=c(R),E=o(R),A=y-P;let _=q*x,S=d[2]-(q-q*E);w||(S=q-q*E-d[2]),_=_>i?_:0;const b=t.add(t.create(),l,[d[0]-q,d[1]-q,S]),T=t.add(t.create(),l,[q-d[0],d[1]-q,S]),M=t.add(t.create(),l,[q-d[0],q-d[1],S]),$=t.add(t.create(),l,[d[0]-q,q-d[1],S]),C=[],F=[],B=[],O=[];for(let V=0;V<=A;V++){const k=A>0?e/4*V/A:0,G=r.fromAngleRadians(r.create(),k);r.scale(G,G,_);const Z=t.fromVec2(t.create(),G);C.push(t.add(t.create(),b,Z)),t.rotateZ(Z,Z,[0,0,0],e/4),F.push(t.add(t.create(),T,Z)),t.rotateZ(Z,Z,[0,0,0],e/4),B.push(t.add(t.create(),M,Z)),t.rotateZ(Z,Z,[0,0,0],e/4),O.push(t.add(t.create(),$,Z))}return w?[C,F,B,O]:(C.reverse(),F.reverse(),B.reverse(),O.reverse(),[O,B,F,C])},p=(l,d)=>{const q=[];for(let y=0;y<l.length;y++){const P=l[y],w=d[y];for(let R=0;R<P.length-1;R++)q.push(s.create([P[R],P[R+1],w[R]])),R<w.length-1&&q.push(s.create([w[R],P[R+1],w[R+1]]))}return q},g=(l,d)=>{const q=[];for(let y=0;y<l.length;y++){let P=l[y],w=d[y];const R=P[P.length-1],x=w[w.length-1],E=(y+1)%l.length;P=l[E],w=d[E];const A=P[0],_=w[0];q.push(s.create([R,A,_,x]))}return q},m=(l,d)=>{l=[l[3],l[2],l[1],l[0]],l=l.map(w=>w.slice().reverse());const q=[];l.forEach(w=>{w.forEach(R=>q.push(R))});const y=[];d.forEach(w=>{w.forEach(R=>y.push(R))});const P=[];for(let w=0;w<y.length;w++){const R=(w+1)%y.length;P.push(s.create([q[w],q[R],y[R],y[w]]))}return P};return ei=l=>{const d={center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32};let{center:q,size:y,roundRadius:P,segments:w}=Object.assign({},d,l);if(!u(q,3))throw new Error("center must be an array of X, Y and Z values");if(!u(y,3))throw new Error("size must be an array of X, Y and Z values");if(!y.every(A=>A>=0))throw new Error("size values must be positive");if(!a(P,0))throw new Error("roundRadius must be positive");if(!a(w,4))throw new Error("segments must be four or more");if(y[0]===0||y[1]===0||y[2]===0)return n.create();if(P===0)return f({center:q,size:y});if(y=y.map(A=>A/2),P>y[0]-i||P>y[1]-i||P>y[2]-i)throw new Error("roundRadius must be smaller than the radius of all dimensions");w=Math.floor(w/4);let R=null,x=null,E=[];for(let A=0;A<=w;A++){const _=h(q,y,P,w,A,!0),S=h(q,y,P,w,A,!1);if(A===0&&(E=E.concat(m(S,_))),R&&(E=E.concat(p(R,_),g(R,_))),x&&(E=E.concat(p(x,S),g(x,S))),A===w){let b=_.map(T=>T[0]);E.push(s.create(b)),b=S.map(T=>T[0]),E.push(s.create(b))}R=_,x=S}return n.create(E)},ei}var ti,ed;function jv(){if(ed)return ti;ed=1;const{EPS:i,TAU:e}=Y(),r=N(),t=L(),n=X(),{sin:s,cos:o}=ee(),{isGTE:c,isNumberArray:a}=j(),u=hg();return ti=h=>{const p={center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},{center:g,height:m,radius:v,roundRadius:l,segments:d}=Object.assign({},p,h);if(!a(g,3))throw new Error("center must be an array of X, Y and Z values");if(!c(m,0))throw new Error("height must be positive");if(!c(v,0))throw new Error("radius must be positive");if(!c(l,0))throw new Error("roundRadius must be positive");if(l>v)throw new Error("roundRadius must be smaller than the radius");if(!c(d,4))throw new Error("segments must be four or more");if(m===0||v===0)return t.create();if(l===0)return u({center:g,height:m,radius:v});const q=[0,0,-(m/2)],y=[0,0,m/2],P=r.subtract(r.create(),y,q),w=r.length(P);if(2*l>w-i)throw new Error("height must be larger than twice roundRadius");let R;Math.abs(P[0])>Math.abs(P[1])?R=r.fromValues(0,1,0):R=r.fromValues(1,0,0);const x=r.scale(r.create(),r.normalize(r.create(),P),l),E=r.scale(r.create(),r.normalize(r.create(),r.cross(r.create(),x,R)),v),A=r.scale(r.create(),r.normalize(r.create(),r.cross(r.create(),E,x)),v);r.add(q,q,x),r.subtract(y,y,x);const _=Math.floor(.25*d),S=F=>{const B=F.map(O=>r.add(O,O,g));return n.create(B)},b=[],T=r.create(),M=r.create();let $;for(let F=0;F<=d;F++){const B=e*F/d,O=r.add(r.create(),r.scale(T,E,o(B)),r.scale(M,A,s(B)));if(F>0){let V=[];V.push(r.add(r.create(),q,O)),V.push(r.add(r.create(),q,$)),V.push(r.add(r.create(),y,$)),V.push(r.add(r.create(),y,O)),b.push(S(V));let k,G;for(let Z=0;Z<=_;Z++){const U=e/4*Z/_,J=o(U),W=s(U);if(Z>0){V=[];let H;H=r.add(r.create(),q,r.subtract(T,r.scale(T,$,k),r.scale(M,x,G))),V.push(H),H=r.add(r.create(),q,r.subtract(T,r.scale(T,O,k),r.scale(M,x,G))),V.push(H),Z<_&&(H=r.add(r.create(),q,r.subtract(T,r.scale(T,O,J),r.scale(M,x,W))),V.push(H)),H=r.add(r.create(),q,r.subtract(T,r.scale(T,$,J),r.scale(M,x,W))),V.push(H),b.push(S(V)),V=[],H=r.add(r.create(),r.scale(T,$,k),r.scale(M,x,G)),r.add(H,H,y),V.push(H),H=r.add(r.create(),r.scale(T,O,k),r.scale(M,x,G)),r.add(H,H,y),V.push(H),Z<_&&(H=r.add(r.create(),r.scale(T,O,J),r.scale(M,x,W)),r.add(H,H,y),V.push(H)),H=r.add(r.create(),r.scale(T,$,J),r.scale(M,x,W)),r.add(H,H,y),V.push(H),V.reverse(),b.push(S(V))}k=J,G=W}}$=O}return t.create(b)},ti}var ri,td;function e5(){if(td)return ri;td=1;const{EPS:i,TAU:e}=Y(),r=I(),t=z(),{isGTE:n,isNumberArray:s}=j(),o=bc();return ri=a=>{const u={center:[0,0],size:[2,2],roundRadius:.2,segments:32};let{center:f,size:h,roundRadius:p,segments:g}=Object.assign({},u,a);if(!s(f,2))throw new Error("center must be an array of X and Y values");if(!s(h,2))throw new Error("size must be an array of X and Y values");if(!h.every(x=>x>=0))throw new Error("size values must be positive");if(!n(p,0))throw new Error("roundRadius must be positive");if(!n(g,4))throw new Error("segments must be four or more");if(h[0]===0||h[1]===0)return t.create();if(p===0)return o({center:f,size:h});if(h=h.map(x=>x/2),p>h[0]-i||p>h[1]-i)throw new Error("roundRadius must be smaller than the radius of all dimensions");const m=Math.floor(g/4),v=r.add(r.create(),f,[h[0]-p,h[1]-p]),l=r.add(r.create(),f,[p-h[0],h[1]-p]),d=r.add(r.create(),f,[p-h[0],p-h[1]]),q=r.add(r.create(),f,[h[0]-p,p-h[1]]),y=[],P=[],w=[],R=[];for(let x=0;x<=m;x++){const E=e/4*x/m,A=r.fromAngleRadians(r.create(),E);r.scale(A,A,p),y.push(r.add(r.create(),v,A)),r.rotate(A,A,r.create(),e/4),P.push(r.add(r.create(),l,A)),r.rotate(A,A,r.create(),e/4),w.push(r.add(r.create(),d,A)),r.rotate(A,A,r.create(),e/4),R.push(r.add(r.create(),q,A))}return t.fromPoints(y.concat(P,w,R))},ri}var ni,rd;function pg(){if(rd)return ni;rd=1;const i=dg(),{isGTE:e}=j();return ni=t=>{const n={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:s,radius:o,segments:c,axes:a}=Object.assign({},n,t);if(!e(o,0))throw new Error("radius must be positive");return o=[o,o,o],i({center:s,radius:o,segments:c,axes:a})},ni}var si,nd;function t5(){if(nd)return si;nd=1;const i=bc(),{isGTE:e}=j();return si=t=>{const n={center:[0,0],size:2};let{center:s,size:o}=Object.assign({},n,t);if(!e(o,0))throw new Error("size must be positive");return o=[o,o],i({center:s,size:o})},si}var oi,sd;function r5(){if(sd)return oi;sd=1;const{TAU:i}=Y(),e=I(),r=z(),{isGT:t,isGTE:n,isNumberArray:s}=j(),o=(u,f)=>u>0&&f>1&&f<u/2?Math.cos(Math.PI*f/u)/Math.cos(Math.PI*(f-1)/u):0,c=(u,f,h,p)=>{const g=i/u,m=[];for(let v=0;v<u;v++){const l=e.fromAngleRadians(e.create(),g*v+h);e.scale(l,l,f),e.add(l,p,l),m.push(l)}return m};return oi=u=>{const f={center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0};let{center:h,vertices:p,outerRadius:g,innerRadius:m,density:v,startAngle:l}=Object.assign({},f,u);if(!s(h,2))throw new Error("center must be an array of X and Y values");if(!n(p,2))throw new Error("vertices must be two or more");if(!t(g,0))throw new Error("outerRadius must be greater than zero");if(!n(m,0))throw new Error("innerRadius must be greater than zero");if(!n(l,0))throw new Error("startAngle must be greater than zero");if(p=Math.floor(p),v=Math.floor(v),l=l%i,m===0){if(!n(v,2))throw new Error("density must be two or more");m=g*o(p,v)}const d=e.clone(h),q=c(p,g,l,d),y=c(p,m,l+Math.PI/p,d),P=[];for(let w=0;w<p;w++)P.push(q[w]),P.push(y[w]);return r.fromPoints(P)},oi}var ii,od;function de(){if(od)return ii;od=1;const i=D(),e=K(),r=re(),t=z(),n=L(),s=Q(),o=(f,...h)=>{const p={origin:[0,0,0],normal:[0,0,1]},{origin:g,normal:m}=Object.assign({},p,f);if(h=i(h),h.length===0)throw new Error("wrong number of arguments");const v=r.fromNormalAndPoint(r.create(),m,g);if(Number.isNaN(v[0]))throw new Error("the given origin and normal do not define a proper plane");const l=e.mirrorByPlane(e.create(),v),d=h.map(q=>s.isA(q)?s.transform(l,q):t.isA(q)?t.transform(l,q):n.isA(q)?n.transform(l,q):q);return d.length===1?d[0]:d};return ii={mirror:o,mirrorX:(...f)=>o({normal:[1,0,0]},f),mirrorY:(...f)=>o({normal:[0,1,0]},f),mirrorZ:(...f)=>o({normal:[0,0,1]},f)},ii}var ai,id;function mg(){if(id)return ai;id=1;const i=re(),e=N();return ai=t=>{const n=t.edges;if(n.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const s=n.reduce((u,f)=>e.add(e.create(),u,f[0]),e.create());e.scale(s,s,1/n.length);let o,c=0;n.forEach(u=>{if(!e.equals(u[0],u[1])){const f=e.squaredDistance(s,u[0]);f>c&&(o=u,c=f)}});const a=n.find(u=>e.equals(u[1],o[0]));return i.fromPoints(i.create(),a[0],o[0],o[1])},ai}var ci,ad;function ue(){return ad||(ad=1,ci=e=>(e||(e=[]),{edges:e})),ci}var ui,cd;function n5(){if(cd)return ui;cd=1;const i=ue(),e=N();return ui=(...t)=>{let n,s;return t.length===1?(n=i(),s=t[0]):(n=t[0],s=t[1]),n.edges=s.edges.map(o=>[e.clone(o[0]),e.clone(o[1])]),n},ui}var li,ud;function s5(){if(ud)return li;ud=1;const i=N();return li=(r,t)=>{const n=r.edges,s=t.edges;return n.length!==s.length?!1:n.reduce((c,a,u)=>{const f=s[u],h=i.squaredDistance(a[0],f[0]);return c&&h<Number.EPSILON},!0)},li}var fi,ld;function o5(){if(ld)return fi;ld=1;const i=N(),e=ue();return fi=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");if(t.length<3)throw new Error("the given points must contain THREE or more points");const n=[];let s=t[t.length-1];return t.forEach(o=>{o.length===2&&n.push([i.fromVec2(i.create(),s),i.fromVec2(i.create(),o)]),o.length===3&&n.push([s,o]),s=o}),e(n)},fi}var hi,fd;function i5(){if(fd)return hi;fd=1;const i=N(),e=ue();return hi=t=>{if(!Array.isArray(t))throw new Error("the given sides must be an array");const n=[];return t.forEach(s=>{n.push([i.fromVec2(i.create(),s[0]),i.fromVec2(i.create(),s[1])])}),e(n)},hi}var di,hd;function a5(){return hd||(hd=1,di=e=>!!(e&&typeof e=="object"&&"edges"in e&&Array.isArray(e.edges))),di}var gi,dd;function c5(){if(dd)return gi;dd=1;const i=ue();return gi=(...r)=>{let t,n;return r.length===1?(t=i(),n=r[0]):(t=r[0],n=r[1]),t.edges=n.edges.map(s=>[s[1],s[0]]),t},gi}var pi,gd;function u5(){return gd||(gd=1,pi=e=>e.edges),pi}var mi,pd;function l5(){return pd||(pd=1,mi=(e,r)=>{let t,n,s,o,c,a=1;do{n=e,e=null;let u=null;for(c=0;n;){c++,s=n;let f=0;for(t=0;t<a&&(f++,s=s.nextZ,!!s);t++);let h=a;for(;f>0||h>0&&s;)f!==0&&(h===0||!s||r(n)<=r(s))?(o=n,n=n.nextZ,f--):(o=s,s=s.nextZ,h--),u?u.nextZ=o:e=o,o.prevZ=u,u=o;n=s}u.nextZ=null,a*=2}while(c>1);return e}),mi}var vi,md;function vg(){if(md)return vi;md=1;const i=l5();class e{constructor(s,o,c){this.i=s,this.x=o,this.y=c,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}return vi={Node:e,insertNode:(n,s,o,c)=>{const a=new e(n,s,o);return c?(a.next=c.next,a.prev=c,c.next.prev=a,c.next=a):(a.prev=a,a.next=a),a},removeNode:n=>{n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)},sortLinked:i},vi}var qi,vd;function $c(){return vd||(vd=1,qi={area:(r,t,n)=>(t.y-r.y)*(n.x-t.x)-(t.x-r.x)*(n.y-t.y),pointInTriangle:(r,t,n,s,o,c,a,u)=>(o-a)*(t-u)-(r-a)*(c-u)>=0&&(r-a)*(s-u)-(n-a)*(t-u)>=0&&(n-a)*(c-u)-(o-a)*(s-u)>=0}),qi}var yi,qd;function qg(){if(qd)return yi;qd=1;const{Node:i,insertNode:e,removeNode:r}=vg(),{area:t}=$c(),n=(l,d,q,y,P)=>{let w;if(P===m(l,d,q,y)>0)for(let R=d;R<q;R+=y)w=e(R,l[R],l[R+1],w);else for(let R=q-y;R>=d;R-=y)w=e(R,l[R],l[R+1],w);return w&&v(w,w.next)&&(r(w),w=w.next),w},s=(l,d)=>{if(!l)return l;d||(d=l);let q=l,y;do if(y=!1,!q.steiner&&(v(q,q.next)||t(q.prev,q,q.next)===0)){if(r(q),q=d=q.prev,q===q.next)break;y=!0}else q=q.next;while(y||q!==d);return d},o=(l,d,q)=>{let y=l;do{const P=y.prev,w=y.next.next;!v(P,w)&&p(P,y,y.next,w)&&a(P,w)&&a(w,P)&&(d.push(P.i/q),d.push(y.i/q),d.push(w.i/q),r(y),r(y.next),y=l=w),y=y.next}while(y!==l);return s(y)},c=(l,d)=>{let q=l;do{if(q.i!==l.i&&q.next.i!==l.i&&q.i!==d.i&&q.next.i!==d.i&&p(q,q.next,l,d))return!0;q=q.next}while(q!==l);return!1},a=(l,d)=>t(l.prev,l,l.next)<0?t(l,d,l.next)>=0&&t(l,l.prev,d)>=0:t(l,d,l.prev)<0||t(l,l.next,d)<0,u=(l,d)=>{let q=l,y=!1;const P=(l.x+d.x)/2,w=(l.y+d.y)/2;do q.y>w!=q.next.y>w&&q.next.y!==q.y&&P<(q.next.x-q.x)*(w-q.y)/(q.next.y-q.y)+q.x&&(y=!y),q=q.next;while(q!==l);return y},f=(l,d)=>{const q=new i(l.i,l.x,l.y),y=new i(d.i,d.x,d.y),P=l.next,w=d.prev;return l.next=d,d.prev=l,q.next=P,P.prev=q,y.next=q,q.prev=y,w.next=y,y.prev=w,y},h=(l,d)=>l.next.i!==d.i&&l.prev.i!==d.i&&!c(l,d)&&(a(l,d)&&a(d,l)&&u(l,d)&&(t(l.prev,l,d.prev)||t(l,d.prev,d))||v(l,d)&&t(l.prev,l,l.next)>0&&t(d.prev,d,d.next)>0),p=(l,d,q,y)=>{const P=Math.sign(t(l,d,q)),w=Math.sign(t(l,d,y)),R=Math.sign(t(q,y,l)),x=Math.sign(t(q,y,d));return!!(P!==w&&R!==x||P===0&&g(l,q,d)||w===0&&g(l,y,d)||R===0&&g(q,l,y)||x===0&&g(q,d,y))},g=(l,d,q)=>d.x<=Math.max(l.x,q.x)&&d.x>=Math.min(l.x,q.x)&&d.y<=Math.max(l.y,q.y)&&d.y>=Math.min(l.y,q.y),m=(l,d,q,y)=>{let P=0;for(let w=d,R=q-y;w<q;w+=y)P+=(l[R]-l[w])*(l[w+1]+l[R+1]),R=w;return P},v=(l,d)=>l.x===d.x&&l.y===d.y;return yi={cureLocalIntersections:o,filterPoints:s,isValidDiagonal:h,linkedPolygon:n,locallyInside:a,splitPolygon:f},yi}var wi,yd;function f5(){if(yd)return wi;yd=1;const{filterPoints:i,linkedPolygon:e,locallyInside:r,splitPolygon:t}=qg(),{area:n,pointInTriangle:s}=$c(),o=(h,p,g,m)=>{const v=[];for(let l=0,d=p.length;l<d;l++){const q=p[l]*m,y=l<d-1?p[l+1]*m:h.length,P=e(h,q,y,m,!1);P===P.next&&(P.steiner=!0),v.push(f(P))}v.sort((l,d)=>l.x-d.x);for(let l=0;l<v.length;l++)g=c(v[l],g),g=i(g,g.next);return g},c=(h,p)=>{const g=a(h,p);if(!g)return p;const m=t(g,h),v=i(g,g.next);return i(m,m.next),p===g?v:p},a=(h,p)=>{let g=p;const m=h.x,v=h.y;let l=-1/0,d;do{if(v<=g.y&&v>=g.next.y&&g.next.y!==g.y){const R=g.x+(v-g.y)*(g.next.x-g.x)/(g.next.y-g.y);if(R<=m&&R>l){if(l=R,R===m){if(v===g.y)return g;if(v===g.next.y)return g.next}d=g.x<g.next.x?g:g.next}}g=g.next}while(g!==p);if(!d)return null;if(m===l)return d;const q=d,y=d.x,P=d.y;let w=1/0;g=d;do{if(m>=g.x&&g.x>=y&&m!==g.x&&s(v<P?m:l,v,y,P,v<P?l:m,v,g.x,g.y)){const R=Math.abs(v-g.y)/(m-g.x);r(g,h)&&(R<w||R===w&&(g.x>d.x||g.x===d.x&&u(d,g)))&&(d=g,w=R)}g=g.next}while(g!==q);return d},u=(h,p)=>n(h.prev,h,p.prev)<0&&n(p.next,h,h.next)<0,f=h=>{let p=h,g=h;do(p.x<g.x||p.x===g.x&&p.y<g.y)&&(g=p),p=p.next;while(p!==h);return g};return wi=o,wi}var Pi,wd;function h5(){if(wd)return Pi;wd=1;const i=f5(),{removeNode:e,sortLinked:r}=vg(),{cureLocalIntersections:t,filterPoints:n,isValidDiagonal:s,linkedPolygon:o,splitPolygon:c}=qg(),{area:a,pointInTriangle:u}=$c(),f=(d,q,y=2)=>{const P=q&&q.length,w=P?q[0]*y:d.length;let R=o(d,0,w,y,!0);const x=[];if(!R||R.next===R.prev)return x;let E,A,_,S,b;if(P&&(R=i(d,q,R,y)),d.length>80*y){E=_=d[0],A=S=d[1];for(let T=y;T<w;T+=y){const M=d[T],$=d[T+1];M<E&&(E=M),$<A&&(A=$),M>_&&(_=M),$>S&&(S=$)}b=Math.max(_-E,S-A),b=b!==0?1/b:0}return h(R,x,y,E,A,b),x},h=(d,q,y,P,w,R,x)=>{if(!d)return;!x&&R&&v(d,P,w,R);let E=d,A,_;for(;d.prev!==d.next;){if(A=d.prev,_=d.next,R?g(d,P,w,R):p(d)){q.push(A.i/y),q.push(d.i/y),q.push(_.i/y),e(d),d=_.next,E=_.next;continue}if(d=_,d===E){x?x===1?(d=t(n(d),q,y),h(d,q,y,P,w,R,2)):x===2&&m(d,q,y,P,w,R):h(n(d),q,y,P,w,R,1);break}}},p=d=>{const q=d.prev,y=d,P=d.next;if(a(q,y,P)>=0)return!1;let w=d.next.next;for(;w!==d.prev;){if(u(q.x,q.y,y.x,y.y,P.x,P.y,w.x,w.y)&&a(w.prev,w,w.next)>=0)return!1;w=w.next}return!0},g=(d,q,y,P)=>{const w=d.prev,R=d,x=d.next;if(a(w,R,x)>=0)return!1;const E=w.x<R.x?w.x<x.x?w.x:x.x:R.x<x.x?R.x:x.x,A=w.y<R.y?w.y<x.y?w.y:x.y:R.y<x.y?R.y:x.y,_=w.x>R.x?w.x>x.x?w.x:x.x:R.x>x.x?R.x:x.x,S=w.y>R.y?w.y>x.y?w.y:x.y:R.y>x.y?R.y:x.y,b=l(E,A,q,y,P),T=l(_,S,q,y,P);let M=d.prevZ,$=d.nextZ;for(;M&&M.z>=b&&$&&$.z<=T;){if(M!==d.prev&&M!==d.next&&u(w.x,w.y,R.x,R.y,x.x,x.y,M.x,M.y)&&a(M.prev,M,M.next)>=0||(M=M.prevZ,$!==d.prev&&$!==d.next&&u(w.x,w.y,R.x,R.y,x.x,x.y,$.x,$.y)&&a($.prev,$,$.next)>=0))return!1;$=$.nextZ}for(;M&&M.z>=b;){if(M!==d.prev&&M!==d.next&&u(w.x,w.y,R.x,R.y,x.x,x.y,M.x,M.y)&&a(M.prev,M,M.next)>=0)return!1;M=M.prevZ}for(;$&&$.z<=T;){if($!==d.prev&&$!==d.next&&u(w.x,w.y,R.x,R.y,x.x,x.y,$.x,$.y)&&a($.prev,$,$.next)>=0)return!1;$=$.nextZ}return!0},m=(d,q,y,P,w,R)=>{let x=d;do{let E=x.next.next;for(;E!==x.prev;){if(x.i!==E.i&&s(x,E)){let A=c(x,E);x=n(x,x.next),A=n(A,A.next),h(x,q,y,P,w,R),h(A,q,y,P,w,R);return}E=E.next}x=x.next}while(x!==d)},v=(d,q,y,P)=>{let w=d;do w.z===null&&(w.z=l(w.x,w.y,q,y,P)),w.prevZ=w.prev,w.nextZ=w.next,w=w.next;while(w!==d);w.prevZ.nextZ=null,w.prevZ=null,r(w,R=>R.z)},l=(d,q,y,P,w)=>(d=32767*(d-y)*w,q=32767*(q-P)*w,d=(d|d<<8)&16711935,d=(d|d<<4)&252645135,d=(d|d<<2)&858993459,d=(d|d<<1)&1431655765,q=(q|q<<8)&16711935,q=(q|q<<4)&252645135,q=(q|q<<2)&858993459,q=(q|q<<1)&1431655765,d|q<<1);return Pi=f,Pi}var Ri,Pd;function d5(){if(Pd)return Ri;Pd=1;const{area:i}=qe(),{toOutlines:e}=z(),{arePointsInside:r}=qc(),t=s=>{const o=e(s),c=[],a=[];o.forEach((h,p)=>{const g=i(h);g<0?a.push(p):g>0&&c.push(p)});const u=[],f=[];return c.forEach((h,p)=>{const g=o[h];u[p]=[],a.forEach((m,v)=>{const l=o[m];r([l[0]],{vertices:g})&&(u[p].push(m),f[v]||(f[v]=[]),f[v].push(p))})}),a.forEach((h,p)=>{if(f[p]&&f[p].length>1){const g=n(f[p],m=>u[m].length);f[p].forEach((m,v)=>{v!==g&&(u[m]=u[m].filter(l=>l!==h))})}}),u.map((h,p)=>({solid:o[c[p]],holes:h.map(g=>o[g])}))},n=(s,o)=>{let c,a;return s.forEach((u,f)=>{const h=o(u);(a===void 0||h<a)&&(c=f,a=h)}),c};return Ri=t,Ri}var xi,Rd;function g5(){if(Rd)return xi;Rd=1;const i=z(),e=re(),r=I(),t=N(),n=mg(),s=d5();class o{constructor(a){this.plane=n(a);const u=t.orthogonal(t.create(),this.plane),f=t.cross(t.create(),this.plane,u);this.v=t.normalize(f,f),this.u=t.cross(t.create(),this.v,this.plane),this.basisMap=new Map;const h=a.edges.map(g=>g.map(m=>this.to2D(m))),p=i.create(h);this.roots=s(p)}to2D(a){const u=r.fromValues(t.dot(a,this.u),t.dot(a,this.v));return this.basisMap.set(u,a),u}to3D(a){const u=this.basisMap.get(a);if(u)return u;{console.log("Warning: point not in original slice");const f=t.scale(t.create(),this.u,a[0]),h=t.scale(t.create(),this.v,a[1]),p=t.scale(t.create(),e,e[3]),g=t.add(f,f,p);return t.add(h,h,g)}}}return xi=o,xi}var Ei,xd;function p5(){if(xd)return Ei;xd=1;const i=X(),e=h5(),r=g5();return Ei=n=>{const s=new r(n),o=[];return s.roots.forEach(({solid:c,holes:a})=>{let u=c.length;const f=[];a.forEach((v,l)=>{f.push(u),u+=v.length});const h=[c,...a].flat(),p=h.flat(),g=v=>s.to3D(h[v]),m=e(p,f);for(let v=0;v<m.length;v+=3){const l=m.slice(v,v+3).map(g);o.push(i.fromPointsAndPlane(l,s.plane))}}),o},Ei}var Ai,Ed;function m5(){if(Ed)return Ai;Ed=1;const i=N(),e=t=>t.reduce((n,s)=>n+=`[${i.toString(s[0])}, ${i.toString(s[1])}], `,"");return Ai=t=>`[${e(t.edges)}]`,Ai}var bi,Ad;function v5(){if(Ad)return bi;Ad=1;const i=N(),e=ue();return bi=(t,n)=>{const s=n.edges.map(o=>[i.transform(i.create(),o[0],t),i.transform(i.create(),o[1],t)]);return e(s)},bi}var $i,bd;function he(){return bd||(bd=1,$i={calculatePlane:mg(),clone:n5(),create:ue(),equals:s5(),fromPoints:o5(),fromSides:i5(),isA:a5(),reverse:c5(),toEdges:u5(),toPolygons:p5(),toString:m5(),transform:v5()}),$i}var Si,$d;function q5(){if($d)return Si;$d=1;const i=N(),e=ue();return Si=t=>{if(!t.edges)return t;let n=t.edges;const s=new Map,o=new Map;n=n.filter(u=>!i.equals(u[0],u[1])),n.forEach(u=>{const f=u[0].toString(),h=u[1].toString();s.set(f,u[0]),s.set(h,u[1]),o.set(f,(o.get(f)||0)+1),o.set(h,(o.get(h)||0)-1)});const c=[],a=[];return o.forEach((u,f)=>{u<0&&c.push(f),u>0&&a.push(f)}),c.forEach(u=>{const f=s.get(u);let h=1/0,p;a.forEach(g=>{const m=s.get(g),v=i.distance(f,m);v<h&&(h=v,p=m)}),console.warn(`slice.repair: repairing vertex gap ${f} to ${p} distance ${h}`),n=n.map(g=>g[0].toString()===u?[p,g[1]]:g[1].toString()===u?[g[0],p]:g)}),e(n)},Si}var Ti,Sd;function y5(){if(Sd)return Ti;Sd=1;const{EPS:i}=Y(),e=N(),r=X(),t=he(),n=(u,f)=>u===f?u:u<f?n(f,u):f===1?1:f===0?u:n(f,u%f),s=(u,f)=>u*f/n(u,f),o=(u,f)=>{const h=u/f.length;if(h===1)return f;const p=e.fromValues(h,h,h),g=[];return f.forEach(m=>{const v=e.subtract(e.create(),m[1],m[0]);e.divide(v,v,p);let l=m[0];for(let d=1;d<=h;++d){const q=e.add(e.create(),l,v);g.push([l,q]),l=q}}),g},c=i*i/2*Math.sin(Math.PI/3);return Ti=(u,f)=>{let h=t.toEdges(u),p=t.toEdges(f);if(h.length!==p.length){const m=s(h.length,p.length);m!==h.length&&(h=o(m,h)),m!==p.length&&(p=o(m,p))}const g=[];return h.forEach((m,v)=>{const l=p[v],d=r.create([m[0],m[1],l[1]]),q=r.measureArea(d);Number.isFinite(q)&&q>c&&g.push(d);const y=r.create([m[0],l[1],l[0]]),P=r.measureArea(y);Number.isFinite(P)&&P>c&&g.push(y)}),g},Ti}var Mi,Td;function Be(){if(Td)return Mi;Td=1;const i=K(),e=z(),r=L(),t=X(),n=he(),s=q5(),o=y5(),c=(u,f,h)=>{let p=null;return e.isA(h)&&(p=n.fromSides(e.toSides(h))),t.isA(h)&&(p=n.fromPoints(t.toPoints(h))),u===0||u===1?n.transform(i.fromTranslation(i.create(),[0,0,u]),p):null};return Mi=(u,f)=>{const h={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:c},{numberOfSlices:p,capStart:g,capEnd:m,close:v,repair:l,callback:d}=Object.assign({},h,u);if(p<2)throw new Error("numberOfSlices must be 2 or more");l&&(f=s(f));const q=p-1;let y=null,P=null,w=null,R=[];for(let x=0;x<p;x++){const E=d(x/q,x,f);if(E){if(!n.isA(E))throw new Error("the callback function must return slice objects");if(n.toEdges(E).length===0)throw new Error("the callback function must return slices with one or more edges");w&&(R=R.concat(o(w,E))),x===0&&(y=E),x===p-1&&(P=E),w=E}}if(m){const x=n.toPolygons(P);R=R.concat(x)}if(g){const x=n.toPolygons(y).map(t.invert);R=R.concat(x)}return!g&&!m&&v&&!n.equals(P,y)&&(R=R.concat(o(P,y))),r.create(R)},Mi}var _i,Md;function yg(){if(Md)return _i;Md=1;const{TAU:i}=Y(),e=K(),{mirrorX:r}=de(),t=z(),n=he(),s=Be();return _i=(c,a)=>{const u={segments:12,startAngle:0,angle:i,overflow:"cap"};let{segments:f,startAngle:h,angle:p,overflow:g}=Object.assign({},u,c);if(f<3)throw new Error("segments must be greater then 3");h=Math.abs(h)>i?h%i:h,p=Math.abs(p)>i?p%i:p;let m=h+p;if(m=Math.abs(m)>i?m%i:m,m<h){const A=h;h=m,m=A}let v=m-h;if(v<=0&&(v=i),Math.abs(v)<i){const A=i/f;f=Math.floor(Math.abs(v)/A),Math.abs(v)>f*A&&f++}let l=t.toSides(a);if(l.length===0)throw new Error("the given geometry cannot be empty");const d=l.filter(A=>A[0][0]<0),q=l.filter(A=>A[0][0]>=0);d.length>0&&q.length>0&&g==="cap"&&(d.length>q.length?(l=l.map(A=>{let _=A[0],S=A[1];return _=[Math.min(_[0],0),_[1]],S=[Math.min(S[0],0),S[1]],[_,S]}),a=t.create(l),a=r(a)):q.length>=d.length&&(l=l.map(A=>{let _=A[0],S=A[1];return _=[Math.max(_[0],0),_[1]],S=[Math.max(S[0],0),S[1]],[_,S]}),a=t.create(l)));const P=v/f,w=Math.abs(v)<i,R=n.fromSides(t.toSides(a));n.reverse(R,R);const x=e.create(),E=(A,_,S)=>{let b=P*_+h;return v===i&&_===f&&(b=h),e.multiply(x,e.fromZRotation(x,b),e.fromXRotation(e.create(),i/4)),n.transform(x,S)};return c={numberOfSlices:f+1,capStart:w,capEnd:w,close:!w,callback:E},s(c,R)},_i}var Ci,_d;function ge(){if(_d)return Ci;_d=1;const i=D(),e=K(),r=z(),t=L(),n=Q(),s=(u,...f)=>{if(!Array.isArray(u))throw new Error("angles must be an array");if(f=i(f),f.length===0)throw new Error("wrong number of arguments");for(u=u.slice();u.length<3;)u.push(0);const h=u[2],p=u[1],g=u[0],m=e.fromTaitBryanRotation(e.create(),h,p,g),v=f.map(l=>n.isA(l)?n.transform(m,l):r.isA(l)?r.transform(m,l):t.isA(l)?t.transform(m,l):l);return v.length===1?v[0]:v};return Ci={rotate:s,rotateX:(u,...f)=>s([u,0,0],f),rotateY:(u,...f)=>s([0,u,0],f),rotateZ:(u,...f)=>s([0,0,u],f)},Ci}var Fi,Cd;function ae(){if(Cd)return Fi;Cd=1;const i=D(),e=K(),r=z(),t=L(),n=Q(),s=(u,...f)=>{if(!Array.isArray(u))throw new Error("offset must be an array");if(f=i(f),f.length===0)throw new Error("wrong number of arguments");for(u=u.slice();u.length<3;)u.push(0);const h=e.fromTranslation(e.create(),u),p=f.map(g=>n.isA(g)?n.transform(h,g):r.isA(g)?r.transform(h,g):t.isA(g)?t.transform(h,g):g);return p.length===1?p[0]:p};return Fi={translate:s,translateX:(u,...f)=>s([u,0,0],f),translateY:(u,...f)=>s([0,u,0],f),translateZ:(u,...f)=>s([0,0,u],f)},Fi}var Bi,Fd;function w5(){if(Fd)return Bi;Fd=1;const{TAU:i}=Y(),e=yg(),{rotate:r}=ge(),{translate:t}=ae(),n=lg(),{isGT:s,isGTE:o}=j();return Bi=a=>{const u={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:i},{innerRadius:f,innerSegments:h,outerRadius:p,outerSegments:g,innerRotation:m,startAngle:v,outerRotation:l}=Object.assign({},u,a);if(!s(f,0))throw new Error("innerRadius must be greater than zero");if(!o(h,3))throw new Error("innerSegments must be three or more");if(!s(p,0))throw new Error("outerRadius must be greater than zero");if(!o(g,3))throw new Error("outerSegments must be three or more");if(!o(v,0))throw new Error("startAngle must be positive");if(!s(l,0))throw new Error("outerRotation must be greater than zero");if(f>=p)throw new Error("inner circle is too large to rotate about the outer circle");let d=n({radius:f,segments:h});return m!==0&&(d=r([0,0,m],d)),d=t([p,0],d),e({startAngle:v,angle:l,segments:g},d)},Bi}var Vi,Bd;function P5(){if(Bd)return Vi;Bd=1;const{NEPS:i}=Y(),e=I(),r=z(),{isNumberArray:t}=j(),n=(m,v,l)=>Math.acos((m*m+v*v-l*l)/(2*m*v)),s=(m,v,l)=>v>i?Math.sqrt(m*m+l*l-2*m*l*Math.cos(v)):Math.sqrt((m-l)*(m-l)+m*l*v*v*(1-v*v/12)),o=m=>{if(Math.abs(m[0]+m[1]+m[2]-Math.PI)>i)throw new Error("AAA triangles require angles that sum to PI");const l=m[0],d=m[1],q=Math.PI-l-d,y=1,P=y/Math.sin(q)*Math.sin(l),w=y/Math.sin(q)*Math.sin(d);return p(l,d,q,P,w,y)},c=m=>{const v=m[0],l=m[1],d=Math.PI+i-v-l;if(d<i)throw new Error("AAS triangles require angles that sum to PI");const q=m[2],y=q/Math.sin(v)*Math.sin(l),P=q/Math.sin(v)*Math.sin(d);return p(v,l,d,q,y,P)},a=m=>{const v=m[0],l=m[2],d=Math.PI+i-v-l;if(d<i)throw new Error("ASA triangles require angles that sum to PI");const q=m[1],y=q/Math.sin(d)*Math.sin(v),P=q/Math.sin(d)*Math.sin(l);return p(v,l,d,y,P,q)},u=m=>{const v=m[0],l=m[1],d=m[2],q=s(v,l,d),y=n(q,v,d),P=Math.PI-y-l;return p(y,l,P,d,q,v)},f=m=>{const v=m[0],l=m[1],d=m[2],q=Math.asin(l*Math.sin(d)/v),y=Math.PI-q-d,P=v/Math.sin(d)*Math.sin(y);return p(q,y,d,l,P,v)},h=m=>{const v=m[1],l=m[2],d=m[0];if(v+l<=d||l+d<=v||d+v<=l)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const q=n(l,d,v),y=n(d,v,l),P=Math.PI-q-y;return p(q,y,P,v,l,d)},p=(m,v,l,d,q,y)=>{const P=e.fromValues(0,0),w=e.fromValues(y,0),R=e.fromValues(d,0);return e.add(R,e.rotate(R,R,[0,0],Math.PI-v),w),r.fromPoints([P,w,R])};return Vi=m=>{const v={type:"SSS",values:[1,1,1]};let{type:l,values:d}=Object.assign({},v,m);if(typeof l!="string")throw new Error("triangle type must be a string");if(l=l.toUpperCase(),!((l[0]==="A"||l[0]==="S")&&(l[1]==="A"||l[1]==="S")&&(l[2]==="A"||l[2]==="S")))throw new Error("triangle type must contain three letters; A or S");if(!t(d,3))throw new Error("triangle values must contain three values");if(!d.every(q=>q>0))throw new Error("triangle values must be greater than zero");switch(l){case"AAA":return o(d);case"AAS":return c(d);case"ASA":return a(d);case"SAS":return u(d);case"SSA":return f(d);case"SSS":return h(d);default:throw new Error("invalid triangle type, try again")}},Vi}var Oi,Vd;function R5(){return Vd||(Vd=1,Oi={arc:Yv(),circle:lg(),cube:Uv(),cuboid:Ac(),cylinder:hg(),cylinderElliptic:fg(),ellipse:ug(),ellipsoid:dg(),geodesicSphere:Wv(),line:Qv(),polygon:Kv(),polyhedron:gg(),rectangle:bc(),roundedCuboid:Jv(),roundedCylinder:jv(),roundedRectangle:e5(),sphere:pg(),square:t5(),star:r5(),torus:w5(),triangle:P5()}),Oi}var ki,Od;function x5(){return Od||(Od=1,ki={height:14,32:[16],33:[10,5,21,5,7,void 0,5,2,4,1,5,0,6,1,5,2],34:[16,4,21,4,14,void 0,12,21,12,14],35:[21,11,25,4,-7,void 0,17,25,10,-7,void 0,4,12,18,12,void 0,3,6,17,6],36:[20,8,25,8,-4,void 0,12,25,12,-4,void 0,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],37:[24,21,21,3,0,void 0,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,void 0,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7],38:[26,23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2],39:[10,5,19,4,20,5,21,6,20,6,18,5,16,4,15],40:[14,11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7],41:[14,3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7],42:[16,8,21,8,9,void 0,3,18,13,12,void 0,13,18,3,12],43:[26,13,18,13,0,void 0,4,9,22,9],44:[10,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],45:[26,4,9,22,9],46:[10,5,2,4,1,5,0,6,1,5,2],47:[22,20,25,2,-7],48:[20,9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21],49:[20,6,17,8,18,11,21,11,0],50:[20,4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0],51:[20,5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],52:[20,13,21,3,7,18,7,void 0,13,21,13,0],53:[20,15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],54:[20,16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7],55:[20,17,21,7,0,void 0,3,21,17,21],56:[20,8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21],57:[20,16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3],58:[10,5,14,4,13,5,12,6,13,5,14,void 0,5,2,4,1,5,0,6,1,5,2],59:[10,5,14,4,13,5,12,6,13,5,14,void 0,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],60:[24,20,18,4,9,20,0],61:[26,4,12,22,12,void 0,4,6,22,6],62:[24,4,18,20,9,4,0],63:[18,3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,void 0,9,2,8,1,9,0,10,1,9,2],64:[27,18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,void 0,12,16,10,14,9,11,9,8,10,6,11,5,void 0,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,void 0,19,16,18,8,18,6,19,5],65:[18,9,21,1,0,void 0,9,21,17,0,void 0,4,7,14,7],66:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,void 0,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0],67:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5],68:[21,4,21,4,0,void 0,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0],69:[19,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11,void 0,4,0,17,0],70:[18,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11],71:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,void 0,13,8,18,8],72:[22,4,21,4,0,void 0,18,21,18,0,void 0,4,11,18,11],73:[8,4,21,4,0],74:[16,12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7],75:[21,4,21,4,0,void 0,18,21,4,7,void 0,9,12,18,0],76:[17,4,21,4,0,void 0,4,0,16,0],77:[24,4,21,4,0,void 0,4,21,12,0,void 0,20,21,12,0,void 0,20,21,20,0],78:[22,4,21,4,0,void 0,4,21,18,0,void 0,18,21,18,0],79:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21],80:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10],81:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,void 0,12,4,18,-2],82:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,void 0,11,11,18,0],83:[20,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],84:[16,8,21,8,0,void 0,1,21,15,21],85:[22,4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21],86:[18,1,21,9,0,void 0,17,21,9,0],87:[24,2,21,7,0,void 0,12,21,7,0,void 0,12,21,17,0,void 0,22,21,17,0],88:[20,3,21,17,0,void 0,17,21,3,0],89:[18,1,21,9,11,9,0,void 0,17,21,9,11],90:[20,17,21,3,0,void 0,3,21,17,21,void 0,3,0,17,0],91:[14,4,25,4,-7,void 0,5,25,5,-7,void 0,4,25,11,25,void 0,4,-7,11,-7],92:[14,0,21,14,-3],93:[14,9,25,9,-7,void 0,10,25,10,-7,void 0,3,25,10,25,void 0,3,-7,10,-7],94:[16,6,15,8,18,10,15,void 0,3,12,8,17,13,12,void 0,8,17,8,0],95:[16,0,-2,16,-2],96:[10,6,21,5,20,4,18,4,16,5,15,6,16,5,17],97:[19,15,14,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],98:[19,4,21,4,0,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],99:[18,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],100:[19,15,21,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],101:[18,3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],102:[12,10,21,8,21,6,20,5,17,5,0,void 0,2,14,9,14],103:[19,15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],104:[19,4,21,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],105:[8,3,21,4,20,5,21,4,22,3,21,void 0,4,14,4,0],106:[10,5,21,6,20,7,21,6,22,5,21,void 0,6,14,6,-3,5,-6,3,-7,1,-7],107:[17,4,21,4,0,void 0,14,14,4,4,void 0,8,8,15,0],108:[8,4,21,4,0],109:[30,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0,void 0,15,10,18,13,20,14,23,14,25,13,26,10,26,0],110:[19,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],111:[19,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14],112:[19,4,14,4,-7,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],113:[19,15,14,15,-7,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],114:[13,4,14,4,0,void 0,4,8,5,11,7,13,9,14,12,14],115:[17,14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3],116:[12,5,21,5,4,6,1,8,0,10,0,void 0,2,14,9,14],117:[19,4,14,4,4,5,1,7,0,10,0,12,1,15,4,void 0,15,14,15,0],118:[16,2,14,8,0,void 0,14,14,8,0],119:[22,3,14,7,0,void 0,11,14,7,0,void 0,11,14,15,0,void 0,19,14,15,0],120:[17,3,14,14,0,void 0,14,14,3,0],121:[16,2,14,8,0,void 0,14,14,8,0,6,-4,4,-6,2,-7,1,-7],122:[17,14,14,3,0,void 0,3,14,14,14,void 0,3,0,14,0],123:[14,9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,void 0,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,void 0,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7],124:[8,4,25,4,-7],125:[14,5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,void 0,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,void 0,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7],126:[24,3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,void 0,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]}),ki}var Ni,kd;function wg(){if(kd)return Ni;kd=1;const e={xOffset:0,yOffset:0,input:"?",align:"left",font:x5(),height:14,lineSpacing:2.142857142857143,letterSpacing:1,extrudeOffset:0};return Ni=(t,n)=>{!n&&typeof t=="string"&&(t={input:t}),t=t||{};const s=Object.assign({},e,t);return s.input=n||s.input,s},Ni}var Gi,Nd;function Pg(){if(Nd)return Gi;Nd=1;const i=wg();return Gi=(r,t)=>{const{xOffset:n,yOffset:s,input:o,font:c,height:a,extrudeOffset:u}=i(r,t);let f=o.charCodeAt(0);(!f||!c[f])&&(f=63);const h=[].concat(c[f]),p=(a-u)/c.height,g=u/2,m=h.shift()*p,v=[];let l=[];for(let d=0,q=h.length;d<q;d+=2){const y=p*h[d]+n,P=p*h[d+1]+s+g;if(h[d]!==void 0){l.push([y,P]);continue}v.push(l),l=[],d--}return l.length&&v.push(l),{width:m,height:a,segments:v}},Gi}var Di,Gd;function E5(){if(Gd)return Di;Gd=1;const i=Pg(),e=wg(),r=(n,s)=>{const{x:o,y:c}=Object.assign({x:0,y:0},n||{}),a=s.segments;let u=null,f=null;for(let h=0,p=a.length;h<p;h++){u=a[h];for(let g=0,m=u.length;g<m;g++)f=u[g],u[g]=[f[0]+o,f[1]+c]}return s};return Di=(n,s)=>{const{xOffset:o,yOffset:c,input:a,font:u,height:f,align:h,extrudeOffset:p,lineSpacing:g,letterSpacing:m}=e(n,s);let[v,l]=[o,c],d,q,y,P,w,R,x={width:0,segments:[]};const E=[];let A=[],_=0;const S=v,b=()=>{E.push(x),_=Math.max(_,x.width),x={width:0,segments:[]}};for(d=0,q=a.length;d<q;d++){if(y=a[d],P=i({xOffset:v,yOffset:l,font:u,height:f,extrudeOffset:p},y),y===`
`){v=S,l-=P.height*g,b();continue}w=P.width*m,x.width+=w,v+=w,y!==" "&&(x.segments=x.segments.concat(P.segments))}for(x.segments.length&&b(),d=0,q=E.length;d<q;d++)x=E[d],_>x.width&&(R=_-x.width,h==="right"?x=r({x:R},x):h==="center"&&(x=r({x:R/2},x))),A=A.concat(x.segments);return A},Di}var zi,Dd;function A5(){return Dd||(Dd=1,zi={vectorChar:Pg(),vectorText:E5()}),zi}var Li,zd;function we(){if(zd)return Li;zd=1;const i=z(),e=L(),r=Q();return Li=n=>{let s;for(const o of n){let c=0;if(i.isA(o)&&(c=1),e.isA(o)&&(c=2),r.isA(o)&&(c=3),s&&c!==s)return!1;s=c}return!0},Li}var Ii,Ld;function b5(){return Ld||(Ld=1,Ii=e=>e*.017453292519943295),Ii}var Hi,Id;function Rg(){return Id||(Id=1,Hi=(e,r)=>e-r),Hi}var Zi,Hd;function $5(){return Hd||(Hd=1,Zi=(e,r,t)=>{let n=0,s=e.length;for(;s>n;){const o=Math.floor((n+s)/2),c=e[o];t(r,c)>0?n=o+1:s=o}e.splice(n,0,r)}),Zi}var Xi,Zd;function S5(){if(Zd)return Xi;Zd=1;const{TAU:i}=Y();return Xi=(r,t,n)=>{const s=t>0?r*i/t:0,o=n>0?i/n:0;return Math.ceil(Math.max(s,o,4))},Xi}var Yi,Xd;function T5(){return Xd||(Xd=1,Yi=e=>e*57.29577951308232),Yi}var Ui,Yd;function xg(){return Yd||(Yd=1,Ui={areAllShapesTheSameType:we(),degToRad:b5(),flatten:D(),fnNumberSort:Rg(),insertSorted:$5(),radiusToSegments:S5(),radToDeg:T5()}),Ui}var Wi,Ud;function Sc(){if(Ud)return Wi;Ud=1;const i=I(),e=z(),r=(n,s)=>{if(s.vertices.length<4)return null;const o=[],c=s.vertices.filter((f,h)=>f[2]>0?(o.push(h),!0):!1);if(c.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const a=c.map(f=>{const h=Math.round(f[0]/n)*n+0,p=Math.round(f[1]/n)*n+0;return i.fromValues(h,p)});if(i.equals(a[0],a[1]))return null;const u=o[1]-o[0];if(u===1||u===3)u===1&&a.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return a};return Wi=(n,s)=>{const o=s.map(c=>r(n,c)).filter(c=>c!==null);return e.create(o)},Wi}var Qi,Wd;function Tc(){if(Wd)return Qi;Wd=1;const i=N(),e=z(),r=L(),t=X(),n=(o,c,a)=>{const u=[i.fromVec2(i.create(),a[0],o),i.fromVec2(i.create(),a[1],o),i.fromVec2(i.create(),a[1],c),i.fromVec2(i.create(),a[0],c)];return t.create(u)};return Qi=(o,c)=>{const u=e.toSides(c).map(h=>n(o.z0,o.z1,h));return r.create(u)},Qi}var Ki,Qd;function M5(){if(Qd)return Ki;Qd=1;const i=K(),e=I(),r=N(),t=function(n,s){arguments.length<2&&(s=r.orthogonal(r.create(),n)),this.v=r.normalize(r.create(),r.cross(r.create(),n,s)),this.u=r.cross(r.create(),this.v,n),this.plane=n,this.planeorigin=r.scale(r.create(),n,n[3])};return t.prototype={getProjectionMatrix:function(){return i.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const n=r.scale(r.create(),this.plane,this.plane[3]);return i.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,n[0],n[1],n[2],1)},to2D:function(n){return e.fromValues(r.dot(n,this.u),r.dot(n,this.v))},to3D:function(n){const s=r.scale(r.create(),this.u,n[0]),o=r.scale(r.create(),this.v,n[1]),c=r.add(s,s,this.planeorigin);return r.add(o,o,c)}},Ki=t,Ki}var Ji,Kd;function _5(){if(Kd)return Ji;Kd=1;const{EPS:i}=Y(),e=xc(),r=I(),t=M5(),n=rg(),{insertSorted:s,fnNumberSort:o}=xg(),c=X();return Ji=u=>{if(u.length<2)return u;const f=[],h=u.length,p=c.plane(u[0]),g=new t(p),m=[],v=[],l=new Map,d=new Map,q=new Map,y=10/i;for(let x=0;x<h;x++){const E=u[x];let A=[],_=E.vertices.length,S=-1;if(_>0){let b,T;for(let M=0;M<_;M++){let $=g.to2D(E.vertices[M]);const C=Math.floor($[1]*y);let F;q.has(C)?F=q.get(C):q.has(C+1)?F=q.get(C+1):q.has(C-1)?F=q.get(C-1):(F=$[1],q.set(C,$[1])),$=r.fromValues($[0],F),A.push($);const B=$[1];(M===0||B<b)&&(b=B,S=M),(M===0||B>T)&&(T=B);let O=d.get(B);O||(O={},d.set(B,O)),O[x]=!0}if(b>=T)A=[],_=0,S=-1;else{let M=l.get(b);M||(M=[],l.set(b,M)),M.push(x)}}A.reverse(),S=_-S-1,m.push(A),v.push(S)}const P=[];d.forEach((x,E)=>P.push(E)),P.sort(o);let w=[],R=[];for(let x=0;x<P.length;x++){const E=[],A=P[x],_=d.get(A);for(let b=0;b<w.length;++b){const T=w[b],M=T.polygonindex;if(_[M]){const $=m[M],C=$.length;let F=T.leftvertexindex,B=T.rightvertexindex;for(;;){let V=F+1;if(V>=C&&(V=0),$[V][1]!==A)break;F=V}let O=B-1;if(O<0&&(O=C-1),$[O][1]===A&&(B=O),F!==T.leftvertexindex&&F===B)w.splice(b,1),--b;else{T.leftvertexindex=F,T.rightvertexindex=B,T.topleft=$[F],T.topright=$[B];let V=F+1;V>=C&&(V=0),T.bottomleft=$[V];let k=B-1;k<0&&(k=C-1),T.bottomright=$[k]}}}let S;if(x>=P.length-1)w=[],S=null;else{S=Number(P[x+1]);const b=.5*(A+S),T=l.get(A);for(const M in T){const $=T[M],C=m[$],F=C.length,B=v[$];let O=B;for(;;){let U=O+1;if(U>=F&&(U=0),C[U][1]!==A||U===B)break;O=U}let V=B;for(;;){let U=V-1;if(U<0&&(U=F-1),C[U][1]!==A||U===O)break;V=U}let k=O+1;k>=F&&(k=0);let G=V-1;G<0&&(G=F-1);const Z={polygonindex:$,leftvertexindex:O,rightvertexindex:V,topleft:C[O],topright:C[V],bottomleft:C[k],bottomright:C[G]};s(w,Z,(U,J)=>{const W=n(U.topleft,U.bottomleft,b),H=n(J.topleft,J.bottomleft,b);return W>H?1:W<H?-1:0})}}for(const b in w){const T=w[b];let M=n(T.topleft,T.bottomleft,A);const $=r.fromValues(M,A);M=n(T.topright,T.bottomright,A);const C=r.fromValues(M,A);M=n(T.topleft,T.bottomleft,S);const F=r.fromValues(M,S);M=n(T.topright,T.bottomright,S);const B=r.fromValues(M,S),O={topleft:$,topright:C,bottomleft:F,bottomright:B,leftline:e.fromPoints(e.create(),$,F),rightline:e.fromPoints(e.create(),B,C)};if(E.length>0){const V=E[E.length-1],k=r.distance(O.topleft,V.topright),G=r.distance(O.bottomleft,V.bottomright);k<i&&G<i&&(O.topleft=V.topleft,O.leftline=V.leftline,O.bottomleft=V.bottomleft,E.splice(E.length-1,1))}E.push(O)}if(x>0){const b=new Set,T=new Set;for(let M=0;M<E.length;M++){const $=E[M];for(let C=0;C<R.length;C++)if(!T.has(C)){const F=R[C];if(r.distance(F.bottomleft,$.topleft)<i&&r.distance(F.bottomright,$.topright)<i){T.add(C);const B=e.direction($.leftline),O=e.direction(F.leftline),V=B[0]-O[0],k=e.direction($.rightline),G=e.direction(F.rightline),Z=k[0]-G[0],U=Math.abs(V)<i,J=Math.abs(Z)<i,W=U||V>=0,H=J||Z>=0;W&&H&&($.outpolygon=F.outpolygon,$.leftlinecontinues=U,$.rightlinecontinues=J,b.add(C));break}}}for(let M=0;M<R.length;M++)if(!b.has(M)){const $=R[M];$.outpolygon.rightpoints.push($.bottomright),r.distance($.bottomright,$.bottomleft)>i&&$.outpolygon.leftpoints.push($.bottomleft),$.outpolygon.leftpoints.reverse();const F=$.outpolygon.rightpoints.concat($.outpolygon.leftpoints).map(O=>g.to3D(O)),B=c.fromPointsAndPlane(F,p);B.vertices.length&&f.push(B)}}for(let b=0;b<E.length;b++){const T=E[b];T.outpolygon?(T.leftlinecontinues||T.outpolygon.leftpoints.push(T.topleft),T.rightlinecontinues||T.outpolygon.rightpoints.push(T.topright)):(T.outpolygon={leftpoints:[],rightpoints:[]},T.outpolygon.leftpoints.push(T.topleft),r.distance(T.topleft,T.topright)>i&&T.outpolygon.rightpoints.push(T.topright))}R=E}return f},Ji}var ji,Jd;function Pe(){if(Jd)return ji;Jd=1;const i=L(),e=X(),{NEPS:r}=Y(),t=_5(),n=c=>{if(c.isRetesselated)return c;const a=i.toPolygons(c).map((p,g)=>({vertices:p.vertices,plane:e.plane(p),index:g})),u=s(a),f=[];u.forEach(p=>{if(Array.isArray(p)){const g=t(p);f.push(...g)}else f.push(p)});const h=i.create(f);return h.isRetesselated=!0,h},s=c=>{let a=[c];const u=[];for(let h=3;h>=0;h--){const p=[],g=h===3?15e-9:r;a.forEach(m=>{m.sort(o(h,g));let v=0;for(let l=1;l<m.length;l++)m[l].plane[h]-m[v].plane[h]>g&&(l-v===1?u.push(m[v]):p.push(m.slice(v,l)),v=l);m.length-v===1?u.push(m[v]):p.push(m.slice(v))}),a=p}const f=[];return a.forEach(h=>{h[0]&&(f[h[0].index]=h)}),u.forEach(h=>{f[h.index]=h}),f},o=(c,a)=>(u,f)=>u.plane[c]-f.plane[c]>a?1:f.plane[c]-u.plane[c]>a?-1:0;return ji=n,ji}var ea,jd;function Mc(){if(jd)return ea;jd=1;const{EPS:i}=Y(),e=ce();return ea=(t,n)=>{if(t.polygons.length===0||n.polygons.length===0)return!1;const s=e(t),o=s[0],c=s[1],a=e(n),u=a[0],f=a[1];return!(u[0]-c[0]>i||o[0]-f[0]>i||u[1]-c[1]>i||o[1]-f[1]>i||u[2]-c[2]>i||o[2]-f[2]>i)},ea}var ta,e0;function C5(){if(e0)return ta;e0=1;const i=re(),e=X();class r{constructor(n){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=n}invert(){const n=[this];let s;for(let o=0;o<n.length;o++){s=n[o],s.plane&&(s.plane=i.flip(i.create(),s.plane)),s.front&&n.push(s.front),s.back&&n.push(s.back);const c=s.front;s.front=s.back,s.back=c}}clipPolygons(n,s){let o={node:this,polygontreenodes:n},c;const a=[];do{if(c=o.node,n=o.polygontreenodes,c.plane){const u=c.plane,f=[],h=[],p=s?f:h,g=n.length;for(let v=0;v<g;v++){const l=n[v];l.isRemoved()||l.splitByPlane(u,p,f,h,f)}c.front&&h.length>0&&a.push({node:c.front,polygontreenodes:h});const m=f.length;if(c.back&&m>0)a.push({node:c.back,polygontreenodes:f});else for(let v=0;v<m;v++)f[v].remove()}o=a.pop()}while(o!==void 0)}clipTo(n,s){let o=this;const c=[];do o.polygontreenodes.length>0&&n.rootnode.clipPolygons(o.polygontreenodes,s),o.front&&c.push(o.front),o.back&&c.push(o.back),o=c.pop();while(o!==void 0)}addPolygonTreeNodes(n){let s={node:this,polygontreenodes:n};const o=[];do{const c=s.node,a=s.polygontreenodes;if(a.length===0){s=o.pop();continue}if(!c.plane){let p=0;p=Math.floor(a.length/2);const g=a[p].getPolygon();c.plane=e.plane(g)}const u=[],f=[],h=a.length;for(let p=0;p<h;++p)a[p].splitByPlane(c.plane,c.polygontreenodes,f,u,f);u.length>0&&(c.front||(c.front=new r(c)),h===u.length&&f.length===0?c.front.polygontreenodes=u:o.push({node:c.front,polygontreenodes:u})),f.length>0&&(c.back||(c.back=new r(c)),h===f.length&&u.length===0?c.back.polygontreenodes=f:o.push({node:c.back,polygontreenodes:f})),s=o.pop()}while(s!==void 0)}}return ta=r,ta}var ra,t0;function F5(){if(t0)return ra;t0=1;const i=N();return ra=(r,t,n)=>{const s=i.subtract(i.create(),n,t);let o=(r[3]-i.dot(r,t))/i.dot(r,s);return Number.isNaN(o)&&(o=0),o>1&&(o=1),o<0&&(o=0),i.scale(s,s,o),i.add(s,t,s),s},ra}var na,r0;function B5(){if(r0)return na;r0=1;const{EPS:i}=Y(),e=re(),r=N(),t=X(),n=F5();return na=(o,c)=>{const a={type:null,front:null,back:null},u=c.vertices,f=u.length,h=t.plane(c);if(e.equals(h,o))a.type=0;else{let p=!1,g=!1;const m=[],v=-i;for(let l=0;l<f;l++){const d=r.dot(o,u[l])-o[3],q=d<v;m.push(q),d>i&&(p=!0),d<v&&(g=!0)}if(!p&&!g){const l=r.dot(o,h);a.type=l>=0?0:1}else if(!g)a.type=2;else if(!p)a.type=3;else{a.type=4;const l=[],d=[];let q=m[0];for(let P=0;P<f;P++){const w=u[P];let R=P+1;R>=f&&(R=0);const x=m[R];if(q===x)q?d.push(w):l.push(w);else{const E=u[R],A=n(o,w,E);q?(d.push(w),d.push(A),l.push(A)):(l.push(w),l.push(A),d.push(A))}q=x}const y=i*i;if(d.length>=3){let P=d[d.length-1];for(let w=0;w<d.length;w++){const R=d[w];r.squaredDistance(R,P)<y&&(d.splice(w,1),w--),P=R}}if(l.length>=3){let P=l[l.length-1];for(let w=0;w<l.length;w++){const R=l[w];r.squaredDistance(R,P)<y&&(l.splice(w,1),w--),P=R}}l.length>=3&&(a.front=t.fromPointsAndPlane(l,h)),d.length>=3&&(a.back=t.fromPointsAndPlane(d,h))}}return a},na}var sa,n0;function V5(){if(n0)return sa;n0=1;const{EPS:i}=Y(),e=N(),r=X(),t=B5();class n{constructor(o,c){this.parent=o,this.children=[],this.polygon=c,this.removed=!1}addPolygons(o){if(!this.isRootNode())throw new Error("Assertion failed");const c=this;o.forEach(a=>{c.addChild(a)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const o=this.parent.children,c=o.indexOf(this);if(c<0)throw new Error("Assertion failed");o.splice(c,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(o){let c=[this];const a=[c];let u,f,h,p;for(u=0;u<a.length;++u)for(c=a[u],f=0,h=c.length;f<h;f++)p=c[f],p.polygon?o.push(p.polygon):p.children.length>0&&a.push(p.children)}splitByPlane(o,c,a,u,f){if(this.children.length){const h=[this.children];let p,g,m,v,l;for(p=0;p<h.length;p++)for(l=h[p],g=0,m=l.length;g<m;g++)v=l[g],v.children.length>0?h.push(v.children):v._splitByPlane(o,c,a,u,f)}else this._splitByPlane(o,c,a,u,f)}_splitByPlane(o,c,a,u,f){const h=this.polygon;if(h){const p=r.measureBoundingSphere(h),g=p[3]+i,m=p,v=e.dot(o,m)-o[3];if(v>g)u.push(this);else if(v<-g)f.push(this);else{const l=t(o,h);switch(l.type){case 0:c.push(this);break;case 1:a.push(this);break;case 2:u.push(this);break;case 3:f.push(this);break;case 4:if(l.front){const d=this.addChild(l.front);u.push(d)}if(l.back){const d=this.addChild(l.back);f.push(d)}break}}}}addChild(o){const c=new n(this,o);return this.children.push(c),c}invertSub(){let o=[this];const c=[o];let a,u,f,h;for(a=0;a<c.length;a++)for(o=c[a],u=0,f=o.length;u<f;u++)h=o[u],h.polygon&&(h.polygon=r.invert(h.polygon)),h.children.length>0&&c.push(h.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let o=[this];const c=[o];for(let a=0;a<c.length;++a){o=c[a];const u=o.length;for(let f=0;f<u;f++){const h=o[f];h.polygon&&(h.polygon=null),h.parent&&(h.parent=null),h.children.length>0&&c.push(h.children),h.children=[]}}}toString(){let o="",c=[this];const a=[c];let u,f,h,p;for(u=0;u<a.length;++u){c=a[u];const g=" ".repeat(u);for(f=0,h=c.length;f<h;f++)p=c[f],o+=`${g}PolygonTreeNode (${p.isRootNode()}): ${p.children.length}`,p.polygon?o+=`
 ${g}polygon: ${p.polygon.vertices}
`:o+=`
`,p.children.length>0&&a.push(p.children)}return o}}return sa=n,sa}var oa,s0;function O5(){if(s0)return oa;s0=1;const i=C5(),e=V5();class r{constructor(n){this.polygonTree=new e,this.rootnode=new i(null),n&&this.addPolygons(n)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(n,s=!1){this.rootnode.clipTo(n,s)}allPolygons(){const n=[];return this.polygonTree.getPolygons(n),n}addPolygons(n){const s=new Array(n.length);for(let o=0;o<n.length;o++)s[o]=this.polygonTree.addChild(n[o]);this.rootnode.addPolygonTreeNodes(s)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}}return oa=r,oa}var ia,o0;function _c(){return o0||(o0=1,ia={Tree:O5()}),ia}var aa,i0;function k5(){if(i0)return aa;i0=1;const i=L(),e=Mc(),{Tree:r}=_c();return aa=(n,s)=>{if(!e(n,s))return i.create();const o=new r(i.toPolygons(n)),c=new r(i.toPolygons(s));o.invert(),c.clipTo(o),c.invert(),o.clipTo(c),c.clipTo(o),o.addPolygons(c.allPolygons()),o.invert();const a=o.allPolygons();return i.create(a)},aa}var ca,a0;function Eg(){if(a0)return ca;a0=1;const i=D(),e=Pe(),r=k5();return ca=(...n)=>{n=i(n);let s=n.shift();return n.forEach(o=>{s=r(s,o)}),s=e(s),s},ca}var ua,c0;function N5(){if(c0)return ua;c0=1;const i=D(),e=L(),r=se(),t=Sc(),n=Tc(),s=Eg();return ua=(...c)=>{c=i(c);const a=c.map(h=>n({z0:-1,z1:1},h)),u=s(a),f=r(u);return t(f,e.toPolygons(u))},ua}var la,u0;function G5(){if(u0)return la;u0=1;const i=D(),e=we(),r=z(),t=L(),n=N5(),s=Eg();return la=(...c)=>{if(c=i(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only intersect of the types are supported");const a=c[0];return r.isA(a)?n(c):t.isA(a)?s(c):a},la}var fa,l0;function D5(){if(l0)return fa;l0=1;const i=N(),e=se(),r=L(),t=c=>c.sort((a,u)=>a-u).filter((a,u,f)=>!u||a!==f[u-1]),n=(c,a,u)=>{const f=`${a}`,h=c.get(f);h===void 0?c.set(f,[u]):h.push(u)},s=(c,a)=>{const u=`${a}`;return c.get(u)};return fa=c=>{const a=e(c),u=r.toPolygons(c),f=u.length,h=new Map,p=i.create();u.forEach((d,q)=>{d.vertices.forEach(y=>{n(h,i.snap(p,y,a),q)})});const g=u.map(d=>{let q=[];return d.vertices.forEach(y=>{q=q.concat(s(h,i.snap(p,y,a)))}),{e:1,d:t(q)}});h.clear();let m=0;const v=g.length;for(let d=0;d<v;d++){const q=g[d];if(q.e>0){const y=new Array(f);y[d]=!0;do m=0,y.forEach((P,w)=>{const R=g[w];if(R.e>0){R.e=-1;for(let x=0;x<R.d.length;x++)y[R.d[x]]=!0;m++}});while(m>0);q.indexes=y}}const l=[];for(let d=0;d<v;d++)if(g[d].indexes){const q=[];g[d].indexes.forEach((y,P)=>q.push(u[P])),l.push(r.create(q))}return l},fa}var ha,f0;function z5(){if(f0)return ha;f0=1;const i=D(),e=L(),r=D5();return ha=(...n)=>{if(n=i(n),n.length===0)throw new Error("wrong number of arguments");const s=n.map(o=>e.isA(o)?r(o):o);return s.length===1?s[0]:s},ha}var da,h0;function L5(){if(h0)return da;h0=1;const i=L(),e=Mc(),{Tree:r}=_c();return da=(n,s)=>{if(!e(n,s))return i.clone(n);const o=new r(i.toPolygons(n)),c=new r(i.toPolygons(s));o.invert(),o.clipTo(c),c.clipTo(o,!0),o.addPolygons(c.allPolygons()),o.invert();const a=o.allPolygons();return i.create(a)},da}var ga,d0;function Ag(){if(d0)return ga;d0=1;const i=D(),e=Pe(),r=L5();return ga=(...n)=>{n=i(n);let s=n.shift();return n.forEach(o=>{s=r(s,o)}),s=e(s),s},ga}var pa,g0;function I5(){if(g0)return pa;g0=1;const i=D(),e=L(),r=se(),t=Sc(),n=Tc(),s=Ag();return pa=(...c)=>{c=i(c);const a=c.map(h=>n({z0:-1,z1:1},h)),u=s(a),f=r(u);return t(f,e.toPolygons(u))},pa}var ma,p0;function H5(){if(p0)return ma;p0=1;const i=D(),e=we(),r=z(),t=L(),n=I5(),s=Ag();return ma=(...c)=>{if(c=i(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only subtract of the types are supported");const a=c[0];return r.isA(a)?n(c):t.isA(a)?s(c):a},ma}var va,m0;function bg(){if(m0)return va;m0=1;const i=L(),e=Mc(),{Tree:r}=_c(),t=(s,o)=>{if(!e(s,o))return n(s,o);const c=new r(i.toPolygons(s)),a=new r(i.toPolygons(o));c.clipTo(a,!1),a.clipTo(c),a.invert(),a.clipTo(c),a.invert();const u=c.allPolygons().concat(a.allPolygons());return i.create(u)},n=(s,o)=>{let c=i.toPolygons(s);return c=c.concat(i.toPolygons(o)),i.create(c)};return va=t,va}var qa,v0;function $g(){if(v0)return qa;v0=1;const i=D(),e=Pe(),r=bg();return qa=(...n)=>{n=i(n);let s;for(s=1;s<n.length;s+=2)n.push(r(n[s-1],n[s]));let o=n[s-1];return o=e(o),o},qa}var ya,q0;function Sg(){if(q0)return ya;q0=1;const i=D(),e=L(),r=se(),t=Sc(),n=Tc(),s=$g();return ya=(...c)=>{c=i(c);const a=c.map(h=>n({z0:-1,z1:1},h)),u=s(a),f=r(u);return t(f,e.toPolygons(u))},ya}var wa,y0;function Cc(){if(y0)return wa;y0=1;const i=D(),e=we(),r=z(),t=L(),n=Sg(),s=$g();return wa=(...c)=>{if(c=i(c),c.length===0)throw new Error("wrong number of arguments");if(!e(c))throw new Error("only unions of the same type are supported");const a=c[0];return r.isA(a)?n(c):t.isA(a)?s(c):a},wa}var Pa,w0;function Z5(){return w0||(w0=1,Pa={intersect:G5(),scission:z5(),subtract:H5(),union:Cc()}),Pa}var Ra,P0;function Ve(){if(P0)return Ra;P0=1;const{EPS:i,TAU:e}=Y(),r=ng(),t=xc(),n=I(),s=Ce();return Ra=(c,a)=>{const u={delta:1,corners:"edge",closed:!1,segments:16};let{delta:f,corners:h,closed:p,segments:g}=Object.assign({},u,c);if(Math.abs(f)<i)return a;let m=c.closed?s(a):1;m===0&&(m=1);const v=m>0&&f>=0||m<0&&f<0;f=Math.abs(f);let l=null,d=[];const q=[],y=n.create(),P=a.length;for(let w=0;w<P;w++){const R=(w+1)%P,x=a[w],E=a[R];v?n.subtract(y,x,E):n.subtract(y,E,x),n.normal(y,y),n.normalize(y,y),n.scale(y,y,f);const A=n.add(n.create(),x,y),_=n.add(n.create(),E,y),S=[A,_];if(l!=null&&(p||!p&&R!==0)){const b=r(l[0],l[1],S[0],S[1]);b?(d.pop(),S[0]=b):q.push({c:x,s0:l,s1:S})}l=[A,_],!(R===0&&!p)&&(d.push(S[0]),d.push(S[1]))}if(p&&l!=null){const w=d[0],R=d[1],x=r(l[0],l[1],w,R);if(x)d[0]=x,d.pop();else{const E=a[0],A=[w,R];q.push({c:E,s0:l,s1:A})}}if(h==="edge"){const w=new Map;d.forEach((E,A)=>w.set(E,A));const R=t.create(),x=t.create();q.forEach(E=>{t.fromPoints(R,E.s0[0],E.s0[1]),t.fromPoints(x,E.s1[0],E.s1[1]);const A=t.intersectPointOfLines(R,x);if(Number.isFinite(A[0])&&Number.isFinite(A[1])){const _=E.s0[1],S=w.get(_);d[S]=A,d[(S+1)%d.length]=void 0}else{const _=E.s1[0],S=w.get(_);d[S]=void 0}}),d=d.filter(E=>E!==void 0)}if(h==="round"){let w=Math.floor(g/4);const R=n.create();q.forEach(x=>{let E=n.angle(n.subtract(R,x.s1[0],x.c));if(E-=n.angle(n.subtract(R,x.s0[1],x.c)),v&&E<0&&(E=E+Math.PI,E<0&&(E=E+Math.PI)),!v&&E>0&&(E=E-Math.PI,E>0&&(E=E-Math.PI)),E!==0){w=Math.floor(g*(Math.abs(E)/e));const A=E/w,_=n.angle(n.subtract(R,x.s0[1],x.c)),S=[];for(let b=1;b<w;b++){const T=_+A*b,M=n.fromAngleRadians(n.create(),T);n.scale(M,M,f),n.add(M,M,x.c),S.push(M)}if(S.length>0){const b=x.s0[1];let T=d.findIndex(M=>n.equals(b,M));T=(T+1)%d.length,d.splice(T,0,...S)}}else{const A=x.s1[0],_=d.findIndex(S=>n.equals(A,S));d.splice(_,1)}})}return d},Ra}var xa,R0;function X5(){if(R0)return xa;R0=1;const i=z(),e=Ve();return xa=(t,n)=>{const s={delta:1,corners:"edge",segments:16},{delta:o,corners:c,segments:a}=Object.assign({},s,t);if(!(c==="edge"||c==="chamfer"||c==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const h=i.toOutlines(n).map(p=>(t={delta:o,corners:c,closed:!0,segments:a},e(t,p))).reduce((p,g)=>p.concat(i.toSides(i.fromPoints(g))),[]);return i.create(h)},xa}var Ea,x0;function Y5(){if(x0)return Ea;x0=1;const i=K(),e=N(),r=L(),t=X();return Ea=(s,o)=>{e.dot(t.plane(o),s)>0&&(o=t.invert(o));const a=[o],u=t.transform(i.fromTranslation(i.create(),s),o),f=o.vertices.length;for(let h=0;h<f;h++){const p=h<f-1?h+1:0,g=t.create([o.vertices[h],u.vertices[h],u.vertices[p],o.vertices[p]]);a.push(g)}return a.push(t.invert(u)),r.create(a)},Ea}var Aa,E0;function U5(){if(E0)return Aa;E0=1;const{EPS:i,TAU:e}=Y(),r=K(),t=N(),n=Rg(),s=L(),o=X(),c=pg(),a=Pe(),u=bg(),f=Y5(),h=(v,l,d)=>{const q=l.toString();if(v.has(q))v.get(q)[1].push(d);else{const y=[l,[d]];v.set(q,y)}},p=(v,l,d)=>{const q=l[0].toString(),y=l[1].toString(),P=q<y?`${q},${y}`:`${y},${q}`;if(v.has(P))v.get(P)[1].push(d);else{const w=[l,[d]];v.set(P,w)}},g=(v,l)=>{v.findIndex(q=>q===l)<0&&v.push(l)};return Aa=(v,l)=>{const d={delta:1,segments:12},{delta:q,segments:y}=Object.assign({},d,v);let P=s.create();const w=new Map,R=new Map,x=t.create(),E=t.create();return s.toPolygons(l).forEach((_,S)=>{const b=t.scale(t.create(),o.plane(_),2*q),T=o.transform(r.fromTranslation(r.create(),t.scale(t.create(),b,-.5)),_),M=f(b,T);P=u(P,M);const $=_.vertices;for(let C=0;C<$.length;C++){h(w,$[C],o.plane(_));const F=(C+1)%$.length,B=[$[C],$[F]];p(R,B,o.plane(_))}}),R.forEach(_=>{const S=_[0],b=_[1],T=S[0],M=S[1],$=t.subtract(t.create(),M,T);t.normalize($,$);const C=b[0],F=t.cross(t.create(),C,$);let B=[];for(let W=0;W<y;W++)g(B,W*e/y);for(let W=0,H=b.length;W<H;W++){const oe=b[W],ne=t.dot(F,oe),ie=t.dot(C,oe);let te=Math.atan2(ne,ie);te<0&&(te+=e),g(B,te),te=Math.atan2(-ne,-ie),te<0&&(te+=e),g(B,te)}B=B.sort(n);const O=B.length;let V,k;const G=[],Z=[],U=[];for(let W=-1;W<O;W++){const H=B[W<0?W+O:W],oe=Math.sin(H),ne=Math.cos(H);t.scale(x,C,ne*q),t.scale(E,F,oe*q),t.add(x,x,E);const ie=t.add(t.create(),T,x),te=t.add(t.create(),M,x);let Oc=!1;if(W>=0&&t.distance(ie,V)<i&&(Oc=!0),!Oc){if(W>=0){G.push(ie),Z.push(te);const Cg=[k,te,ie,V],Fg=o.create(Cg);U.push(Fg)}V=ie,k=te}}Z.reverse(),U.push(o.create(G)),U.push(o.create(Z));const J=s.create(U);P=u(P,J)}),w.forEach(_=>{const S=_[0],b=_[1],T=b[0];let M=null,$=0;for(let O=1;O<b.length;O++){const V=b[O],k=t.cross(x,T,V),G=t.length(k);G>.05&&G>$&&($=G,M=V)}M||(M=t.orthogonal(x,T));const C=t.cross(x,T,M);t.normalize(C,C);const F=t.cross(E,C,T),B=c({center:[S[0],S[1],S[2]],radius:q,segments:y,axes:[T,C,F]});P=u(P,B)}),a(P)},Aa}var ba,A0;function W5(){if(A0)return ba;A0=1;const i=L(),e=Cc(),r=U5();return ba=(n,s)=>{const o={delta:1,corners:"round",segments:12},{delta:c,corners:a,segments:u}=Object.assign({},o,n);if(a!=="round")throw new Error('corners must be "round" for 3D geometries');if(i.toPolygons(s).length===0)throw new Error("the given geometry cannot be empty");n={delta:c,corners:a,segments:u};const h=r(n,s);return e(s,h)},ba}var $a,b0;function Q5(){if(b0)return $a;b0=1;const i=Ce(),e=I(),r=z(),t=Q(),n=Ve(),s=a=>{let{external:u,internal:f}=a;i(u)<0?u=u.reverse():f=f.reverse();const h=t.fromPoints({closed:!0},u),p=t.fromPoints({closed:!0},f),g=r.toSides(r.fromPoints(t.toPoints(h))),m=r.toSides(r.fromPoints(t.toPoints(p)));return g.push(...m),r.create(g)},o=(a,u,f,h)=>{const{points:p,external:g,internal:m}=a,v=Math.floor(u/2),l=[],d=[];if(f==="round"&&v>0){const y=Math.PI/v,P=p[p.length-1],w=e.angle(e.subtract(e.create(),g[g.length-1],P)),R=p[0],x=e.angle(e.subtract(e.create(),m[0],R));for(let E=1;E<v;E++){let A=w+y*E,_=e.fromAngleRadians(e.create(),A);e.scale(_,_,h),e.add(_,_,P),l.push(_),A=x+y*E,_=e.fromAngleRadians(e.create(),A),e.scale(_,_,h),e.add(_,_,R),d.push(_)}}const q=[];return q.push(...g,...l,...m.reverse(),...d),r.fromPoints(q)};return $a=(a,u)=>{a=Object.assign({},{delta:1,corners:"edge",segments:16},a);const{delta:h,corners:p,segments:g}=a;if(h<=0)throw new Error("the given delta must be positive for paths");if(!(p==="edge"||p==="chamfer"||p==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const m=u.isClosed,v=t.toPoints(u);if(v.length===0)throw new Error("the given geometry cannot be empty");const l={points:v,external:n({delta:h,corners:p,segments:g,closed:m},v),internal:n({delta:-h,corners:p,segments:g,closed:m},v)};return u.isClosed?s(l):o(l,g,p,h)},$a}var Sa,$0;function Fc(){if($0)return Sa;$0=1;const i=D(),e=z(),r=L(),t=Q(),n=X5(),s=W5(),o=Q5();return Sa=(a,...u)=>{if(u=i(u),u.length===0)throw new Error("wrong number of arguments");const f=u.map(h=>t.isA(h)?o(a,h):e.isA(h)?n(a,h):r.isA(h)?s(a,h):h);return f.length===1?f[0]:f},Sa}var Ta,S0;function K5(){if(S0)return Ta;S0=1;const i=z(),e=qc(),r=Ve();return Ta=(n,s)=>{const o={delta:1,corners:"edge",segments:0},{delta:c,corners:a,segments:u}=Object.assign({},o,n);if(!(a==="edge"||a==="chamfer"||a==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const f=i.toOutlines(s),p=f.map(g=>(n={delta:f.reduce((l,d)=>l+e.arePointsInside(g,e.create(d)),0)%2===0?c:-c,corners:a,closed:!0,segments:u},r(n,g))).reduce((g,m)=>g.concat(i.toSides(i.fromPoints(m))),[]);return i.create(p)},Ta}var Ma,T0;function J5(){if(T0)return Ma;T0=1;const i=Q(),e=Ve();return Ma=(t,n)=>{const s={delta:1,corners:"edge",closed:n.isClosed,segments:16},{delta:o,corners:c,closed:a,segments:u}=Object.assign({},s,t);if(!(c==="edge"||c==="chamfer"||c==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');t={delta:o,corners:c,closed:a,segments:u};const f=e(t,i.toPoints(n));return i.fromPoints({closed:a},f)},Ma}var _a,M0;function j5(){if(M0)return _a;M0=1;const i=D(),e=z(),r=Q(),t=K5(),n=J5();return _a=(o,...c)=>{if(c=i(c),c.length===0)throw new Error("wrong number of arguments");const a=c.map(u=>r.isA(u)?n(o,u):e.isA(u)?t(o,u):u);return a.length===1?a[0]:a},_a}var Ca,_0;function e3(){return _0||(_0=1,Ca={expand:Fc(),offset:j5()}),Ca}var Fa,C0;function Oe(){if(C0)return Fa;C0=1;const i=K(),e=N(),r=z(),t=he(),n=Be();return Fa=(o,c)=>{const a={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:u,twistAngle:f,twistSteps:h,repair:p}=Object.assign({},a,o);if(h<1)throw new Error("twistSteps must be 1 or more");f===0&&(h=1);const g=e.clone(u),m=r.toSides(c);if(m.length===0)throw new Error("the given geometry cannot be empty");const v=t.fromSides(m);g[2]<0&&t.reverse(v,v);const l=i.create(),d=(q,y,P)=>{const w=y/h*f,R=e.scale(e.create(),g,y/h);return i.multiply(l,i.fromZRotation(l,w),i.fromTranslation(i.create(),R)),t.transform(l,P)};return o={numberOfSlices:h+1,capStart:!0,capEnd:!0,repair:p,callback:d},n(o,v)},Fa}var Ba,F0;function t3(){if(F0)return Ba;F0=1;const i=z(),e=Q(),r=Oe();return Ba=(n,s)=>{if(!s.isClosed)throw new Error("extruded path must be closed");const o=e.toPoints(s),c=i.fromPoints(o);return r(n,c)},Ba}var Va,B0;function r3(){if(B0)return Va;B0=1;const i=D(),e=z(),r=Q(),t=Oe(),n=t3();return Va=(o,...c)=>{const a={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:u,twistAngle:f,twistSteps:h,repair:p}=Object.assign({},a,o);if(c=i(c),c.length===0)throw new Error("wrong number of arguments");o={offset:[0,0,u],twistAngle:f,twistSteps:h,repair:p};const g=c.map(m=>r.isA(m)?n(o,m):e.isA(m)?t(o,m):m);return g.length===1?g[0]:g},Va}var Oa,V0;function n3(){if(V0)return Oa;V0=1;const i=Q(),e=Fc(),r=Oe();return Oa=(n,s)=>{const o={size:1,height:1},{size:c,height:a}=Object.assign({},o,n);if(n.delta=c,n.offset=[0,0,a],i.toPoints(s).length===0)throw new Error("the given geometry cannot be empty");const f=e(n,s);return r(n,f)},Oa}var ka,O0;function s3(){if(O0)return ka;O0=1;const{area:i}=qe(),e=z(),r=Q(),t=Fc(),n=Oe();return ka=(o,c)=>{const a={size:1,height:1},{size:u,height:f}=Object.assign({},a,o);o.delta=u,o.offset=[0,0,f];const h=e.toOutlines(c);if(h.length===0)throw new Error("the given geometry cannot be empty");const g=h.map(v=>(i(v)<0&&v.reverse(),t(o,r.fromPoints({closed:!0},v)))).reduce((v,l)=>v.concat(e.toSides(l)),[]),m=e.create(g);return n(o,m)},ka}var Na,k0;function o3(){if(k0)return Na;k0=1;const i=D(),e=z(),r=Q(),t=n3(),n=s3();return Na=(o,...c)=>{const a={size:1,height:1},{size:u,height:f}=Object.assign({},a,o);if(c=i(c),c.length===0)throw new Error("wrong number of arguments");if(u<=0)throw new Error("size must be positive");if(f<=0)throw new Error("height must be positive");const h=c.map(p=>r.isA(p)?t(o,p):e.isA(p)?n(o,p):p);return h.length===1?h[0]:h},Na}var Ga,N0;function i3(){if(N0)return Ga;N0=1;const{TAU:i}=Y(),e=K(),r=z(),t=Be(),n=he();return Ga=(o,c)=>{const a={angle:i,startAngle:0,pitch:10,height:0,endOffset:0,segmentsPerRotation:32};let{angle:u,startAngle:f,pitch:h,height:p,endOffset:g,segmentsPerRotation:m}=Object.assign({},a,o);if(p!=0&&(h=p/(u/i)),m<3)throw new Error("The number of segments per rotation needs to be at least 3.");const l=r.toSides(c);if(l.length===0)throw new Error("The given geometry cannot be empty");const d=l.filter(E=>E[0][0]>=0);let q=n.fromSides(l);d.length===0&&(q=n.reverse(q));const y=Math.round(m/i*Math.abs(u)),P=y>=2?y:2,w=e.create(),R=e.create(),x=(E,A,_)=>{const S=f+u/P*A,b=g/P*A,T=(S-f)/i*h;return e.multiply(w,e.fromTranslation(e.create(),[b,0,T*Math.sign(u)]),e.fromXRotation(e.create(),-i/4*Math.sign(u))),e.multiply(R,e.fromZRotation(e.create(),S),w),n.transform(R,_)};return t({numberOfSlices:P+1,callback:x},q)},Ga}var Da,G0;function a3(){if(G0)return Da;G0=1;const i=D(),e=Rc(),r=re(),t=K(),n=z(),s=L(),o=X(),c=se(),a=Sg(),u=(h,p)=>{const g=r.fromNormalAndPoint(r.create(),h.axis,h.origin);if(Number.isNaN(g[0])||Number.isNaN(g[1])||Number.isNaN(g[2])||Number.isNaN(g[3]))throw new Error("project: invalid axis or origin");const m=c(p),v=m*m*Math.sqrt(3)/4;if(m===0)return n.create();const l=s.toPolygons(p);let d=[];for(let y=0;y<l.length;y++){const P=l[y].vertices.map(x=>r.projectionOfPoint(g,x)),w=o.create(P),R=o.plane(w);e(g,R)&&(o.measureArea(w)<v||d.push(w))}if(!e(g,[0,0,1])){const y=t.fromVectorRotation(t.create(),g,[0,0,1]);d=d.map(P=>o.transform(y,P))}d=d.sort((y,P)=>o.measureArea(P)-o.measureArea(y));const q=d.map(y=>n.fromPoints(y.vertices));return a(q)};return Da=(h,...p)=>{const g={axis:[0,0,1],origin:[0,0,0]},{axis:m,origin:v}=Object.assign({},g,h);if(p=i(p),p.length===0)throw new Error("wrong number of arguments");h={axis:m,origin:v};const l=p.map(d=>s.isA(d)?u(h,d):d);return l.length===1?l[0]:l},Da}var za,D0;function c3(){return D0||(D0=1,za={extrudeFromSlices:Be(),extrudeLinear:r3(),extrudeRectangular:o3(),extrudeRotate:yg(),extrudeHelical:i3(),project:a3(),slice:he()}),za}var La,z0;function Bc(){if(z0)return La;z0=1;const i=I(),e=n=>{let s=i.fromValues(1/0,1/0);n.forEach(a=>{(a[1]<s[1]||a[1]===s[1]&&a[0]<s[0])&&(s=a)});const o=[];n.forEach(a=>{const u=t(a[1]-s[1],a[0]-s[0]),f=i.squaredDistance(a,s);o.push({point:a,angle:u,distSq:f})}),o.sort((a,u)=>a.angle!==u.angle?a.angle-u.angle:a.distSq-u.distSq);const c=[];return o.forEach(a=>{let u=c.length;for(;u>1&&r(c[u-2],c[u-1],a.point)<=Number.EPSILON;)c.pop(),u=c.length;c.push(a.point)}),c},r=(n,s,o)=>(s[0]-n[0])*(o[1]-n[1])-(s[1]-n[1])*(o[0]-n[0]),t=(n,s)=>n===0&&s===0?-1/0:-s/n;return La=e,La}var Ia,L0;function Vc(){if(L0)return Ia;L0=1;const i=z(),e=L(),r=Q();return Ia=n=>{const s=new Set,o=[],c=a=>{const u=a.toString();s.has(u)||(o.push(a),s.add(u))};return n.forEach(a=>{i.isA(a)?i.toPoints(a).forEach(c):e.isA(a)?e.toPoints(a).forEach(u=>u.forEach(c)):r.isA(a)&&r.toPoints(a).forEach(c)}),o},Ia}var Ha,I0;function u3(){if(I0)return Ha;I0=1;const i=D(),e=Q(),r=Bc(),t=Vc();return Ha=(...s)=>{s=i(s);const o=t(s),c=r(o);return e.fromPoints({closed:!0},c)},Ha}var Za,H0;function l3(){if(H0)return Za;H0=1;const i=D(),e=z(),r=Bc(),t=Vc();return Za=(...s)=>{s=i(s);const o=t(s),c=r(o);return c.length<3?e.create():e.fromPoints(c)},Za}var Xa,Z0;function Tg(){if(Z0)return Xa;Z0=1;const i=X(),e=S2();return Xa=t=>e(t,{skipTriangulation:!0}).map(o=>{const c=o.map(a=>t[a]);return i.create(c)}),Xa}var Ya,X0;function f3(){if(X0)return Ya;X0=1;const i=D(),e=L(),r=Vc(),t=Tg();return Ya=(...s)=>{s=i(s);const o=r(s);return o.length===0?e.create():e.create(t(o))},Ya}var Ua,Y0;function Mg(){if(Y0)return Ua;Y0=1;const i=D(),e=we(),r=z(),t=L(),n=Q(),s=u3(),o=l3(),c=f3();return Ua=(...u)=>{if(u=i(u),u.length===0)throw new Error("wrong number of arguments");if(!e(u))throw new Error("only hulls of the same type are supported");const f=u[0];return n.isA(f)?s(u):r.isA(f)?o(u):t.isA(f)?c(u):f},Ua}var Wa,U0;function h3(){if(U0)return Wa;U0=1;const i=D(),e=Cc(),r=Mg();return Wa=(...n)=>{if(n=i(n),n.length<2)throw new Error("wrong number of arguments");const s=[];for(let o=1;o<n.length;o++)s.push(r(n[o-1],n[o]));return e(s)},Wa}var Qa,W0;function d3(){return W0||(W0=1,Qa={hull:Mg(),hullChain:h3(),hullPoints2:Bc(),hullPoints3:Tg()}),Qa}var Ka,Q0;function _g(){if(Q0)return Ka;Q0=1;const i=N(),e=X(),r=(n,s)=>{const o=Math.abs(e.measureArea(s));return Number.isFinite(o)&&o>n};return Ka=(n,s)=>{let o=s.map(a=>{const u=a.vertices.map(p=>i.snap(i.create(),p,n)),f=[];for(let p=0;p<u.length;p++){const g=(p+1)%u.length;i.equals(u[p],u[g])||f.push(u[p])}const h=e.create(f);return a.color&&(h.color=a.color),h});const c=n*n*Math.sqrt(3)/4;return o=o.filter(a=>r(c,a)),o},Ka}var Ja,K0;function g3(){if(K0)return Ja;K0=1;const i=Rc(),e=N(),r=X(),t=v=>{const l=r.toPoints(v),d=[];for(let q=0;q<l.length;q++){const y=(q+1)%l.length,P={v1:l[q],v2:l[y]};d.push(P)}for(let q=0;q<d.length;q++){const y=(q+1)%l.length;d[q].next=d[y],d[y].prev=d[q]}return d},n=(v,l)=>{const d=`${l.v1}:${l.v2}`;v.set(d,l)},s=(v,l)=>{const d=`${l.v1}:${l.v2}`;v.delete(d)},o=(v,l)=>{const d=`${l.v2}:${l.v1}`;return v.get(d)},c=(v,l,d)=>{let q=v.prev.v1,y=v.prev.v2,P=l.next.v2;const w=f(q,y,P,d);q=l.prev.v1,y=l.prev.v2,P=v.next.v2;const R=f(q,y,P,d);return[w,R]},a=e.create(),u=e.create(),f=(v,l,d,q)=>{const y=e.subtract(a,l,v),P=e.subtract(u,d,l);return e.cross(y,y,P),e.dot(y,q)},h=v=>{let l;const d=[];for(;v.next;){const q=v.next;d.push(v.v1),v.v1=null,v.v2=null,v.next=null,v.prev=null,v=q}return d.length>0&&(l=r.create(d)),l},p=v=>{if(v.length<2)return v;const l=v[0].plane,d=v.slice(),q=new Map;for(;d.length>0;){const P=d.shift(),w=t(P);for(let R=0;R<w.length;R++){const x=w[R],E=o(q,x);if(E){const A=c(x,E,l);if(A[0]>=0&&A[1]>=0){const _=E.next,S=x.next;x.prev.next=E.next,x.next.prev=E.prev,E.prev.next=x.next,E.next.prev=x.prev,x.v1=null,x.v2=null,x.next=null,x.prev=null,s(q,E),E.v1=null,E.v2=null,E.next=null,E.prev=null;const b=(T,M,$)=>{const C={v1:$.v1,v2:M.v2,next:M.next,prev:$.prev};$.prev.next=C,M.next.prev=C,s(T,M),M.v1=null,M.v2=null,M.next=null,M.prev=null,s(T,$),$.v1=null,$.v2=null,$.next=null,$.prev=null};A[0]===0&&b(q,_,_.prev),A[1]===0&&b(q,S,S.prev)}}else x.next&&n(q,x)}}const y=[];return q.forEach(P=>{const w=h(P);w&&y.push(w)}),q.clear(),y},g=(v,l)=>Math.abs(v[3]-l[3])<15e-8?i(v,l):!1;return Ja=(v,l)=>{const d=[];l.forEach(y=>{const P=d.find(w=>g(w[0],r.plane(y)));P?P[1].push(y):d.push([r.plane(y),[y]])});let q=[];return d.forEach(y=>{const P=y[1],w=p(P);q=q.concat(w)}),q},Ja}var ja,J0;function p3(){if(J0)return ja;J0=1;const i=Y(),e=N(),r=X(),t=c=>`${c}`,n=(c,a,u,f,h,p)=>{const g=t(f),m=t(h),v=`${g}/${m}`,l=`${m}/${g}`;if(c.has(l))return s(c,a,u,h,f,null),null;const d={vertex0:f,vertex1:h,polygonindex:p};return c.has(v)?c.get(v).push(d):c.set(v,[d]),a.has(g)?a.get(g).push(v):a.set(g,[v]),u.has(m)?u.get(m).push(v):u.set(m,[v]),v},s=(c,a,u,f,h,p)=>{const g=t(f),m=t(h),v=`${g}/${m}`;let l=-1;const d=c.get(v);for(let q=0;q<d.length;q++){const y=d[q];let P=t(y.vertex0);if(P===g&&(P=t(y.vertex1),P===m&&!(p!==null&&y.polygonindex!==p))){l=q;break}}d.splice(l,1),d.length===0&&c.delete(v),l=a.get(g).indexOf(v),a.get(g).splice(l,1),a.get(g).length===0&&a.delete(g),l=u.get(m).indexOf(v),u.get(m).splice(l,1),u.get(m).length===0&&u.delete(m)};return ja=c=>{const a=new Map;for(let u=0;u<c.length;u++){const f=c[u],h=f.vertices.length;if(h>=3){let p=f.vertices[0],g=t(p);for(let m=0;m<h;m++){let v=m+1;v===h&&(v=0);const l=f.vertices[v],d=t(l),q=`${g}/${d}`,y=`${d}/${g}`;if(a.has(y)){const P=a.get(y);P.splice(-1,1),P.length===0&&a.delete(y)}else{const P={vertex0:p,vertex1:l,polygonindex:u};a.has(q)?a.get(q).push(P):a.set(q,[P])}p=l,g=d}}else console.warn("warning: invalid polygon found during insertTjunctions")}if(a.size>0){const u=new Map,f=new Map,h=new Map;for(const[g,m]of a)h.set(g,!0),m.forEach(v=>{const l=t(v.vertex0),d=t(v.vertex1);u.has(l)?u.get(l).push(g):u.set(l,[g]),f.has(d)?f.get(d).push(g):f.set(d,[g])});const p=c.slice(0);for(;a.size!==0;){for(const m of a.keys())h.set(m,!0);let g=!1;for(;;){const m=Array.from(h.keys());if(m.length===0)break;const v=m[0];let l=!0;if(a.has(v)){const q=a.get(v)[0];for(let y=0;y<2;y++){const P=y===0?q.vertex0:q.vertex1,w=y===0?q.vertex1:q.vertex0,R=t(P),x=t(w);let E=[];y===0?f.has(R)&&(E=f.get(R)):u.has(R)&&(E=u.get(R));for(let A=0;A<E.length;A++){const _=E[A],S=a.get(_)[0],b=y===0?S.vertex0:S.vertex1;if(y===0?S.vertex1:S.vertex0,t(b)===x){s(a,u,f,P,w,null),s(a,u,f,w,P,null),l=!1,y=2,g=!0;break}else{const M=P,$=w,C=b,F=e.subtract(e.create(),C,M),B=e.dot(e.subtract(e.create(),$,M),F)/e.dot(F,F);if(B>0&&B<1){const O=e.scale(e.create(),F,B);if(e.add(O,O,M),e.squaredDistance(O,$)<i.EPS*i.EPS){const k=S.polygonindex,G=p[k],Z=t(S.vertex1);let U=-1;for(let ne=0;ne<G.vertices.length;ne++)if(t(G.vertices[ne])===Z){U=ne;break}const J=G.vertices.slice(0);J.splice(U,0,w);const W=r.create(J);p[k]=W,s(a,u,f,S.vertex0,S.vertex1,k);const H=n(a,u,f,S.vertex0,w,k),oe=n(a,u,f,w,S.vertex1,k);H!==null&&h.set(H,!0),oe!==null&&h.set(oe,!0),l=!1,y=2,g=!0;break}}}}}}l&&h.delete(v)}if(!g)break}c=p}return a.clear(),c},ja}var ec,j0;function m3(){if(j0)return ec;j0=1;const i=N(),e=X(),r=(n,s,o)=>{const c=s.vertices.length;if(c>3){if(c>4){const f=[0,0,0];s.vertices.forEach(h=>i.add(f,f,h)),i.snap(f,i.divide(f,f,[c,c,c]),n);for(let h=0;h<c;h++){const p=e.create([f,s.vertices[h],s.vertices[(h+1)%c]]);s.color&&(p.color=s.color),o.push(p)}return}const a=e.create([s.vertices[0],s.vertices[1],s.vertices[2]]),u=e.create([s.vertices[0],s.vertices[2],s.vertices[3]]);s.color&&(a.color=s.color,u.color=s.color),o.push(a,u);return}o.push(s)};return ec=(n,s)=>{const o=[];return s.forEach(c=>{r(n,c,o)}),o},ec}var tc,e2;function v3(){if(e2)return tc;e2=1;const i=D(),e=se(),r=z(),t=L(),n=Q(),s=_g(),o=g3(),c=p3(),a=m3(),u=(g,m)=>m,f=(g,m)=>m,h=(g,m)=>{const v={snap:!1,simplify:!1,triangulate:!1},{snap:l,simplify:d,triangulate:q}=Object.assign({},v,g),y=e(m);let P=t.toPolygons(m);l&&(P=s(y,P)),d&&(P=o(y,P)),q&&(P=c(P),P=a(y,P));const w=Object.assign({},m);return w.polygons=P,w};return tc=(g,...m)=>{if(m=i(m),m.length===0)throw new Error("wrong number of arguments");const v=m.map(l=>{if(n.isA(l))return u(g,l);if(r.isA(l))return f(g,l);if(t.isA(l))return h(g,l);throw new Error("invalid geometry")});return v.length===1?v[0]:v},tc}var rc,t2;function q3(){if(t2)return rc;t2=1;const i=D(),e=I(),r=z(),t=L(),n=Q(),s=se(),o=_g(),c=h=>{const p=s(h),m=n.toPoints(h).map(v=>e.snap(e.create(),v,p));return n.create(m)},a=h=>{const p=s(h);let m=r.toSides(h).map(v=>[e.snap(e.create(),v[0],p),e.snap(e.create(),v[1],p)]);return m=m.filter(v=>!e.equals(v[0],v[1])),r.create(m)},u=h=>{const p=s(h),g=t.toPolygons(h),m=o(p,g);return t.create(m)};return rc=(...h)=>{if(h=i(h),h.length===0)throw new Error("wrong number of arguments");const p=h.map(g=>n.isA(g)?c(g):r.isA(g)?a(g):t.isA(g)?u(g):g);return p.length===1?p[0]:p},rc}var nc,r2;function y3(){return r2||(r2=1,nc={generalize:v3(),snap:q3(),retessellate:Pe()}),nc}var sc,n2;function w3(){return n2||(n2=1,sc=(e,r,t)=>{for(e=e.slice();e.length<t;)e.push(r);return e}),sc}var oc,s2;function P3(){if(s2)return oc;s2=1;const i=D(),e=w3(),r=Ec(),{translate:t}=ae(),n=a=>{if(!Array.isArray(a.modes)||a.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(a.modes=e(a.modes,"none",3),a.modes.filter(u=>["center","max","min","none"].includes(u)).length!==3)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(a.relativeTo)||a.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(a.relativeTo=e(a.relativeTo,0,3),a.relativeTo.filter(u=>Number.isFinite(u)||u==null).length!==3)throw new Error("align(): all relativeTo values must be a number, or null.");if(typeof a.grouped!="boolean")throw new Error("align(): grouped must be a boolean value.");return a},s=(a,u,f)=>{for(let h=0;h<3;h++)a[h]==null&&(u[h]==="center"?a[h]=(f[0][h]+f[1][h])/2:u[h]==="max"?a[h]=f[1][h]:u[h]==="min"&&(a[h]=f[0][h]));return a},o=(a,u,f)=>{const h=r(a),p=[0,0,0];for(let g=0;g<3;g++)u[g]==="center"?p[g]=f[g]-(h[0][g]+h[1][g])/2:u[g]==="max"?p[g]=f[g]-h[1][g]:u[g]==="min"&&(p[g]=f[g]-h[0][g]);return t(p,a)};return oc=(a,...u)=>{a=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},a),a=n(a);let{modes:h,relativeTo:p,grouped:g}=a;if(u=i(u),u.length===0)throw new Error("align(): No geometries were provided to act upon");if(p.filter(m=>m==null).length){const m=r(u);p=s(p,h,m)}return g?u=o(u,h,p):u=u.map(m=>o(m,h,p)),u.length===1?u[0]:u},oc}var ic,o2;function Re(){if(o2)return ic;o2=1;const i=D(),e=z(),r=L(),t=Q(),n=ce(),{translate:s}=ae(),o=(h,p)=>{const g={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:m,relativeTo:v}=Object.assign({},g,h),l=n(p),d=[0,0,0];return m[0]&&(d[0]=v[0]-(l[0][0]+(l[1][0]-l[0][0])/2)),m[1]&&(d[1]=v[1]-(l[0][1]+(l[1][1]-l[0][1])/2)),m[2]&&(d[2]=v[2]-(l[0][2]+(l[1][2]-l[0][2])/2)),s(d,p)},c=(h,...p)=>{const g={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:m,relativeTo:v}=Object.assign({},g,h);if(p=i(p),p.length===0)throw new Error("wrong number of arguments");if(v.length!==3)throw new Error("relativeTo must be an array of length 3");h={axes:m,relativeTo:v};const l=p.map(d=>t.isA(d)||e.isA(d)||r.isA(d)?o(h,d):d);return l.length===1?l[0]:l};return ic={center:c,centerX:(...h)=>c({axes:[!0,!1,!1]},h),centerY:(...h)=>c({axes:[!1,!0,!1]},h),centerZ:(...h)=>c({axes:[!1,!1,!0]},h)},ic}var ac,i2;function xe(){if(i2)return ac;i2=1;const i=D(),e=K(),r=z(),t=L(),n=Q(),s=(u,...f)=>{if(!Array.isArray(u))throw new Error("factors must be an array");if(f=i(f),f.length===0)throw new Error("wrong number of arguments");for(u=u.slice();u.length<3;)u.push(1);if(u[0]<=0||u[1]<=0||u[2]<=0)throw new Error("factors must be positive");const h=e.fromScaling(e.create(),u),p=f.map(g=>n.isA(g)?n.transform(h,g):r.isA(g)?r.transform(h,g):t.isA(g)?t.transform(h,g):g);return p.length===1?p[0]:p};return ac={scale:s,scaleX:(u,...f)=>s([u,1,1],f),scaleY:(u,...f)=>s([1,u,1],f),scaleZ:(u,...f)=>s([1,1,u],f)},ac}var cc,a2;function R3(){if(a2)return cc;a2=1;const i=D(),e=z(),r=L(),t=Q();return cc=(s,...o)=>{if(o=i(o),o.length===0)throw new Error("wrong number of arguments");const c=o.map(a=>t.isA(a)?t.transform(s,a):e.isA(a)?e.transform(s,a):r.isA(a)?r.transform(s,a):a);return c.length===1?c[0]:c},cc}var uc,c2;function x3(){return c2||(c2=1,uc={align:P3(),center:Re().center,centerX:Re().centerX,centerY:Re().centerY,centerZ:Re().centerZ,mirror:de().mirror,mirrorX:de().mirrorX,mirrorY:de().mirrorY,mirrorZ:de().mirrorZ,rotate:ge().rotate,rotateX:ge().rotateX,rotateY:ge().rotateY,rotateZ:ge().rotateZ,scale:xe().scale,scaleX:xe().scaleX,scaleY:xe().scaleY,scaleZ:xe().scaleZ,transform:R3(),translate:ae().translate,translateX:ae().translateX,translateY:ae().translateY,translateZ:ae().translateZ}),uc}var lc,u2;function E3(){return u2||(u2=1,lc={colors:av(),curves:dv(),geometries:yc(),maths:Nv(),measurements:Xv(),primitives:R5(),text:A5(),utils:xg(),booleans:Z5(),expansions:e3(),extrusions:c3(),hulls:d3(),modifiers:y3(),transforms:x3()}),lc}var A3=E3();const $3=Bg(A3);export{$3 as j,A3 as s};
